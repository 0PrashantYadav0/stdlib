/*
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// TypeScript Version: 2.0

/* tslint:disable:max-line-length */
/* tslint:disable:max-file-line-count */

import dapx = require( '@stdlib/blas/ext/base/dapx' );
import dapxsum = require( '@stdlib/blas/ext/base/dapxsum' );
import dapxsumkbn = require( '@stdlib/blas/ext/base/dapxsumkbn' );
import dapxsumkbn2 = require( '@stdlib/blas/ext/base/dapxsumkbn2' );
import dapxsumors = require( '@stdlib/blas/ext/base/dapxsumors' );
import dapxsumpw = require( '@stdlib/blas/ext/base/dapxsumpw' );
import dasumpw = require( '@stdlib/blas/ext/base/dasumpw' );
import dcusum = require( '@stdlib/blas/ext/base/dcusum' );
import dcusumkbn = require( '@stdlib/blas/ext/base/dcusumkbn' );
import dcusumkbn2 = require( '@stdlib/blas/ext/base/dcusumkbn2' );
import dcusumors = require( '@stdlib/blas/ext/base/dcusumors' );
import dcusumpw = require( '@stdlib/blas/ext/base/dcusumpw' );
import dfill = require( '@stdlib/blas/ext/base/dfill' );
import dnanasum = require( '@stdlib/blas/ext/base/dnanasum' );
import dnanasumors = require( '@stdlib/blas/ext/base/dnanasumors' );
import dnannsum = require( '@stdlib/blas/ext/base/dnannsum' );
import dnannsumkbn = require( '@stdlib/blas/ext/base/dnannsumkbn' );
import dnannsumkbn2 = require( '@stdlib/blas/ext/base/dnannsumkbn2' );
import dnannsumors = require( '@stdlib/blas/ext/base/dnannsumors' );
import dnannsumpw = require( '@stdlib/blas/ext/base/dnannsumpw' );
import dnansum = require( '@stdlib/blas/ext/base/dnansum' );
import dnansumkbn = require( '@stdlib/blas/ext/base/dnansumkbn' );
import dnansumkbn2 = require( '@stdlib/blas/ext/base/dnansumkbn2' );
import dnansumors = require( '@stdlib/blas/ext/base/dnansumors' );
import dnansumpw = require( '@stdlib/blas/ext/base/dnansumpw' );
import drev = require( '@stdlib/blas/ext/base/drev' );
import dsapxsum = require( '@stdlib/blas/ext/base/dsapxsum' );
import dsapxsumpw = require( '@stdlib/blas/ext/base/dsapxsumpw' );
import dsnannsumors = require( '@stdlib/blas/ext/base/dsnannsumors' );
import dsnansum = require( '@stdlib/blas/ext/base/dsnansum' );
import dsnansumors = require( '@stdlib/blas/ext/base/dsnansumors' );
import dsnansumpw = require( '@stdlib/blas/ext/base/dsnansumpw' );
import dsort2hp = require( '@stdlib/blas/ext/base/dsort2hp' );
import dsort2ins = require( '@stdlib/blas/ext/base/dsort2ins' );
import dsort2sh = require( '@stdlib/blas/ext/base/dsort2sh' );
import dsorthp = require( '@stdlib/blas/ext/base/dsorthp' );
import dsortins = require( '@stdlib/blas/ext/base/dsortins' );
import dsortsh = require( '@stdlib/blas/ext/base/dsortsh' );
import dssum = require( '@stdlib/blas/ext/base/dssum' );
import dssumors = require( '@stdlib/blas/ext/base/dssumors' );
import dssumpw = require( '@stdlib/blas/ext/base/dssumpw' );
import dsum = require( '@stdlib/blas/ext/base/dsum' );
import dsumkbn = require( '@stdlib/blas/ext/base/dsumkbn' );
import dsumkbn2 = require( '@stdlib/blas/ext/base/dsumkbn2' );
import dsumors = require( '@stdlib/blas/ext/base/dsumors' );
import dsumpw = require( '@stdlib/blas/ext/base/dsumpw' );
import gapx = require( '@stdlib/blas/ext/base/gapx' );
import gapxsum = require( '@stdlib/blas/ext/base/gapxsum' );
import gapxsumkbn = require( '@stdlib/blas/ext/base/gapxsumkbn' );
import gapxsumkbn2 = require( '@stdlib/blas/ext/base/gapxsumkbn2' );
import gapxsumors = require( '@stdlib/blas/ext/base/gapxsumors' );
import gapxsumpw = require( '@stdlib/blas/ext/base/gapxsumpw' );
import gasumpw = require( '@stdlib/blas/ext/base/gasumpw' );
import gcusum = require( '@stdlib/blas/ext/base/gcusum' );
import gcusumkbn = require( '@stdlib/blas/ext/base/gcusumkbn' );
import gcusumkbn2 = require( '@stdlib/blas/ext/base/gcusumkbn2' );
import gcusumors = require( '@stdlib/blas/ext/base/gcusumors' );
import gcusumpw = require( '@stdlib/blas/ext/base/gcusumpw' );
import gfill = require( '@stdlib/blas/ext/base/gfill' );
import gfillBy = require( '@stdlib/blas/ext/base/gfill-by' );
import gnannsumkbn = require( '@stdlib/blas/ext/base/gnannsumkbn' );
import gnansum = require( '@stdlib/blas/ext/base/gnansum' );
import gnansumkbn = require( '@stdlib/blas/ext/base/gnansumkbn' );
import gnansumkbn2 = require( '@stdlib/blas/ext/base/gnansumkbn2' );
import gnansumors = require( '@stdlib/blas/ext/base/gnansumors' );
import gnansumpw = require( '@stdlib/blas/ext/base/gnansumpw' );
import grev = require( '@stdlib/blas/ext/base/grev' );
import gsort2hp = require( '@stdlib/blas/ext/base/gsort2hp' );
import gsort2ins = require( '@stdlib/blas/ext/base/gsort2ins' );
import gsort2sh = require( '@stdlib/blas/ext/base/gsort2sh' );
import gsorthp = require( '@stdlib/blas/ext/base/gsorthp' );
import gsortins = require( '@stdlib/blas/ext/base/gsortins' );
import gsortsh = require( '@stdlib/blas/ext/base/gsortsh' );
import gsum = require( '@stdlib/blas/ext/base/gsum' );
import gsumkbn = require( '@stdlib/blas/ext/base/gsumkbn' );
import gsumkbn2 = require( '@stdlib/blas/ext/base/gsumkbn2' );
import gsumors = require( '@stdlib/blas/ext/base/gsumors' );
import gsumpw = require( '@stdlib/blas/ext/base/gsumpw' );
import sapx = require( '@stdlib/blas/ext/base/sapx' );
import sapxsum = require( '@stdlib/blas/ext/base/sapxsum' );
import sapxsumkbn = require( '@stdlib/blas/ext/base/sapxsumkbn' );
import sapxsumkbn2 = require( '@stdlib/blas/ext/base/sapxsumkbn2' );
import sapxsumors = require( '@stdlib/blas/ext/base/sapxsumors' );
import sapxsumpw = require( '@stdlib/blas/ext/base/sapxsumpw' );
import sasumpw = require( '@stdlib/blas/ext/base/sasumpw' );
import scusum = require( '@stdlib/blas/ext/base/scusum' );
import scusumkbn = require( '@stdlib/blas/ext/base/scusumkbn' );
import scusumkbn2 = require( '@stdlib/blas/ext/base/scusumkbn2' );
import scusumors = require( '@stdlib/blas/ext/base/scusumors' );
import scusumpw = require( '@stdlib/blas/ext/base/scusumpw' );
import sdsapxsum = require( '@stdlib/blas/ext/base/sdsapxsum' );
import sdsapxsumpw = require( '@stdlib/blas/ext/base/sdsapxsumpw' );
import sdsnansum = require( '@stdlib/blas/ext/base/sdsnansum' );
import sdsnansumpw = require( '@stdlib/blas/ext/base/sdsnansumpw' );
import sdssum = require( '@stdlib/blas/ext/base/sdssum' );
import sdssumpw = require( '@stdlib/blas/ext/base/sdssumpw' );
import sfill = require( '@stdlib/blas/ext/base/sfill' );
import snansum = require( '@stdlib/blas/ext/base/snansum' );
import snansumkbn = require( '@stdlib/blas/ext/base/snansumkbn' );
import snansumkbn2 = require( '@stdlib/blas/ext/base/snansumkbn2' );
import snansumors = require( '@stdlib/blas/ext/base/snansumors' );
import snansumpw = require( '@stdlib/blas/ext/base/snansumpw' );
import srev = require( '@stdlib/blas/ext/base/srev' );
import ssort2hp = require( '@stdlib/blas/ext/base/ssort2hp' );
import ssort2ins = require( '@stdlib/blas/ext/base/ssort2ins' );
import ssort2sh = require( '@stdlib/blas/ext/base/ssort2sh' );
import ssorthp = require( '@stdlib/blas/ext/base/ssorthp' );
import ssortins = require( '@stdlib/blas/ext/base/ssortins' );
import ssortsh = require( '@stdlib/blas/ext/base/ssortsh' );
import ssum = require( '@stdlib/blas/ext/base/ssum' );
import ssumkbn = require( '@stdlib/blas/ext/base/ssumkbn' );
import ssumkbn2 = require( '@stdlib/blas/ext/base/ssumkbn2' );
import ssumors = require( '@stdlib/blas/ext/base/ssumors' );
import ssumpw = require( '@stdlib/blas/ext/base/ssumpw' );

/**
* Interface describing the `base` namespace.
*/
interface BASE {
	/**
	* Adds a constant to each element in a double-precision floating-point strided array.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );
	*
	* dapx( x.length, 5.0, x, 1 );
	* // x => <Float64Array>[ 3.0, 6.0, 8.0, 0.0, 9.0, 5.0, 4.0, 2.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );
	*
	* dapx.ndarray( x.length, 5.0, x, 1, 0 );
	* // x => <Float64Array>[ 3.0, 6.0, 8.0, 0.0, 9.0, 5.0, 4.0, 2.0 ]
	*/
	dapx: typeof dapx;

	/**
	* Adds a constant to each double-precision floating-point strided array element and computes the sum.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dapxsum( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dapxsum.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	dapxsum: typeof dapxsum;

	/**
	* Adds a constant to each double-precision floating-point strided array element and computes the sum using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dapxsumkbn( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dapxsumkbn.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	dapxsumkbn: typeof dapxsumkbn;

	/**
	* Adds a constant to each double-precision floating-point strided array element and computes the sum using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dapxsumkbn2( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dapxsumkbn2.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	dapxsumkbn2: typeof dapxsumkbn2;

	/**
	* Adds a constant to each double-precision floating-point strided array element and computes the sum using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dapxsumors( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dapxsumors.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	dapxsumors: typeof dapxsumors;

	/**
	* Adds a constant to each double-precision floating-point strided array element and computes the sum using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dapxsumpw( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dapxsumpw.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	dapxsumpw: typeof dapxsumpw;

	/**
	* Computes the sum of absolute values (L1 norm) of double-precision floating-point strided array elements using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dasumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dasumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dasumpw: typeof dasumpw;

	/**
	* Computes the cumulative sum of double-precision floating-point strided array elements.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float64Array( x.length );
	*
	* dcusum( x.length, 0.0, x, 1, y, 1 );
	* // y => <Float64Array>[ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float64Array( x.length );
	*
	* dcusum.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => <Float64Array>[ 1.0, -1.0, 1.0 ]
	*/
	dcusum: typeof dcusum;

	/**
	* Computes the cumulative sum of double-precision floating-point strided array elements using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float64Array( x.length );
	*
	* dcusumkbn( x.length, 0.0, x, 1, y, 1 );
	* // y => <Float64Array>[ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float64Array( x.length );
	*
	* dcusumkbn.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => <Float64Array>[ 1.0, -1.0, 1.0 ]
	*/
	dcusumkbn: typeof dcusumkbn;

	/**
	* Computes the cumulative sum of double-precision floating-point strided array elements using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float64Array( x.length );
	*
	* dcusumkbn2( x.length, 0.0, x, 1, y, 1 );
	* // y => <Float64Array>[ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float64Array( x.length );
	*
	* dcusumkbn2.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => <Float64Array>[ 1.0, -1.0, 1.0 ]
	*/
	dcusumkbn2: typeof dcusumkbn2;

	/**
	* Computes the cumulative sum of double-precision floating-point strided array elements using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float64Array( x.length );
	*
	* dcusumors( x.length, 0.0, x, 1, y, 1 );
	* // y => <Float64Array>[ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float64Array( x.length );
	*
	* dcusumors.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => <Float64Array>[ 1.0, -1.0, 1.0 ]
	*/
	dcusumors: typeof dcusumors;

	/**
	* Computes the cumulative sum of double-precision floating-point strided array elements using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float64Array( x.length );
	*
	* dcusumpw( x.length, 0.0, x, 1, y, 1 );
	* // y => <Float64Array>[ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float64Array( x.length );
	*
	* dcusumpw.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => <Float64Array>[ 1.0, -1.0, 1.0 ]
	*/
	dcusumpw: typeof dcusumpw;

	/**
	* Fills a double-precision floating-point strided array with a specified scalar value.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );
	*
	* dfill( x.length, 5.0, x, 1 );
	* // x => <Float64Array>[ 5.0, 5.0, 5.0, 0.0, 5.0, 5.0, 5.0, 5.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );
	*
	* dfill.ndarray( x.length, 5.0, x, 1, 0 );
	* // x => <Float64Array>[ 5.0, 5.0, 5.0, 0.0, 5.0, 5.0, 5.0, 5.0 ]
	*/
	dfill: typeof dfill;

	/**
	* Computes the sum of absolute values (L1 norm) of double-precision floating-point strided array elements, ignoring `NaN` values.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnanasum( x.length, x, 1 );
	* // returns 5.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnanasum.ndarray( x.length, x, 1, 0 );
	* // returns 5.0
	*/
	dnanasum: typeof dnanasum;

	/**
	* Computes the sum of absolute values (L1 norm) of double-precision floating-point strided array elements, ignoring `NaN` values and using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnanasumors( x.length, x, 1 );
	* // returns 5.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnanasumors.ndarray( x.length, x, 1, 0 );
	* // returns 5.0
	*/
	dnanasumors: typeof dnanasumors;

	/**
	* Computes the sum of double-precision floating-point strided array elements, ignoring `NaN` values.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param strideX - `x` stride length
	* @param out - output array whose first element is the sum and whose second element is the number of non-NaN elements
	* @param strideOut - `out` stride length
	* @returns output array
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	* var out = new Float64Array( 2 );
	*
	* var v = dnannsum( x.length, x, 1, out, 1 );
	* // returns <Float64Array>[ 1.0, 3 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	* var out = new Float64Array( 2 );
	*
	* var v = dnannsum( x.length, x, 1, 0, out, 1, 0 );
	* // returns <Float64Array>[ 1.0, 3 ]
	*/
	dnannsum: typeof dnannsum;

	/**
	* Computes the sum of double-precision floating-point strided array elements, ignoring `NaN` values and using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param strideX - `x` stride length
	* @param out - output array whose first element is the sum and whose second element is the number of non-NaN elements
	* @param strideOut - `out` stride length
	* @returns output array
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	* var out = new Float64Array( 2 );
	*
	* var v = dnannsumkbn( x.length, x, 1, out, 1 );
	* // returns <Float64Array>[ 1.0, 3 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	* var out = new Float64Array( 2 );
	*
	* var v = dnannsumkbn( x.length, x, 1, 0, out, 1, 0 );
	* // returns <Float64Array>[ 1.0, 3 ]
	*/
	dnannsumkbn: typeof dnannsumkbn;

	/**
	* Computes the sum of double-precision floating-point strided array elements, ignoring `NaN` values and using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param strideX - `x` stride length
	* @param out - output array whose first element is the sum and whose second element is the number of non-NaN elements
	* @param strideOut - `out` stride length
	* @returns output array
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	* var out = new Float64Array( 2 );
	*
	* var v = dnannsumkbn2( x.length, x, 1, out, 1 );
	* // returns <Float64Array>[ 1.0, 3 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	* var out = new Float64Array( 2 );
	*
	* var v = dnannsumkbn2( x.length, x, 1, 0, out, 1, 0 );
	* // returns <Float64Array>[ 1.0, 3 ]
	*/
	dnannsumkbn2: typeof dnannsumkbn2;

	/**
	* Computes the sum of double-precision floating-point strided array elements, ignoring `NaN` values and using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param strideX - `x` stride length
	* @param out - output array whose first element is the sum and whose second element is the number of non-NaN elements
	* @param strideOut - `out` stride length
	* @returns output array
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	* var out = new Float64Array( 2 );
	*
	* var v = dnannsumors( x.length, x, 1, out, 1 );
	* // returns <Float64Array>[ 1.0, 3 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	* var out = new Float64Array( 2 );
	*
	* var v = dnannsumors( x.length, x, 1, 0, out, 1, 0 );
	* // returns <Float64Array>[ 1.0, 3 ]
	*/
	dnannsumors: typeof dnannsumors;

	/**
	* Computes the sum of double-precision floating-point strided array elements, ignoring `NaN` values and using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param strideX - `x` stride length
	* @param out - output array whose first element is the sum and whose second element is the number of non-NaN elements
	* @param strideOut - `out` stride length
	* @returns output array
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	* var out = new Float64Array( 2 );
	*
	* var v = dnannsumpw( x.length, x, 1, out, 1 );
	* // returns <Float64Array>[ 1.0, 3 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	* var out = new Float64Array( 2 );
	*
	* var v = dnannsumpw( x.length, x, 1, 0, out, 1, 0 );
	* // returns <Float64Array>[ 1.0, 3 ]
	*/
	dnannsumpw: typeof dnannsumpw;

	/**
	* Computes the sum of double-precision floating-point strided array elements, ignoring `NaN` values.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnansum( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnansum.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dnansum: typeof dnansum;

	/**
	* Computes the sum of double-precision floating-point strided array elements, ignoring `NaN` values and using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnansumkbn( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnansumkbn.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dnansumkbn: typeof dnansumkbn;

	/**
	* Computes the sum of double-precision floating-point strided array elements, ignoring `NaN` values and using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnansumkbn2( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnansumkbn2.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dnansumkbn2: typeof dnansumkbn2;

	/**
	* Computes the sum of double-precision floating-point strided array elements, ignoring `NaN` values and using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnansumors( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnansumors.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dnansumors: typeof dnansumors;

	/**
	* Computes the sum of double-precision floating-point strided array elements, ignoring `NaN` values and using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnansumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dnansumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dnansumpw: typeof dnansumpw;

	/**
	* Reverses a double-precision floating-point strided array in-place.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );
	*
	* drev( x.length, x, 1 );
	* // x => <Float64Array>[ -3.0, -1.0, 0.0, 4.0, -5.0, 3.0, 1.0, -2.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );
	*
	* drev.ndarray( x.length, x, 1, 0 );
	* // x => <Float64Array>[ -3.0, -1.0, 0.0, 4.0, -5.0, 3.0, 1.0, -2.0 ]
	*/
	drev: typeof drev;

	/**
	* Adds a constant to each single-precision floating-point strided array element and computes the sum using extended accumulation and returning an extended precision result.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsapxsum( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsapxsum.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	dsapxsum: typeof dsapxsum;

	/**
	* Adds a constant to each single-precision floating-point strided array element and computes the sum using pairwise summation with extended accumulation and returning an extended precision result.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsapxsumpw( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsapxsumpw.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	dsapxsumpw: typeof dsapxsumpw;

	/**
	* Computes the sum of single-precision floating-point strided array elements, ignoring `NaN` values, using ordinary recursive summation with extended accumulation, and returning an extended precision result.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param strideX - `x` stride length
	* @param out - output array whose first element is the sum and whose second element is the number of non-NaN elements
	* @param strideOut - `out` stride length
	* @returns output array
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	* var out = new Float64Array( 2 );
	*
	* var v = dsnannsumors( x.length, x, 1, out, 1 );
	* // returns <Float64Array>[ 1.0, 3 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	* var out = new Float64Array( 2 );
	*
	* var v = dsnannsumors( x.length, x, 1, 0, out, 1, 0 );
	* // returns <Float64Array>[ 1.0, 3 ]
	*/
	dsnannsumors: typeof dsnannsumors;

	/**
	* Computes the sum of single-precision floating-point strided array elements, ignoring `NaN` values, using extended accumulation, and returning an extended precision result.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dsnansum( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dsnansum.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dsnansum: typeof dsnansum;

	/**
	* Computes the sum of single-precision floating-point strided array elements, ignoring `NaN` values, using ordinary recursive summation with extended accumulation, and returning an extended precision result.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dsnansumors( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dsnansumors.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dsnansumors: typeof dsnansumors;

	/**
	* Computes the sum of single-precision floating-point strided array elements, ignoring `NaN` values, using pairwise summation with extended accumulation, and returning an extended precision result.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dsnansumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = dsnansumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dsnansumpw: typeof dsnansumpw;

	/**
	* Simultaneously sorts two double-precision floating-point strided arrays based on the sort order of the first array using heapsort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - first input array
	* @param strideX - `x` stride length
	* @param y - second input array
	* @param strideY - `y` stride length
	* @returns `x`
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	* var y = new Float64Array( [ 0.0, 1.0, 2.0, 3.0 ] );
	*
	* dsort2hp( x.length, 1, x, 1, y, 1 );
	*
	* console.log( x );
	* // => <Float64Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => <Float64Array>[ 3.0, 1.0, 0.0, 2.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	* var y = new Float64Array( [ 0.0, 1.0, 2.0, 3.0 ] );
	*
	* dsort2hp.ndarray( x.length, 1, x, 1, 0, y, 1, 0 );
	*
	* console.log( x );
	* // => <Float64Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => <Float64Array>[ 3.0, 1.0, 0.0, 2.0 ]
	*/
	dsort2hp: typeof dsort2hp;

	/**
	* Simultaneously sorts two double-precision floating-point strided arrays based on the sort order of the first array using insertion sort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - first input array
	* @param strideX - `x` stride length
	* @param y - second input array
	* @param strideY - `y` stride length
	* @returns `x`
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	* var y = new Float64Array( [ 0.0, 1.0, 2.0, 3.0 ] );
	*
	* dsort2ins( x.length, 1, x, 1, y, 1 );
	*
	* console.log( x );
	* // => <Float64Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => <Float64Array>[ 3.0, 1.0, 0.0, 2.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	* var y = new Float64Array( [ 0.0, 1.0, 2.0, 3.0 ] );
	*
	* dsort2ins.ndarray( x.length, 1, x, 1, 0, y, 1, 0 );
	*
	* console.log( x );
	* // => <Float64Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => <Float64Array>[ 3.0, 1.0, 0.0, 2.0 ]
	*/
	dsort2ins: typeof dsort2ins;

	/**
	* Simultaneously sorts two double-precision floating-point strided arrays based on the sort order of the first array using Shellsort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - first input array
	* @param strideX - `x` stride length
	* @param y - second input array
	* @param strideY - `y` stride length
	* @returns `x`
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	* var y = new Float64Array( [ 0.0, 1.0, 2.0, 3.0 ] );
	*
	* dsort2sh( x.length, 1, x, 1, y, 1 );
	*
	* console.log( x );
	* // => <Float64Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => <Float64Array>[ 3.0, 1.0, 0.0, 2.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	* var y = new Float64Array( [ 0.0, 1.0, 2.0, 3.0 ] );
	*
	* dsort2sh.ndarray( x.length, 1, x, 1, 0, y, 1, 0 );
	*
	* console.log( x );
	* // => <Float64Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => <Float64Array>[ 3.0, 1.0, 0.0, 2.0 ]
	*/
	dsort2sh: typeof dsort2sh;

	/**
	* Sorts a double-precision floating-point strided array using heapsort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	*
	* dsorthp( x.length, 1, x, 1 );
	* // x => <Float64Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	*
	* dsorthp.ndarray( x.length, 1, x, 1, 0 );
	* // x => <Float64Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*/
	dsorthp: typeof dsorthp;

	/**
	* Sorts a double-precision floating-point strided array using insertion sort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	*
	* dsortins( x.length, 1, x, 1 );
	* // x => <Float64Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	*
	* dsortins.ndarray( x.length, 1, x, 1, 0 );
	* // x => <Float64Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*/
	dsortins: typeof dsortins;

	/**
	* Sorts a double-precision floating-point strided array using Shellsort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	*
	* dsortsh( x.length, 1, x, 1 );
	* // x => <Float64Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	*
	* dsortsh.ndarray( x.length, 1, x, 1, 0 );
	* // x => <Float64Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*/
	dsortsh: typeof dsortsh;

	/**
	* Computes the sum of single-precision floating-point strided array elements using extended accumulation and returning an extended precision result.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dssum( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dssum.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dssum: typeof dssum;

	/**
	* Computes the sum of single-precision floating-point strided array elements using ordinary recursive summation with extended accumulation and returning an extended precision result.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dssumors( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dssumors.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dssumors: typeof dssumors;

	/**
	* Computes the sum of single-precision floating-point strided array elements using pairwise summation with extended accumulation and returning an extended precision result.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dssumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dssumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dssumpw: typeof dssumpw;

	/**
	* Computes the sum of double-precision floating-point strided array elements.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsum( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsum.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dsum: typeof dsum;

	/**
	* Computes the sum of double-precision floating-point strided array elements using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsumkbn( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsumkbn.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dsumkbn: typeof dsumkbn;

	/**
	* Computes the sum of double-precision floating-point strided array elements using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsumkbn2( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsumkbn2.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dsumkbn2: typeof dsumkbn2;

	/**
	* Computes the sum of double-precision floating-point strided array elements using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsumors( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsumors.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dsumors: typeof dsumors;

	/**
	* Computes the sum of double-precision floating-point strided array elements using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float64Array = require( `@stdlib/array/float64` );
	*
	* var x = new Float64Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = dsumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	dsumpw: typeof dsumpw;

	/**
	* Adds a constant to each element in a strided array.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];
	*
	* gapx( x.length, 5.0, x, 1 );
	* // x => [ 3.0, 6.0, 8.0, 0.0, 9.0, 5.0, 4.0, 2.0 ]
	*
	* @example
	* var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];
	*
	* gapx.ndarray( x.length, 5.0, x, 1, 0 );
	* // x => [ 3.0, 6.0, 8.0, 0.0, 9.0, 5.0, 4.0, 2.0 ]
	*/
	gapx: typeof gapx;

	/**
	* Adds a constant to each strided array element and computes the sum.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gapxsum( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gapxsum.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	gapxsum: typeof gapxsum;

	/**
	* Adds a constant to each strided array element and computes the sum using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gapxsumkbn( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gapxsumkbn.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	gapxsumkbn: typeof gapxsumkbn;

	/**
	* Adds a constant to each strided array element and computes the sum using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gapxsumkbn2( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gapxsumkbn2.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	gapxsumkbn2: typeof gapxsumkbn2;

	/**
	* Adds a constant to each strided array element and computes the sum using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gapxsumors( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gapxsumors.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	gapxsumors: typeof gapxsumors;

	/**
	* Adds a constant to each strided array element and computes the sum using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gapxsumpw( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gapxsumpw.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	gapxsumpw: typeof gapxsumpw;

	/**
	* Computes the sum of absolute values (L1 norm) of strided array elements using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gasumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gasumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	gasumpw: typeof gasumpw;

	/**
	* Computes the cumulative sum of strided array elements.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	* var y = [ 0.0, 0.0, 0.0 ];
	*
	* gcusum( x.length, 0.0, x, 1, y, 1 );
	* // y => [ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	* var y = [ 0.0, 0.0, 0.0 ];
	*
	* gcusum.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => [ 1.0, -1.0, 1.0 ]
	*/
	gcusum: typeof gcusum;

	/**
	* Computes the cumulative sum of strided array elements using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	* var y = [ 0.0, 0.0, 0.0 ];
	*
	* gcusumkbn( x.length, 0.0, x, 1, y, 1 );
	* // y => [ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	* var y = [ 0.0, 0.0, 0.0 ];
	*
	* gcusumkbn.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => [ 1.0, -1.0, 1.0 ]
	*/
	gcusumkbn: typeof gcusumkbn;

	/**
	* Computes the cumulative sum of strided array elements using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	* var y = [ 0.0, 0.0, 0.0 ];
	*
	* gcusumkbn2( x.length, 0.0, x, 1, y, 1 );
	* // y => [ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	* var y = [ 0.0, 0.0, 0.0 ];
	*
	* gcusumkbn2.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => [ 1.0, -1.0, 1.0 ]
	*/
	gcusumkbn2: typeof gcusumkbn2;

	/**
	* Computes the cumulative sum of strided array elements using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	* var y = [ 0.0, 0.0, 0.0 ];
	*
	* gcusumors( x.length, 0.0, x, 1, y, 1 );
	* // y => [ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	* var y = [ 0.0, 0.0, 0.0 ];
	*
	* gcusumors.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => [ 1.0, -1.0, 1.0 ]
	*/
	gcusumors: typeof gcusumors;

	/**
	* Computes the cumulative sum of strided array elements using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	* var y = [ 0.0, 0.0, 0.0 ];
	*
	* gcusumpw( x.length, 0.0, x, 1, y, 1 );
	* // y => [ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	* var y = [ 0.0, 0.0, 0.0 ];
	*
	* gcusumpw.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => [ 1.0, -1.0, 1.0 ]
	*/
	gcusumpw: typeof gcusumpw;

	/**
	* Fills a strided array with a specified scalar value.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];
	*
	* gfill( x.length, 5.0, x, 1 );
	* // x => [ 5.0, 5.0, 5.0, 0.0, 5.0, 5.0, 5.0, 5.0 ]
	*
	* @example
	* var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];
	*
	* gfill.ndarray( x.length, 5.0, x, 1, 0 );
	* // x => [ 5.0, 5.0, 5.0, 0.0, 5.0, 5.0, 5.0, 5.0 ]
	*/
	gfill: typeof gfill;

	/**
	* Fills a strided array according to a provided callback function.
	*
	* ## Notes
	*
	* -   The callback function is provided four arguments:
	*
	*     -   `value`: array element
	*     -   `aidx`: array index
	*     -   `sidx`: strided index (offset + aidx*stride)
	*     -   `array`: input array
	*
	* -   The callback return value is used as the fill value for the current array index.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @param clbk - callback
	* @param thisArg - execution context
	* @returns `x`
	*
	* @example
	* var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];
	*
	* function fill() {
	*     return 5.0;
	* }
	*
	* gfillBy( x.length, x, 1, fill );
	* // x => [ 5.0, 5.0, 5.0, 0.0, 5.0, 5.0, 5.0, 5.0 ]
	*
	* @example
	* var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];
	*
	* function fill() {
	*     return 5.0;
	* }
	*
	* gfillBy.ndarray( x.length, x, 1, 0, fill );
	* // x => [ 5.0, 5.0, 5.0, 0.0, 5.0, 5.0, 5.0, 5.0 ]
	*/
	gfillBy: typeof gfillBy;

	/**
	* Computes the sum of strided array elements, ignoring `NaN` values and using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param strideX - `x` stride length
	* @param out - output array whose first element is the sum and whose second element is the number of non-NaN elements
	* @param strideOut - `out` stride length
	* @returns output array
	*
	* @example
	* var x = [ 1.0, -2.0, NaN, 2.0 ];
	* var out = [ 0.0, 0 ];
	*
	* var v = gnannsumkbn( x.length, x, 1, out, 1 );
	* // returns [ 1.0, 3 ]
	*
	* @example
	* var x = [ 1.0, -2.0, NaN, 2.0 ];
	* var out = [ 0.0, 0 ];
	*
	* var v = gnannsumkbn( x.length, x, 1, 0, out, 1, 0 );
	* // returns [ 1.0, 3 ]
	*/
	gnannsumkbn: typeof gnannsumkbn;

	/**
	* Computes the sum of strided array elements, ignoring `NaN` values.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, NaN, 2.0 ];
	*
	* var v = gnansum( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var x = [ 1.0, -2.0, NaN, 2.0 ];
	*
	* var v = gnansum.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	gnansum: typeof gnansum;

	/**
	* Computes the sum of strided array elements, ignoring `NaN` values and using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, NaN, 2.0 ];
	*
	* var v = gnansumkbn( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var x = [ 1.0, -2.0, NaN, 2.0 ];
	*
	* var v = gnansumkbn.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	gnansumkbn: typeof gnansumkbn;

	/**
	* Computes the sum of strided array elements, ignoring `NaN` values and using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, NaN, 2.0 ];
	*
	* var v = gnansumkbn2( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var x = [ 1.0, -2.0, NaN, 2.0 ];
	*
	* var v = gnansumkbn2.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	gnansumkbn2: typeof gnansumkbn2;

	/**
	* Computes the sum of strided array elements, ignoring `NaN` values and using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, NaN, 2.0 ];
	*
	* var v = gnansumors( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var x = [ 1.0, -2.0, NaN, 2.0 ];
	*
	* var v = gnansumors.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	gnansumors: typeof gnansumors;

	/**
	* Computes the sum of strided array elements, ignoring `NaN` values and using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, NaN, 2.0 ];
	*
	* var v = gnansumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var x = [ 1.0, -2.0, NaN, 2.0 ];
	*
	* var v = gnansumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	gnansumpw: typeof gnansumpw;

	/**
	* Reverses a strided array in-place.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];
	*
	* grev( x.length, x, 1 );
	* // x => [ -3.0, -1.0, 0.0, 4.0, -5.0, 3.0, 1.0, -2.0 ]
	*
	* @example
	* var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];
	*
	* grev.ndarray( x.length, x, 1, 0 );
	* // x => [ -3.0, -1.0, 0.0, 4.0, -5.0, 3.0, 1.0, -2.0 ]
	*/
	grev: typeof grev;

	/**
	* Simultaneously sorts two strided arrays based on the sort order of the first array using heapsort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - first input array
	* @param strideX - `x` stride length
	* @param y - second input array
	* @param strideY - `y` stride length
	* @returns `x`
	*
	* @example
	* var x = [ 1.0, -2.0, 3.0, -4.0 ];
	* var y = [ 0.0, 1.0, 2.0, 3.0 ];
	*
	* gsort2hp( x.length, 1, x, 1, y, 1 );
	*
	* console.log( x );
	* // => [ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => [ 3.0, 1.0, 0.0, 2.0 ]
	*
	* @example
	* var x = [ 1.0, -2.0, 3.0, -4.0 ];
	* var y = [ 0.0, 1.0, 2.0, 3.0 ];
	*
	* gsort2hp.ndarray( x.length, 1, x, 1, 0, y, 1, 0 );
	*
	* console.log( x );
	* // => [ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => [ 3.0, 1.0, 0.0, 2.0 ]
	*/
	gsort2hp: typeof gsort2hp;

	/**
	* Simultaneously sorts two strided arrays based on the sort order of the first array using insertion sort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - first input array
	* @param strideX - `x` stride length
	* @param y - second input array
	* @param strideY - `y` stride length
	* @returns `x`
	*
	* @example
	* var x = [ 1.0, -2.0, 3.0, -4.0 ];
	* var y = [ 0.0, 1.0, 2.0, 3.0 ];
	*
	* gsort2ins( x.length, 1, x, 1, y, 1 );
	*
	* console.log( x );
	* // => [ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => [ 3.0, 1.0, 0.0, 2.0 ]
	*
	* @example
	* var x = [ 1.0, -2.0, 3.0, -4.0 ];
	* var y = [ 0.0, 1.0, 2.0, 3.0 ];
	*
	* gsort2ins.ndarray( x.length, 1, x, 1, 0, y, 1, 0 );
	*
	* console.log( x );
	* // => [ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => [ 3.0, 1.0, 0.0, 2.0 ]
	*/
	gsort2ins: typeof gsort2ins;

	/**
	* Simultaneously sorts two strided arrays based on the sort order of the first array using Shellsort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - first input array
	* @param strideX - `x` stride length
	* @param y - second input array
	* @param strideY - `y` stride length
	* @returns `x`
	*
	* @example
	* var x = [ 1.0, -2.0, 3.0, -4.0 ];
	* var y = [ 0.0, 1.0, 2.0, 3.0 ];
	*
	* gsort2sh( x.length, 1, x, 1, y, 1 );
	*
	* console.log( x );
	* // => [ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => [ 3.0, 1.0, 0.0, 2.0 ]
	*
	* @example
	* var x = [ 1.0, -2.0, 3.0, -4.0 ];
	* var y = [ 0.0, 1.0, 2.0, 3.0 ];
	*
	* gsort2sh.ndarray( x.length, 1, x, 1, 0, y, 1, 0 );
	*
	* console.log( x );
	* // => [ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => [ 3.0, 1.0, 0.0, 2.0 ]
	*/
	gsort2sh: typeof gsort2sh;

	/**
	* Sorts a strided array using heapsort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var x = [ 1.0, -2.0, 3.0, -4.0 ];
	*
	* gsorthp( x.length, 1, x, 1 );
	* // x => [ -4.0, -2.0, 1.0, 3.0 ]
	*
	* @example
	* var x = [ 1.0, -2.0, 3.0, -4.0 ];
	*
	* gsorthp.ndarray( x.length, 1, x, 1, 0 );
	* // x => [ -4.0, -2.0, 1.0, 3.0 ]
	*/
	gsorthp: typeof gsorthp;

	/**
	* Sorts a strided array using insertion sort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var x = [ 1.0, -2.0, 3.0, -4.0 ];
	*
	* gsortins( x.length, 1, x, 1 );
	* // x => [ -4.0, -2.0, 1.0, 3.0 ]
	*
	* @example
	* var x = [ 1.0, -2.0, 3.0, -4.0 ];
	*
	* gsortins.ndarray( x.length, 1, x, 1, 0 );
	* // x => [ -4.0, -2.0, 1.0, 3.0 ]
	*/
	gsortins: typeof gsortins;

	/**
	* Sorts a strided array using Shellsort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var x = [ 1.0, -2.0, 3.0, -4.0 ];
	*
	* gsortsh( x.length, 1, x, 1 );
	* // x => [ -4.0, -2.0, 1.0, 3.0 ]
	*
	* @example
	* var x = [ 1.0, -2.0, 3.0, -4.0 ];
	*
	* gsortsh.ndarray( x.length, 1, x, 1, 0 );
	* // x => [ -4.0, -2.0, 1.0, 3.0 ]
	*/
	gsortsh: typeof gsortsh;

	/**
	* Computes the sum of strided array elements.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gsum( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gsum.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	gsum: typeof gsum;

	/**
	* Computes the sum of strided array elements using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gsumkbn( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gsumkbn.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	gsumkbn: typeof gsumkbn;

	/**
	* Computes the sum of strided array elements using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gsumkbn2( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gsumkbn2.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	gsumkbn2: typeof gsumkbn2;

	/**
	* Computes the sum of strided array elements using ordinary recursion summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gsumors( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gsumors.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	gsumors: typeof gsumors;

	/**
	* Computes the sum of strided array elements using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gsumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var x = [ 1.0, -2.0, 2.0 ];
	*
	* var v = gsumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	gsumpw: typeof gsumpw;

	/**
	* Adds a constant to each element in a single-precision floating-point strided array.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );
	*
	* sapx( x.length, 5.0, x, 1 );
	* // x => <Float32Array>[ 3.0, 6.0, 8.0, 0.0, 9.0, 5.0, 4.0, 2.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );
	*
	* sapx.ndarray( x.length, 5.0, x, 1, 0 );
	* // x => <Float32Array>[ 3.0, 6.0, 8.0, 0.0, 9.0, 5.0, 4.0, 2.0 ]
	*/
	sapx: typeof sapx;

	/**
	* Adds a constant to each single-precision floating-point strided array element and computes the sum.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sapxsum( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sapxsum.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	sapxsum: typeof sapxsum;

	/**
	* Adds a constant to each single-precision floating-point strided array element and computes the sum using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sapxsumkbn( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sapxsumkbn.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	sapxsumkbn: typeof sapxsumkbn;

	/**
	* Adds a constant to each single-precision floating-point strided array element and computes the sum using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sapxsumkbn2( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sapxsumkbn2.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	sapxsumkbn2: typeof sapxsumkbn2;

	/**
	* Adds a constant to each single-precision floating-point strided array element and computes the sum using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sapxsumors( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sapxsumors.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	sapxsumors: typeof sapxsumors;

	/**
	* Adds a constant to each single-precision floating-point strided array element and computes the sum using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sapxsumpw( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sapxsumpw.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	sapxsumpw: typeof sapxsumpw;

	/**
	* Computes the sum of absolute values (L1 norm) of single-precision floating-point strided array elements using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sasumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sasumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	sasumpw: typeof sasumpw;

	/**
	* Computes the cumulative sum of single-precision floating-point strided array elements.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float32Array( x.length );
	*
	* scusum( x.length, 0.0, x, 1, y, 1 );
	* // y => <Float32Array>[ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float32Array( x.length );
	*
	* scusum.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => <Float32Array>[ 1.0, -1.0, 1.0 ]
	*/
	scusum: typeof scusum;

	/**
	* Computes the cumulative sum of single-precision floating-point strided array elements using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float32Array( x.length );
	*
	* scusumkbn( x.length, 0.0, x, 1, y, 1 );
	* // y => <Float32Array>[ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float32Array( x.length );
	*
	* scusumkbn.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => <Float32Array>[ 1.0, -1.0, 1.0 ]
	*/
	scusumkbn: typeof scusumkbn;

	/**
	* Computes the cumulative sum of single-precision floating-point strided array elements using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float32Array( x.length );
	*
	* scusumkbn2( x.length, 0.0, x, 1, y, 1 );
	* // y => <Float32Array>[ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float32Array( x.length );
	*
	* scusumkbn2.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => <Float32Array>[ 1.0, -1.0, 1.0 ]
	*/
	scusumkbn2: typeof scusumkbn2;

	/**
	* Computes the cumulative sum of single-precision floating-point strided array elements using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float32Array( x.length );
	*
	* scusumors( x.length, 0.0, x, 1, y, 1 );
	* // y => <Float32Array>[ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float32Array( x.length );
	*
	* scusumors.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => <Float32Array>[ 1.0, -1.0, 1.0 ]
	*/
	scusumors: typeof scusumors;

	/**
	* Computes the cumulative sum of single-precision floating-point strided array elements using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param sum - initial sum
	* @param x - input array
	* @param strideX - `x` stride length
	* @param y - output array
	* @param strideY - `y` stride length
	* @returns output array
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float32Array( x.length );
	*
	* scusumpw( x.length, 0.0, x, 1, y, 1 );
	* // y => <Float32Array>[ 1.0, -1.0, 1.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	* var y = new Float32Array( x.length );
	*
	* scusumpw.ndarray( x.length, 0.0, x, 1, 0, y, 1, 0 );
	* // y => <Float32Array>[ 1.0, -1.0, 1.0 ]
	*/
	scusumpw: typeof scusumpw;

	/**
	* Adds a constant to each single-precision floating-point strided array element and computes the sum using extended accumulation.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sdsapxsum( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sdsapxsum.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	sdsapxsum: typeof sdsapxsum;

	/**
	* Adds a constant to each single-precision floating-point strided array element and computes the sum using pairwise summation with extended accumulation.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sdsapxsumpw( x.length, 5.0, x, 1 );
	* // returns 16.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sdsapxsumpw.ndarray( x.length, 5.0, x, 1, 0 );
	* // returns 16.0
	*/
	sdsapxsumpw: typeof sdsapxsumpw;

	/**
	* Computes the sum of single-precision floating-point strided array elements, ignoring `NaN` values and using extended accumulation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = sdsnansum( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = sdsnansum.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	sdsnansum: typeof sdsnansum;

	/**
	* Computes the sum of single-precision floating-point strided array elements, ignoring `NaN` values and using pairwise summation with extended accumulation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = sdsnansumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = sdsnansumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	sdsnansumpw: typeof sdsnansumpw;

	/**
	* Computes the sum of single-precision floating-point strided array elements using extended accumulation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sdssum( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sdssum.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	sdssum: typeof sdssum;

	/**
	* Computes the sum of single-precision floating-point strided array elements using pairwise summation with extended accumulation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sdssumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = sdssumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	sdssumpw: typeof sdssumpw;

	/**
	* Fills a single-precision floating-point strided array with a specified scalar value.
	*
	* @param N - number of indexed elements
	* @param alpha - constant
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );
	*
	* sfill( x.length, 5.0, x, 1 );
	* // x => <Float32Array>[ 5.0, 5.0, 5.0, 0.0, 5.0, 5.0, 5.0, 5.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );
	*
	* sfill.ndarray( x.length, 5.0, x, 1, 0 );
	* // x => <Float32Array>[ 5.0, 5.0, 5.0, 0.0, 5.0, 5.0, 5.0, 5.0 ]
	*/
	sfill: typeof sfill;

	/**
	* Computes the sum of single-precision floating-point strided array elements, ignoring `NaN` values.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = snansum( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = snansum.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	snansum: typeof snansum;

	/**
	* Computes the sum of single-precision floating-point strided array elements, ignoring `NaN` values and using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = snansumkbn( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = snansumkbn.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	snansumkbn: typeof snansumkbn;

	/**
	* Computes the sum of single-precision floating-point strided array elements, ignoring `NaN` values and using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = snansumkbn2( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = snansumkbn2.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	snansumkbn2: typeof snansumkbn2;

	/**
	* Computes the sum of single-precision floating-point strided array elements, ignoring `NaN` values and using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = snansumors( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = snansumors.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	snansumors: typeof snansumors;

	/**
	* Computes the sum of single-precision floating-point strided array elements, ignoring `NaN` values and using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = snansumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, NaN, 2.0 ] );
	*
	* var v = snansumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	snansumpw: typeof snansumpw;

	/**
	* Reverses a single-precision floating-point strided array in-place.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );
	*
	* srev( x.length, x, 1 );
	* // x => <Float32Array>[ -3.0, -1.0, 0.0, 4.0, -5.0, 3.0, 1.0, -2.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ] );
	*
	* srev.ndarray( x.length, x, 1, 0 );
	* // x => <Float32Array>[ -3.0, -1.0, 0.0, 4.0, -5.0, 3.0, 1.0, -2.0 ]
	*/
	srev: typeof srev;

	/**
	* Simultaneously sorts two single-precision floating-point strided arrays based on the sort order of the first array using heapsort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - first input array
	* @param strideX - `x` stride length
	* @param y - second input array
	* @param strideY - `y` stride length
	* @returns `x`
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	* var y = new Float32Array( [ 0.0, 1.0, 2.0, 3.0 ] );
	*
	* ssort2hp( x.length, 1, x, 1, y, 1 );
	*
	* console.log( x );
	* // => <Float32Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => <Float32Array>[ 3.0, 1.0, 0.0, 2.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	* var y = new Float32Array( [ 0.0, 1.0, 2.0, 3.0 ] );
	*
	* ssort2hp.ndarray( x.length, 1, x, 1, 0, y, 1, 0 );
	*
	* console.log( x );
	* // => <Float32Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => <Float32Array>[ 3.0, 1.0, 0.0, 2.0 ]
	*/
	ssort2hp: typeof ssort2hp;

	/**
	* Simultaneously sorts two single-precision floating-point strided arrays based on the sort order of the first array using insertion sort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - first input array
	* @param strideX - `x` stride length
	* @param y - second input array
	* @param strideY - `y` stride length
	* @returns `x`
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	* var y = new Float32Array( [ 0.0, 1.0, 2.0, 3.0 ] );
	*
	* ssort2ins( x.length, 1, x, 1, y, 1 );
	*
	* console.log( x );
	* // => <Float32Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => <Float32Array>[ 3.0, 1.0, 0.0, 2.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	* var y = new Float32Array( [ 0.0, 1.0, 2.0, 3.0 ] );
	*
	* ssort2ins.ndarray( x.length, 1, x, 1, 0, y, 1, 0 );
	*
	* console.log( x );
	* // => <Float32Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => <Float32Array>[ 3.0, 1.0, 0.0, 2.0 ]
	*/
	ssort2ins: typeof ssort2ins;

	/**
	* Simultaneously sorts two single-precision floating-point strided arrays based on the sort order of the first array using Shellsort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - first input array
	* @param strideX - `x` stride length
	* @param y - second input array
	* @param strideY - `y` stride length
	* @returns `x`
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	* var y = new Float32Array( [ 0.0, 1.0, 2.0, 3.0 ] );
	*
	* ssort2sh( x.length, 1, x, 1, y, 1 );
	*
	* console.log( x );
	* // => <Float32Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => <Float32Array>[ 3.0, 1.0, 0.0, 2.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	* var y = new Float32Array( [ 0.0, 1.0, 2.0, 3.0 ] );
	*
	* ssort2sh.ndarray( x.length, 1, x, 1, 0, y, 1, 0 );
	*
	* console.log( x );
	* // => <Float32Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* console.log( y );
	* // => <Float32Array>[ 3.0, 1.0, 0.0, 2.0 ]
	*/
	ssort2sh: typeof ssort2sh;

	/**
	* Sorts a single-precision floating-point strided array using heapsort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	*
	* ssorthp( x.length, 1, x, 1 );
	* // x => <Float32Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	*
	* ssorthp.ndarray( x.length, 1, x, 1, 0 );
	* // x => <Float32Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*/
	ssorthp: typeof ssorthp;

	/**
	* Sorts a single-precision floating-point strided array using insertion sort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	*
	* ssortins( x.length, 1, x, 1 );
	* // x => <Float32Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	*
	* ssortins.ndarray( x.length, 1, x, 1, 0 );
	* // x => <Float32Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*/
	ssortins: typeof ssortins;

	/**
	* Sorts a single-precision floating-point strided array using Shellsort.
	*
	* @param N - number of indexed elements
	* @param order - sort order
	* @param x - input array
	* @param stride - stride length
	* @returns `x`
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	*
	* ssortsh( x.length, 1, x, 1 );
	* // x => <Float32Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 3.0, -4.0 ] );
	*
	* ssortsh.ndarray( x.length, 1, x, 1, 0 );
	* // x => <Float32Array>[ -4.0, -2.0, 1.0, 3.0 ]
	*/
	ssortsh: typeof ssortsh;

	/**
	* Computes the sum of single-precision floating-point strided array elements.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = ssum( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = ssum.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	ssum: typeof ssum;

	/**
	* Computes the sum of single-precision floating-point strided array elements using an improved Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = ssumkbn( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = ssumkbn.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	ssumkbn: typeof ssumkbn;

	/**
	* Computes the sum of single-precision floating-point strided array elements using a second-order iterative Kahan–Babuška algorithm.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = ssumkbn2( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = ssumkbn2.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	ssumkbn2: typeof ssumkbn2;

	/**
	* Computes the sum of single-precision floating-point strided array elements using ordinary recursive summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = ssumors( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = ssumors.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	ssumors: typeof ssumors;

	/**
	* Computes the sum of single-precision floating-point strided array elements using pairwise summation.
	*
	* @param N - number of indexed elements
	* @param x - input array
	* @param stride - stride length
	* @returns sum
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = ssumpw( x.length, x, 1 );
	* // returns 1.0
	*
	* @example
	* var Float32Array = require( `@stdlib/array/float32` );
	*
	* var x = new Float32Array( [ 1.0, -2.0, 2.0 ] );
	*
	* var v = ssumpw.ndarray( x.length, x, 1, 0 );
	* // returns 1.0
	*/
	ssumpw: typeof ssumpw;
}

/**
* Standard library extended basic linear algebra subroutines (BLAS).
*/
declare var base: BASE;


// EXPORTS //

export = base;
