/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-restricted-syntax */

'use strict';

// MODULES //

var isNonNegativeInteger = require( '@stdlib/assert/is-nonnegative-integer' ).isPrimitive;
var isArrayLikeObject = require( '@stdlib/assert/is-array-like-object' );
var isArrayBuffer = require( '@stdlib/assert/is-arraybuffer' );
var isObject = require( '@stdlib/assert/is-object' );
var isFunction = require( '@stdlib/assert/is-function' );
var isComplex = require( '@stdlib/assert/is-complex' );
var isEven = require( '@stdlib/math/base/assert/is-even' );
var isInteger = require( '@stdlib/math/base/assert/is-integer' );
var Float32Array = require( '@stdlib/array/float32' );
var fromIterable = require( './from_iterable.js' );
var fromArray = require( './from_array.js' );


// VARIABLES //

var BYTES_PER_ELEMENT = Float32Array.BYTES_PER_ELEMENT * 2;


// MAIN //

/**
* 64-bit complex number array constructor.
*
* @constructor
* @param {(NonNegativeInteger|TypedArray|ArrayLikeObject|ArrayBuffer)} [arg] - a length, typed array, array-like object, or buffer
* @param {NonNegativeInteger} [byteOffset=0] - byte offset
* @param {NonNegativeInteger} [length] - view length
* @throws {RangeError} ArrayBuffer byte length must be a multiple of `8`
* @throws {RangeError} array-like object and typed array input arguments must have a length which is a multiple of two
* @throws {TypeError} if provided only a single argument, must provide a valid argument
* @throws {TypeError} byte offset must be a nonnegative integer
* @throws {RangeError} byte offset must be a multiple of `8`
* @throws {TypeError} view length must be a positive multiple of two
* @throws {TypeError} an iterator must return either a two element array containing real and imaginary components or a complex number
* @returns {Complex64Array} complex number array
*
* @example
* var arr = new Complex64Array();
* // returns <Complex64Array>
*
* var len = arr.length;
* // returns 0
*
* @example
* var arr = new Complex64Array( 2 );
* // returns <Complex64Array>
*
* var len = arr.length;
* // returns 2
*
* @example
* var arr = new Complex64Array( [ 1.0, -1.0 ] );
* // returns <Complex64Array>
*
* var len = arr.length;
* // returns 1
*
* @example
* var ArrayBuffer = require( '@stdlib/array/buffer' );
*
* var buf = new ArrayBuffer( 16 );
* var arr = new Complex64Array( buf );
* // returns <Complex64Array>
*
* var len = arr.length;
* // returns 2
*
* @example
* var ArrayBuffer = require( '@stdlib/array/buffer' );
*
* var buf = new ArrayBuffer( 16 );
* var arr = new Complex64Array( buf, 8 );
* // returns <Complex64Array>
*
* var len = arr.length;
* // returns 2
*
* @example
* var ArrayBuffer = require( '@stdlib/array/buffer' );
*
* var buf = new ArrayBuffer( 32 );
* var arr = new Complex64Array( buf, 8, 2 );
* // returns <Complex64Array>
*
* var len = arr.length;
* // returns 2
*/
function Complex64Array() {
	var byteOffset;
	var nargs;
	var buf;
	var len;

	nargs = arguments.length;
	if ( !(this instanceof Complex64Array)) {
		if ( nargs === 0 ) {
			return new Complex64Array();
		}
		if ( nargs === 1 ) {
			return new Complex64Array( arguments[0] );
		}
		if ( nargs === 2 ) {
			return new Complex64Array( arguments[0], arguments[1] );
		}
		return new Complex64Array( arguments[0], arguments[1], arguments[2] );
	}
	// Create the underlying data buffer...
	if ( nargs === 0 ) {
		buf = new Float32Array( 0 ); // backward-compatibility
	} else if ( nargs === 1 ) {
		if ( isNonNegativeInteger( arguments[0] ) ) {
			len = arguments[ 0 ];
			buf = new Float32Array( len*2 );
		} else if ( isArrayBuffer( arguments[0] ) ) {
			buf = arguments[ 0 ];
			len = buf.byteLength / BYTES_PER_ELEMENT;
			if ( !isInteger( len ) ) {
				throw new RangeError( 'invalid input argument. ArrayBuffer byte length must be a multiple of '+BYTES_PER_ELEMENT+'. Byte length: `'+buf.byteLength+'`.' );
			}
			buf = new Float32Array( buf );
		} else if ( isArrayLikeObject( arguments[0] ) ) {
			buf = arguments[ 0 ];
			len = buf.length;

			// Sniff the first value to determine how we'll process the array-like object...
			if ( len && isComplex( buf[0] ) ) {
				buf = fromArray( new Float32Array( len*2 ), buf );
				if ( buf instanceof Error ) {
					throw buf;
				}
			} else {
				if ( !isEven( len ) ) {
					throw new RangeError( 'invalid input argument. Array-like object and typed array input arguments must have a length which is a multiple of two. Length: `'+len+'`.' );
				}
				buf = new Float32Array( buf );
			}
		} else if ( isObject( arguments[0] ) ) {
			buf = arguments[ 0 ];
			if ( !isFunction( buf.next ) ) {
				throw new TypeError( 'invalid input argument. Must provide a length, ArrayBuffer, typed array, array-like object, or an iterable. Value: `'+buf+'`.' );
			}
			buf = fromIterable( buf );
			if ( buf instanceof Error ) {
				throw buf;
			}
			buf = new Float32Array( buf );
			len = buf.length / 2;
		} else {
			throw new TypeError( 'invalid input argument. Must provide a length, ArrayBuffer, typed array, array-like object, or an iterable. Value: `'+arguments[0]+'`.' );
		}
	} else {
		buf = arguments[ 0 ];
		if ( !isArrayBuffer( buf ) ) {
			throw new TypeError( 'invalid input argument. First argument must be an array buffer. Value: `'+buf+'`.' );
		}
		byteOffset = arguments[ 1 ];
		if ( !isNonNegativeInteger( byteOffset ) ) {
			throw new TypeError( 'invalid input argument. Byte offset must be a nonnegative integer. Value: `'+byteOffset+'`.' );
		}
		if ( !isInteger( byteOffset/BYTES_PER_ELEMENT ) ) {
			throw new RangeError( 'invalid input argument. Byte offset must be a multiple of '+BYTES_PER_ELEMENT+'. Value: `'+byteOffset+'`.' );
		}
		if ( nargs === 2 ) {
			len = buf.byteLength - byteOffset;
			if ( !isInteger( len/BYTES_PER_ELEMENT ) ) {
				throw new RangeError( 'invalid input arguments. ArrayBuffer view byte length must be a multiple of '+BYTES_PER_ELEMENT+'. View byte length: `'+len+'`.' );
			}
			buf = new Float32Array( buf, byteOffset );
			len = buf.length;
		} else {
			len = arguments[ 2 ];
			if ( !isNonNegativeInteger( len ) ) {
				throw new TypeError( 'invalid input argument. Length must be a nonnegative integer. Value: `'+len+'`.' );
			}
			if ( (len*BYTES_PER_ELEMENT) > (buf.byteLength-byteOffset) ) {
				throw new RangeError( 'invalid input arguments. ArrayBuffer has insufficient capacity. Either decrease the array length or provide a bigger buffer. Minimum capacity: `'+(len*BYTES_PER_ELEMENT)+'`.' );
			}
			buf = new Float32Array( buf, byteOffset, len*2 );
		}
	}
	Object.defineProperty( this, '_buffer', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': buf
	});
	Object.defineProperty( this, '_length', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': len
	});

	return this;
}

/**
* Size (in bytes) of each array element.
*
* @name BYTES_PER_ELEMENT
* @memberof Complex64Array
* @type {PositiveInteger}
* @default 8
*
* @example
* var nbytes = Complex64Array.BYTES_PER_ELEMENT;
* // returns 8
*/
Object.defineProperty( Complex64Array, 'BYTES_PER_ELEMENT', {
	'configurable': false,
	'enumerable': false,
	'writable': false,
	'value': BYTES_PER_ELEMENT
});

/**
* Pointer to the underlying data buffer.
*
* @name buffer
* @memberof Complex64Array.prototype
* @type {ArrayBuffer}
*
* @example
* var arr = new Complex64Array( 10 );
*
* var buf = arr.buffer;
* // returns <ArrayBuffer>
*/
Object.defineProperty( Complex64Array.prototype, 'buffer', {
	'configurable': false,
	'enumerable': false,
	'get': function get() {
		return this._buffer.buffer;
	}
});

/**
* Size (in bytes) of the array.
*
* @name byteLength
* @memberof Complex64Array.prototype
* @type {NonNegativeInteger}
*
* @example
* var arr = new Complex64Array( 10 );
*
* var byteLength = arr.byteLength;
* // returns 80
*/
Object.defineProperty( Complex64Array.prototype, 'byteLength', {
	'configurable': false,
	'enumerable': false,
	'get': function get() {
		return this._buffer.byteLength;
	}
});

/**
* Offset (in bytes) of the array from the start of its underlying `ArrayBuffer`.
*
* @name byteOffset
* @memberof Complex64Array.prototype
* @type {NonNegativeInteger}
*
* @example
* var arr = new Complex64Array( 10 );
*
* var byteOffset = arr.byteOffset;
* // returns 0
*/
Object.defineProperty( Complex64Array.prototype, 'byteOffset', {
	'configurable': false,
	'enumerable': false,
	'get': function get() {
		return this._buffer.byteOffset;
	}
});

/**
* Length of the array.
*
* @name length
* @memberof Complex64Array.prototype
* @type {NonNegativeInteger}
*
* @example
* var arr = new Complex64Array( 10 );
*
* var len = arr.length;
* // returns 10
*/
Object.defineProperty( Complex64Array.prototype, 'length', {
	'configurable': false,
	'enumerable': false,
	'get': function get() {
		return this._length;
	}
});


// EXPORTS //

module.exports = Complex64Array;
