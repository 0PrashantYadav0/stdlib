'use strict';

// MODULES //

var debug = require( 'debug' )( 'parallel-runner:exec' );
var fork = require( 'child_process' ).fork;
var path = require( 'path' );
var getKeys = require( 'object-keys' ).shim();
var cwd = require( '@stdlib/utils/cwd' );


// VARIABLES //

var WORKER_FILEPATH = path.resolve( __dirname, './worker/index.js' );


// EXEC //

/**
* Executes scripts in parallel.
*
* @private
* @param {StringArray} files - script filenames
* @param {Options} opts - options
* @param {PositiveInteger} opts.concurrency - number of scripts to execute concurrently
* @param {PositiveInteger} opts.workers - number of workers
* @param {Callback} clbk - callback to invoke after executing all scripts
*/
function exec( files, opts, clbk ) {
	var numClosed;
	var workers;
	var pending;
	var closing;
	var proc;
	var dir;
	var idx;
	var err;
	var i;

	debug( 'Options: %s.', JSON.stringify( opts ) );

	dir = cwd();
	debug( 'Current working directory: %s.', dir );

	// Initialize internal variables related to closing state:
	closing = false;
	numClosed = 0;

	debug( 'Creating %d workers...', opts.workers );
	workers = new Array( opts.workers );
	for ( i = 0; i < opts.workers; i++ ) {
		debug( 'Creating child process...' );

		// TODO: args as option (?)
		proc = fork( WORKER_FILEPATH, [ 'node' ], {
			'cwd': dir,
			'env': process.env // TODO: option
		});

		// Bind event listeners:
		proc.on( 'error', onError( proc ) );
		proc.on( 'close', onClose( proc ) );
		proc.on( 'exit', onExit( proc ) );
		proc.on( 'disconnect', onDisconnect( proc ) );
		proc.on( 'message', onMessage( proc ) );

		debug( 'Child process created. pid: %d.', proc.pid );
		workers[ i ] = proc;
	}
	debug( '%d workers created.', opts.workers );

	debug( 'Running %d scripts concurrently...', opts.concurrency );
	pending = {};
	idx = -1;
	for ( i = 0; i < opts.concurrency; i++ ) {
		next( workers[ i ] );
	}

	/**
	* Instructs a child process to run the next script.
	*
	* @private
	* @param {Object} child - child process
	*/
	function next( child ) {
		var numPending;

		idx += 1;
		debug( '%d of %d scripts have finished.', idx, files.length );
		if ( idx >= files.length ) {
			numPending = getKeys( pending ).length;
			if ( numPending > 0 ) {
				debug( '%d scripts are pending.', numPending );
				return;
			}
			debug( 'All scripts have finished.' );
			return close();
		}
		debug( 'Instructing child process to run script: %s. pid: %d.', files[ idx ], child.pid );
		child.send( files[ idx ] );
		pending[ files[ idx ] ] = true;
	} // end FUNCTION next()

	/**
	* Returns a callback to be invoked upon receiving a message from a child process.
	*
	* @private
	* @param {Object} child - child process
	* @returns {Callback} callback
	*/
	function onMessage( child ) {
		/**
		* Callback invoked upon receiving a message from a child process.
		*
		* @private
		* @param {string} filepath - script filepath
		*/
		return function onMessage( filepath ) {
			debug( 'Child process message: %s. pid: %d.', filepath, child.pid );

			// Remove the script from the listing of pending scripts:
			delete pending[ filepath ];

			// Indicate that the child process is ready for its next task:
			next( child );
		}; // end FUNCTION onMessage()
	} // end FUNCTION onMessage()

	/**
	* Returns a callback to be invoked upon child process close.
	*
	* @private
	* @param {Object} child - child process
	* @returns {Callback} callback
	*/
	function onClose( child ) {
		/**
		* Callback invoked upon child process close.
		*
		* @private
		* @param {(number|null)} code - exit code
		* @param {(string|null)} signal - termination signal
		*/
		return function onClose( code, signal ) {
			debug( 'Child process closed. Code %d. Signal %s. pid: %d.', code, signal, child.pid );
			childClosed();
		}; // end FUNCTION onClose()
	} // end FUNCTION onClose()

	/**
	* Callback invoked if a child closes.
	*
	* @private
	*/
	function childClosed() {
		numClosed += 1;
		debug( '%d of %d child processes have closed.', numClosed, workers.length );
		if ( numClosed === workers.length ) {
			done();
		}
	} // end FUNCTION childClosed()

	/**
	* Returns a callback to be invoked upon child process exit.
	*
	* @private
	* @param {Object} child - child process
	* @returns {Callback} callback
	*/
	function onExit( child ) {
		/**
		* Callback invoked upon child process exit.
		*
		* @private
		* @param {(number|null)} code - exit code
		* @param {(string|null)} signal - termination signal
		*/
		return function onExit( code, signal ) {
			debug( 'Child process exited. Code %d. Signal %s. pid: %d.', code, signal, child.pid );
		}; // end FUNCTION onExit()
	} // end FUNCTION onExit()

	/**
	* Closes all workers.
	*
	* @private
	* @param {Error} [error] - error object
	*/
	function close( error ) {
		var i;
		if ( error && !err ) {
			err = error;
		}
		// Update the closing state:
		closing = true;

		debug( 'Instructing child processes to close...' );
		for ( i = 0; i < workers.length; i++ ) {
			debug( 'Instructing child process (pid: %d) to close...', workers[ i ].pid );
			workers[ i ].send( 'close' );
		}
	} // end FUNCTION close()

	/**
	* Returns a callback to be invoked upon child process disconnect.
	*
	* @private
	* @param {Object} child - child process
	* @returns {Callback} callback
	*/
	function onDisconnect( child ) {
		/**
		* Callback invoked upon child process disconnect.
		*
		* @private
		*/
		return function onDisconnect() {
			debug( 'Child process disconnected. pid: %d.', child.pid );
		}; // end FUNCTION onDisconnect()
	} // end FUNCTION onDisconnect()

	/**
	* Returns a callback to be invoked upon encountering a child process error.
	*
	* @private
	* @param {Object} child - child process
	* @returns {Callback} callback
	*/
	function onError( child ) {
		/**
		* Callback invoked upon a child process error.
		*
		* @private
		* @param {Error} error - error object
		*/
		return function onError( error ) {
			debug( 'Child process error: %s. pid: %d.', error.message, child.pid );
			close( error );
		}; // end FUNCTION onError()
	} // end FUNCTION onError()

	/**
	* Callback invoked once all tasks are finished.
	*
	* @private
	*/
	function done() {
		if ( err ) {
			return clbk( err );
		}
		clbk();
	} // end FUNCTION done()
} // end FUNCTION exec()


// EXPORTS //

module.exports = exec;
