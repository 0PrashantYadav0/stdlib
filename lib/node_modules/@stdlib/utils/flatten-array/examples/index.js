'use strict';

var flattenArray = require( './../lib' );

var flatten;
var opts;
var arr;
var out;

// Basic usage:
console.log( '\nBasic:\n' );

arr = [ 1, [2, [3, [4, [ 5 ], 6], 7], 8], 9 ];

out = flattenArray( arr );
console.log( out );
// => [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]


// Limiting depth:
console.log( '\nLimiting Depth:\n' );

opts = {
	'depth': 2
};

out = flattenArray( arr, opts );
console.log( out );
// => [ 1, 2, 3, [4, [ 5 ], 6], 7, 8, 9 ]


// Deep copy:
console.log( '\nDeep Copy:\n' );

opts = {
	'depth': 2,
	'copy': true
};

out = flattenArray( arr, opts );
console.log( out );
// => [ 1, 2, 3, [4, [ 5 ], 6], 7, 8, 9 ]

console.log( arr[1][1][1] === out[3] );
// => false


// Equal dimensions:
console.log( '\nEqual Dimensions:\n' );

arr = [
	[ 1, 2, 3 ],
	[ 4, 5, 6 ],
	[ 7, 8, 9 ],
	[ 10, 11, 12 ]
];

out = flattenArray( arr, {
	'equalDims': true
});

console.log( out );
// => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ]


//  Custom flatten function:
console.log( '\nCustom Flatten:\n' );

// Create a flatten function customized for flattening 3x3 arrays:
flatten = flattenArray.factory( [3,3] );

arr = [
	[ 1, 2, 3 ],
	[ 4, 5, 6 ],
	[ 7, 8, 9 ]
];

out = flatten( arr );
console.log( out );
// => [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]


// Custom flatten function and deep copy:
console.log( '\nCustom Flatten and Deep Copy:\n' );

opts = {
	'copy': true
};

flatten = flattenArray.factory( [3,3], opts );

arr = [
	[ 1, 2, 3 ],
	[ 4, {'x':5}, 6 ],
	[ 7, 8, 9 ]
];

out = flatten( arr );
console.log( out );
// => [ 1, 2, 3, 4, {'x':5}, 6, 7, 8, 9 ]

console.log( arr[1][1] === out[4] );
// => false


// Strided arrays:
console.log( '\nStrided Arrays:\n' );

var xStride;
var yStride;
var zStride;
var data;
var tmp1;
var tmp2;
var val;
var N;
var M;
var L;
var i;
var j;
var k;

N = 1000;
M = 100;
L = 10;

// Create an NxMxL (3D) array...
data = new Array( N );
for ( i = 0; i < N; i++ ) {
	tmp1 = new Array( M );
	for ( j = 0; j < M; j++ ) {
		tmp2 = new Array( L );
		for ( k = 0; k < L; k++ ) {
			tmp2[ k ] = M*L*i + j*L + k + 1;
		}
		tmp1[ j ] = tmp2;
	}
	data[ i ] = tmp1;
}
// Create a flattened (strided) array:
arr = flattenArray( data );

// To access the data[4][20][2] element...
xStride = M * L;
yStride = L;
zStride = 1;
val = arr[ 4*xStride + 20*yStride + 2*zStride ];

console.log( val );
// => 4203

console.log( data[4][20][2] === val );
// => true
