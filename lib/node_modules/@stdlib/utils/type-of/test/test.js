'use strict';

// MODULES //

var tape = require( 'tape' );
var hasMapSupport = require( '@stdlib/utils/detect-map-support' )();
var hasWeakMapSupport = require( '@stdlib/utils/detect-weakmap-support' )();
var hasSetSupport = require( '@stdlib/utils/detect-set-support' )();
var hasWeakSetSupport = require( '@stdlib/utils/detect-weakset-support' )();
var hasSymbolSupport = require( '@stdlib/utils/detect-symbol-support' )();
var proxyquire = require( 'proxyquire' );
var polyfill = require( './../lib/polyfill.js' );
var getType = require( './../lib/typeof.js' );
var typeOf = require( './../lib' );


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.equal( typeof typeOf, 'function', 'export is a function' );
	t.end();
});

tape( 'if an environment has non-standard `typeof` behavior, the main export is a polyfill', function test( t ) {
	var typeOf = proxyquire( './../lib', {
		'./check.js': check
	});

	t.equal( typeOf.toString(), polyfill.toString(), 'exports polyfill' );
	t.end();

	function check() {
		return true;
	}
});

tape( 'if an environment has standard `typeof` behavior, the main export is a function which extends built-in `typeof` behavior', function test( t ) {
	var typeOf = proxyquire( './../lib', {
		'./check.js': check
	});

	t.equal( typeOf.toString(), getType.toString(), 'exports main implementation' );
	t.end();

	function check() {
		return false;
	}
});

tape( 'the function returns a value\'s type', function test( t ) {
	var expected;
	var values;
	var type;
	var i;

	values = [
		'a',
		new String( 'a' ),
		5,
		new Number( 5 ),
		NaN,
		true,
		new Boolean( true ),
		false,
		new Boolean( false ),
		undefined,
		null,
		[],
		{},
		function noop(){},
		/./,
		new Date(),
		Math,
		JSON,
		new Error(),
		new TypeError(),
		new SyntaxError(),
		new URIError(),
		new EvalError(),
		new ReferenceError(),
		new RangeError(),
		new Int8Array(),
		new Uint8Array(),
		new Uint8ClampedArray(),
		new Int16Array(),
		new Uint16Array(),
		new Int32Array(),
		new Uint32Array(),
		new Float32Array(),
		new Float64Array(),
		new ArrayBuffer(),
		new Buffer( 'beep' )
	];

	expected = [
		'string',
		'string',
		'number',
		'number',
		'number',
		'boolean',
		'boolean',
		'boolean',
		'boolean',
		'undefined',
		'null',
		'array',
		'object',
		'function',
		'regexp',
		'date',
		'math',
		'json',
		'error',
		'typeerror',
		'syntaxerror',
		'urierror',
		'evalerror',
		'referenceerror',
		'rangeerror',
		'int8array',
		'uint8array',
		'uint8clampedarray',
		'int16array',
		'uint16array',
		'int32array',
		'uint32array',
		'float32array',
		'float64array',
		'arraybuffer',
		'buffer'
	];

	for ( i = 0; i < values.length; i++ ) {
		type = typeOf( values[i] );
		t.equal( type, expected[i], 'returns '+expected[i]+' when provided '+values[i] );
	}
	t.end();
});

tape( 'the function supports Map objects (ES2015)', function test( t ) {
	var v;
	if ( hasMapSupport ) {
		v = typeOf( new Map() );
		t.equal( v, 'map', 'returns map' );
	}
	t.end();
});

tape( 'the function supports WeakMap objects (ES2015)', function test( t ) {
	var v;
	if ( hasWeakMapSupport ) {
		v = typeOf( new WeakMap() );
		t.equal( v, 'weakmap', 'returns weakmap' );
	}
	t.end();
});

tape( 'the function supports Set objects (ES2015)', function test( t ) {
	var v;
	if ( hasSetSupport ) {
		v = typeOf( new Set() );
		t.equal( v, 'set', 'returns set' );
	}
	t.end();
});

tape( 'the function supports WeakSet objects (ES2015)', function test( t ) {
	var v;
	if ( hasWeakSetSupport ) {
		v = typeOf( new WeakSet() );
		t.equal( v, 'weakset', 'returns weakset' );
	}
	t.end();
});

tape( 'the function supports Symbol objects (ES2015)', function test( t ) {
	var v;
	if ( hasSymbolSupport ) {
		v = typeOf( Symbol() );
		t.equal( v, 'symbol', 'returns symbol' );
	}
	t.end();
});

tape( 'the function supports custom objects', function test( t ) {
	var v;
	function Person(){}
	v = typeOf( new Person() );
	t.equal( v, 'person', 'returns person' );
	t.end();
});

tape( 'if a value\'s constructor is an anonymous function, the function returns an empty string', function test( t ) {
	var Person = function(){};
	var v;

	v = typeOf( new Person() );
	t.equal( v, '', 'returns empty string' );

	t.end();
});

// TODO: add generator function test
