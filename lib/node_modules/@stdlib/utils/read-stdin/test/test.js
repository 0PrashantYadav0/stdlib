'use strict';

// MODULES //

var tape = require( 'tape' );
var proxyquire = require( 'proxyquire' );
var noop = require( '@stdlib/utils/noop' );
var isBuffer = require( '@stdlib/utils/is-buffer' );
var Stream = require( './fixtures/stdin.js' );
var stdin = require( './../lib' );


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.equal( typeof stdin, 'function', 'main export is a function' );
	t.end();
});

tape( 'the function throws if provided an `encoding` argument which is not a string', function test( t ) {
	var values;
	var i;

	values = [
		5,
		true,
		null,
		undefined,
		[],
		{},
		function(){}
	];

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws TypeError when provided ' + values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			stdin( value, noop );
		};
	}
});

tape( 'the function throws if provided a `callback` argument which is not a function', function test( t ) {
	var values;
	var i;

	values = [
		'5',
		5,
		true,
		null,
		undefined,
		[],
		{}
	];

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue1( values[i] ), TypeError, 'throws TypeError when provided ' + values[i] );
		t.throws( badValue2( values[i] ), TypeError, 'throws TypeError when provided ' + values[i] );
	}
	t.end();

	function badValue1( value ) {
		return function badValue() {
			stdin( value );
		};
	}
	function badValue2( value ) {
		return function badValue() {
			stdin( 'utf8', value );
		};
	}
});

tape( 'if `stdin` is run in TTY mode and the encoding is not set, the function returns an empty buffer', function test( t ) {
	var stream;
	var stdin;

	stream = new Stream();
	stream.isTTY = true;

	stdin = proxyquire( './../lib/read.js', {
		'@stdlib/streams/base/stdin': stream
	});

	stdin( onRead );

	function onRead( error, data ) {
		if ( error ) {
			t.ok( false, error.message );
		}
		t.equal( isBuffer( data ), true, 'returns a buffer' );
		t.equal( data.length, 0, 'buffer is empty' );
		t.end();
	}
});

tape( 'if `stdin` is run in TTY mode and the encoding is set, the function returns an empty string', function test( t ) {
	var stream;
	var stdin;

	stream = new Stream();
	stream.isTTY = true;

	stdin = proxyquire( './../lib/read.js', {
		'@stdlib/streams/base/stdin': stream
	});

	stdin( 'hex', onRead );

	function onRead( error, data ) {
		if ( error ) {
			t.ok( false, error.message );
		}
		t.equal( isBuffer( data ), false, 'does not return a buffer' );
		t.equal( typeof data, 'string', 'returns a string' );
		t.equal( data.length, 0, 'string is empty' );
		t.end();
	}
});

tape( 'if an error is encountered while reading from `stdin`, the error is returned', function test( t ) {
	var stream;
	var stdin;

	stream = new Stream();
	stream.isTTY = false;

	stdin = proxyquire( './../lib/read.js', {
		'@stdlib/streams/base/stdin': stream
	});

	stdin( onRead );

	stream.emit( 'error', new Error( 'beep' ) );

	function onRead( error ) {
		if ( error ) {
			t.equal( error.message, 'beep', 'returns an error' );
		}
		t.end();
	}
});

tape( 'if an error is encountered while reading from `stdin`, the error is returned (encoding set)', function test( t ) {
	var stream;
	var stdin;

	stream = new Stream();
	stream.isTTY = false;

	stdin = proxyquire( './../lib/read.js', {
		'@stdlib/streams/base/stdin': stream
	});

	stdin( 'utf8', onRead );

	stream.emit( 'error', new Error( 'beep' ) );

	function onRead( error ) {
		if ( error ) {
			t.equal( error.message, 'beep', 'returns an error' );
		}
		t.end();
	}
});

tape( 'if the `encoding` argument is not set, the function returns `stdin` data as a `buffer`', function test( t ) {
	var stream;
	var stdin;

	stream = new Stream();
	stream.isTTY = false;

	stdin = proxyquire( './../lib/read.js', {
		'@stdlib/streams/base/stdin': stream
	});

	stdin( onRead );

	stream.push( new Buffer( 'beep' ) );
	stream.push( new Buffer( ' ' ) );
	stream.push( new Buffer( 'boop' ) );
	stream.push( null );

	function onRead( error, data ) {
		if ( error ) {
			t.ok( false, error.message );
		}
		t.equal( isBuffer( data ), true, 'returns a buffer' );
		t.equal( data.toString(), 'beep boop', 'returns `stdin` data' );
		t.end();
	}
});

tape( 'if the `encoding` argument is set, the function returns `stdin` data as a `string`', function test( t ) {
	var stream;
	var stdin;

	stream = new Stream();
	stream.isTTY = false;

	stdin = proxyquire( './../lib/read.js', {
		'@stdlib/streams/base/stdin': stream
	});

	stdin( 'utf8', onRead );

	stream.push( new Buffer( 'beep' ) );
	stream.push( new Buffer( ' ' ) );
	stream.push( new Buffer( 'boop' ) );
	stream.push( null );

	function onRead( error, data ) {
		if ( error ) {
			t.ok( false, error.message );
		}
		t.equal( isBuffer( data ), false, 'does not return a buffer' );
		t.equal( typeof data, 'string', 'returns a string' );
		t.equal( data, 'beep boop', 'returns `stdin` data' );
		t.end();
	}
});

tape( 'if the `encoding` argument is not set and no `stdin` data, the function returns an empty `buffer`', function test( t ) {
	var stream;
	var stdin;

	stream = new Stream();
	stream.isTTY = false;

	stdin = proxyquire( './../lib/read.js', {
		'@stdlib/streams/base/stdin': stream
	});

	stdin( onRead );

	stream.push( null );

	function onRead( error, data ) {
		if ( error ) {
			t.ok( false, error.message );
		}
		t.equal( isBuffer( data ), true, 'returns a buffer' );
		t.equal( data.length, 0, 'returns an empty buffer' );
		t.equal( data.toString(), '', 'buffer is empty' );
		t.end();
	}
});

tape( 'if the `encoding` argument is set and no `stdin` data, the function returns an empty `string`', function test( t ) {
	var stream;
	var stdin;

	stream = new Stream();
	stream.isTTY = false;

	stdin = proxyquire( './../lib/read.js', {
		'@stdlib/streams/base/stdin': stream
	});

	stdin( 'utf8', onRead );

	stream.push( null );

	function onRead( error, data ) {
		if ( error ) {
			t.ok( false, error.message );
		}
		t.equal( isBuffer( data ), false, 'does not return a buffer' );
		t.equal( typeof data, 'string', 'returns a string' );
		t.equal( data, '', 'returns empty string' );
		t.end();
	}
});
