/* eslint-disable max-len, max-lines */

/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var isStringArray = require( '@stdlib/assert/is-string-array' ).primitives;
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var isArrayBuffer = require( '@stdlib/assert/is-arraybuffer' );
var isFunction = require( '@stdlib/assert/is-function' );
var isNonNegativeInteger = require( '@stdlib/assert/is-nonnegative-integer' ).isPrimitive;
var propertiesIn = require( '@stdlib/utils/properties-in' );
var typedarray = require( '@stdlib/array/typed' );
var Int8Array = require( '@stdlib/array/int8' );
var getDtype = require( '@stdlib/array/dtype' );
var setReadWriteAccessor = require( '@stdlib/utils/define-read-write-accessor' );
var defineProperty = require( '@stdlib/utils/define-property' );
var floor = require( '@stdlib/math/base/special/floor' );
var ITERATOR_SYMBOL = require( '@stdlib/symbol/iterator' );
var contains = require( './contains.js' );
var validate = require( './validate.js' );


// VARIABLES //

var RESERVED_PROPS = propertiesIn( new Int8Array( 0 ) );


// MAIN //

/**
* Returns a named typed tuple factory.
*
* @param {StringArray} names - field (property) names
* @param {Options} [options] - options
* @param {string} [options.dtype="float64"] - default data type
* @param {string} [options.name="tuple"] - tuple name
* @throws {TypeError} must provide an array of strings
* @throws {Error} cannot provide a reserved field (property) name
* @throws {TypeError} must provide valid options
* @throws {Error} must provide a recognized data type
* @returns {Function} factory function
*
* @example
* var point = factory( [ 'x', 'y' ] );
*
* var p = point( [ 1.0, -1.0 ] );
*
* var x = p[ 0 ];
* // returns 1.0
*
* x = p.x;
* // returns 1.0
*
* var y = p[ 1 ];
* // returns -1.0
*
* y = p.y;
* // returns -1.0
*/
function factory( names, options ) { // eslint-disable-line max-lines-per-function
	var nfields;
	var fields;
	var opts;
	var err;
	var i;
	if ( !isStringArray( names ) ) {
		throw new TypeError( 'invalid argument. Must provide an array of strings. Value: `' + names + '`.' );
	}
	fields = names.slice();
	nfields = fields.length;
	for ( i = 0; i < nfields; i++ ) {
		if ( contains( RESERVED_PROPS, fields[ i ] ) ) {
			throw new Error( 'invalid argument. Provided field name is reserved. Name: `' + fields[ i ] + '`.' );
		}
	}
	opts = {
		'dtype': 'float64',
		'name': 'tuple'
	};
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}

	/**
	* Returns a named typed tuple.
	*
	* @private
	* @param {(TypedArray|ArrayLikeObject|ArrayBuffer)} [arg] - a typed array, array-like object, or buffer
	* @param {NonNegativeInteger} [byteOffset=0] - byte offset
	* @param {string} [dtype] - data type
	* @throws {TypeError} must provide a recognized data type
	* @throws {RangeError} arguments must be compatible with tuple length
	* @returns {TypedArray} named typed tuple
	*/
	function namedtypedtuple() { // eslint-disable-line max-lines-per-function
		var indices;
		var dtype;
		var nargs;
		var tuple;
		var i;

		nargs = arguments.length;
		if ( nargs <= 0 ) {
			tuple = typedarray( nfields );
		} else if ( nargs === 1 ) {
			if ( isString( arguments[ 0 ] ) ) {
				// Arguments: [ dtype ]
				tuple = typedarray( nfields, arguments[ 0 ] );
			} else if ( isArrayBuffer( arguments[ 0 ] ) ) {
				// Arguments: [ ArrayBuffer ]
				tuple = typedarray( arguments[ 0 ], 0, nfields, opts.dtype );
			} else {
				// Arguments: [ TypedArray|ArrayLikeObject ]
				tuple = typedarray( arguments[ 0 ], opts.dtype );
			}
		} else if ( nargs === 2 ) {
			if ( isArrayBuffer( arguments[ 0 ] ) ) {
				if ( isString( arguments[ 1 ] ) ) {
					// Arguments: [ ArrayBuffer, dtype ]
					tuple = typedarray( arguments[ 0 ], 0, nfields, arguments[ 1 ] );
				} else {
					// Arguments: [ ArrayBuffer, byteOffset ]
					tuple = typedarray( arguments[ 0 ], arguments[ 1 ], nfields, opts.dtype );
				}
			} else {
				// Arguments: [ TypedArray|ArrayLikeObject, dtype ]
				tuple = typedarray( arguments[ 0 ], arguments[ 1 ] );
			}
		} else {
			// Arguments: [ ArrayBuffer, byteOffset, dtype ]
			tuple = typedarray( arguments[ 0 ], arguments[ 1 ], nfields, arguments[ 2 ] );
		}
		if ( tuple.length !== nfields ) {
			throw new RangeError( 'invalid arguments. Arguments are incompatible with number of tuple fields. Tuple length: `' + tuple.length + '`.' );
		}
		dtype = getDtype( tuple );

		indices = []; // indirect index look-up table
		for ( i = 0; i < nfields; i++ ) {
			indices.push( i );
			setReadWriteAccessor( tuple, fields[ i ], getter( i ), setter( i ) );
		}
		tuple.entries = entries;
		tuple.every = every;
		tuple.fields = getFields;
		tuple.filter = filter;
		tuple.find = find;
		tuple.findIndex = findIndex;
		tuple.forEach = forEach;
		tuple.ind2key = ind2key;
		tuple.key2ind = key2ind;
		tuple.keys = keys;
		tuple.map = map;
		tuple.reduce = reduce;

		// TODO: reduce => clbk( prev, curr, index, name, array )

		// TODO: reduceRight => clbk( prev, curr, index, name, array )

		tuple.reverse = reverse;
		tuple.some = some;

		// TODO: sort => update mapping of keys to indices (this may require a custom sort algorithm to allow tracking indices)

		tuple.subtuple = subtuple;
		tuple.toString = toString;

		return tuple;

		/**
		* Returns an accessor to retrieve a tuple value.
		*
		* @private
		* @param {NonNegativeInteger} i - tuple index
		* @returns {Function} accessor
		*/
		function getter( i ) {
			return get;

			/**
			* Returns a tuple value.
			*
			* @private
			* @returns {number} tuple value
			*/
			function get() {
				return tuple[ indices[ i ] ];
			}
		}

		/**
		* Returns an accessor to set a tuple value.
		*
		* @private
		* @param {NonNegativeInteger} i - tuple index
		* @returns {Function} accessor
		*/
		function setter( i ) {
			return set;

			/**
			* Sets a tuple value.
			*
			* @private
			* @param {number} v - value to set
			*/
			function set( v ) {
				tuple[ indices[ i ] ] = v;
			}
		}

		/**
		* Returns an iterator for iterating over tuple key-value pairs.
		*
		* @private
		* @memberof tuple
		* @throws {TypeError} `this` must be the host tuple
		* @returns {Iterator} iterator
		*/
		function entries() {
			var self;
			var iter;
			var FLG;
			var i;

			self = this; // eslint-disable-line no-invalid-this
			if ( self !== tuple ) {
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}

			// Initialize the iteration index:
			i = -1;

			// Create an iterator protocol-compliant object:
			iter = {};
			defineProperty( iter, 'next', {
				'configurable': false,
				'enumerable': false,
				'writable': false,
				'value': next
			});
			defineProperty( iter, 'return', {
				'configurable': false,
				'enumerable': false,
				'writable': false,
				'value': end
			});
			if ( ITERATOR_SYMBOL ) {
				defineProperty( iter, ITERATOR_SYMBOL, {
					'configurable': false,
					'enumerable': false,
					'writable': false,
					'value': factory
				});
			}
			return iter;

			/**
			* Returns an iterator protocol-compliant object containing the next iterated value.
			*
			* @private
			* @returns {Object} iterator protocol-compliant object
			*/
			function next() {
				i += 1;
				if ( FLG || i >= nfields ) {
					return {
						'done': true
					};
				}
				return {
					'value': [ i, fields[ indices[ i ] ], tuple[ i ] ],
					'done': false
				};
			}

			/**
			* Finishes an iterator.
			*
			* @private
			* @param {*} [value] - value to return
			* @returns {Object} iterator protocol-compliant object
			*/
			function end( value ) {
				FLG = true;
				if ( arguments.length ) {
					return {
						'value': value,
						'done': true
					};
				}
				return {
					'done': true
				};
			}

			/**
			* Returns a new iterator.
			*
			* @private
			* @returns {Iterator} iterator
			*/
			function factory() {
				return self.entries();
			}
		}

		/**
		* Tests whether all tuple elements pass a test implemented by a predicate function.
		*
		* @private
		* @memberof tuple
		* @param {Function} predicate - predicate function
		* @param {*} [thisArg] - execution context
		* @throws {TypeError} `this` must be the host tuple
		* @throws {TypeError} first argument must be a function
		* @returns {boolean} boolean indicating if all elements pass
		*/
		function every( predicate, thisArg ) {
			var bool;
			var i;
			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			if ( !isFunction( predicate ) ) {
				throw new TypeError( 'invalid argument. First argument must be a function. Value: `' + predicate + '`.' );
			}
			for ( i = 0; i < nfields; i++ ) {
				bool = predicate.call( thisArg, tuple[ i ], i, fields[ indices[i] ], tuple );
				if ( !bool ) {
					return false;
				}
			}
			return true;
		}

		/**
		* Returns the list of tuple fields.
		*
		* @private
		* @memberof tuple
		* @throws {TypeError} `this` must be the host tuple
		* @returns {StringArray} tuple fields
		*/
		function getFields() {
			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			return fields.slice();
		}

		/**
		* Creates a new tuple which includes those elements for which a predicate function returns a truthy value.
		*
		* ## Notes
		*
		* -   The returned tuple has the same data type as the host tuple.
		*
		* @private
		* @memberof tuple
		* @param {Function} fcn - filter function
		* @param {*} [thisArg] - execution context
		* @throws {TypeError} `this` must be the host tuple
		* @throws {TypeError} first argument must be a function
		* @returns {TypedArray} new tuple
		*/
		function filter( fcn, thisArg ) {
			var fields;
			var bool;
			var out;
			var tmp;
			var i;
			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			if ( !isFunction( fcn ) ) {
				throw new TypeError( 'invalid argument. First argument must be a function. Value: `' + fcn + '`.' );
			}
			fields = [];
			tmp = [];
			for ( i = 0; i < nfields; i++ ) {
				bool = fcn.call( thisArg, tuple[ i ], i, fields[ indices[i] ], tuple );
				if ( bool ) {
					fields.push( fields[ indices[i] ] );
					tmp.push( tuple[ i ] );
				}
			}
			if ( fields.length === nfields ) {
				out = namedtypedtuple( tmp, dtype );
			} else if ( fields.length ) {
				out = factory( fields, opts )( tmp );
			}
			return out;
		}

		/**
		* Returns the first tuple element for which a provided predicate function returns a truthy value.
		*
		* @private
		* @memberof tuple
		* @param {Function} predicate - predicate function
		* @param {*} [thisArg] - execution context
		* @throws {TypeError} `this` must be the host tuple
		* @throws {TypeError} first argument must be a function
		* @returns {(number|void)} tuple element
		*/
		function find( predicate, thisArg ) {
			var bool;
			var i;
			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			if ( !isFunction( predicate ) ) {
				throw new TypeError( 'invalid argument. First argument must be a function. Value: `' + predicate + '`.' );
			}
			for ( i = 0; i < nfields; i++ ) {
				bool = predicate.call( thisArg, tuple[ i ], i, fields[ indices[i] ], tuple );
				if ( bool ) {
					return tuple[ i ];
				}
			}
		}

		/**
		* Returns the index of the first tuple element for which a provided predicate function returns a truthy value.
		*
		* ## Notes
		*
		* -   If the predicate function never returns a truthy value, the function returns `-1`.
		*
		* @private
		* @memberof tuple
		* @param {Function} predicate - predicate function
		* @param {*} [thisArg] - execution context
		* @throws {TypeError} `this` must be the host tuple
		* @throws {TypeError} first argument must be a function
		* @returns {integer} tuple index or `-1`
		*/
		function findIndex( predicate, thisArg ) {
			var bool;
			var i;
			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			if ( !isFunction( predicate ) ) {
				throw new TypeError( 'invalid argument. First argument must be a function. Value: `' + predicate + '`.' );
			}
			for ( i = 0; i < nfields; i++ ) {
				bool = predicate.call( thisArg, tuple[ i ], i, fields[ indices[i] ], tuple );
				if ( bool ) {
					return i;
				}
			}
			return -1;
		}

		/**
		* Invokes a callback for each tuple element.
		*
		* @private
		* @memberof tuple
		* @param {Function} fcn - function to invoke
		* @param {*} [thisArg] - execution context
		* @throws {TypeError} `this` must be the host tuple
		* @throws {TypeError} first argument must be a function
		*/
		function forEach( fcn, thisArg ) {
			var i;
			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			if ( !isFunction( fcn ) ) {
				throw new TypeError( 'invalid argument. First argument must be a function. Value: `' + fcn + '`.' );
			}
			for ( i = 0; i < nfields; i++ ) {
				fcn.call( thisArg, tuple[ i ], i, fields[ indices[i] ], tuple );
			}
		}

		/**
		* Converts a tuple index to a field name.
		*
		* @private
		* @memberof tuple
		* @param {NonNegativeInteger} ind - tuple index
		* @throws {TypeError} `this` must be the host tuple
		* @throws {TypeError} first argument must be a nonnegative integer
		* @throws {RangeError} index cannot exceed tuple dimensions
		* @returns {string} field name
		*/
		function ind2key( ind ) {
			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			if ( !isNonNegativeInteger( ind ) ) {
				throw new TypeError( 'invalid argument. First argument must be a nonnegative integer. Value: `' + ind + '`.' );
			}
			if ( ind >= nfields ) {
				throw new RangeError( 'invalid argument. Tuple index cannot exceed tuple dimensions. Value: `' + ind + '`.' );
			}
			return fields[ indices[ ind ] ];
		}

		/**
		* Converts a field name to a tuple index.
		*
		* ## Notes
		*
		* -   If provided an unknown field name, the function returns `-1`.
		*
		* @private
		* @memberof tuple
		* @param {string} key - field name
		* @throws {TypeError} `this` must be the host tuple
		* @throws {TypeError} first argument must be a string
		* @returns {integer} tuple index
		*/
		function key2ind( key ) {
			var i;
			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			if ( !isString( key ) ) {
				throw new TypeError( 'invalid argument. First argument must be a string. Value: `' + key + '`.' );
			}
			for ( i = 0; i < nfields; i++ ) {
				if ( fields[ indices[i] ] === key ) {
					return i;
				}
			}
			return -1;
		}

		/**
		* Returns an iterator for iterating over tuple keys.
		*
		* @private
		* @memberof tuple
		* @throws {TypeError} `this` must be the host tuple
		* @returns {Iterator} iterator
		*/
		function keys() {
			var self;
			var iter;
			var FLG;
			var i;

			self = this; // eslint-disable-line no-invalid-this
			if ( self !== tuple ) {
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}

			// Initialize the iteration index:
			i = -1;

			// Create an iterator protocol-compliant object:
			iter = {};
			defineProperty( iter, 'next', {
				'configurable': false,
				'enumerable': false,
				'writable': false,
				'value': next
			});
			defineProperty( iter, 'return', {
				'configurable': false,
				'enumerable': false,
				'writable': false,
				'value': end
			});
			if ( ITERATOR_SYMBOL ) {
				defineProperty( iter, ITERATOR_SYMBOL, {
					'configurable': false,
					'enumerable': false,
					'writable': false,
					'value': factory
				});
			}
			return iter;

			/**
			* Returns an iterator protocol-compliant object containing the next iterated value.
			*
			* @private
			* @returns {Object} iterator protocol-compliant object
			*/
			function next() {
				i += 1;
				if ( FLG || i >= nfields ) {
					return {
						'done': true
					};
				}
				return {
					'value': [ i, fields[ indices[ i ] ] ],
					'done': false
				};
			}

			/**
			* Finishes an iterator.
			*
			* @private
			* @param {*} [value] - value to return
			* @returns {Object} iterator protocol-compliant object
			*/
			function end( value ) {
				FLG = true;
				if ( arguments.length ) {
					return {
						'value': value,
						'done': true
					};
				}
				return {
					'done': true
				};
			}

			/**
			* Returns a new iterator.
			*
			* @private
			* @returns {Iterator} iterator
			*/
			function factory() {
				return self.keys();
			}
		}

		/**
		* Maps each tuple element to an element in a new tuple.
		*
		* ## Notes
		*
		* -   The returned tuple has the same data type as the host tuple.
		*
		* @private
		* @memberof tuple
		* @param {Function} fcn - map function
		* @param {*} [thisArg] - execution context
		* @throws {TypeError} `this` must be the host tuple
		* @throws {TypeError} first argument must be a function
		* @returns {TypedArray} new tuple
		*/
		function map( fcn, thisArg ) {
			var out;
			var i;
			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			if ( !isFunction( fcn ) ) {
				throw new TypeError( 'invalid argument. First argument must be a function. Value: `' + fcn + '`.' );
			}
			out = namedtypedtuple( dtype );
			for ( i = 0; i < nfields; i++ ) {
				out[ i ] = fcn.call( thisArg, tuple[ i ], i, fields[ indices[i] ], tuple );
			}
			return out;
		}

		/**
		* Applies a function against an accumulator and each element in a tuple and returns the accumulated result.
		*
		* @private
		* @memberof tuple
		* @param {Function} fcn - reduction function
		* @param {*} [initial] - initial value
		* @throws {TypeError} `this` must be the host tuple
		* @throws {TypeError} first argument must be a function
		* @returns {*} accumulated result
		*/
		function reduce( fcn ) {
			var acc;
			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			if ( !isFunction( fcn ) ) {
				throw new TypeError( 'invalid argument. First argument must be a function. Value: `' + fcn + '`.' );
			}
			// TODO: implement
			return acc;
		}

		/**
		* Reverses a tuple **in-place**.
		*
		* @private
		* @memberof tuple
		* @throws {TypeError} `this` must be the host tuple
		* @returns {TypedArray} reversed tuple
		*/
		function reverse() {
			var tmp;
			var i;
			var j;
			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			for ( i = 0; i < floor( nfields/2 ); i++ ) {
				j = nfields - i - 1;
				tmp = tuple[ i ];
				tuple[ i ] = tuple[ j ];
				tuple[ j ] = tmp;
			}
			for ( i = 0; i < nfields; i++ ) {
				indices[ i ] = nfields - indices[ i ] - 1;
			}
			return tuple;
		}

		/**
		* Tests whether at least one tuple element passes a test implemented by a predicate function.
		*
		* @private
		* @memberof tuple
		* @param {Function} predicate - predicate function
		* @param {*} [thisArg] - execution context
		* @throws {TypeError} `this` must be the host tuple
		* @throws {TypeError} first argument must be a function
		* @returns {boolean} boolean indicating if at least one element passes
		*/
		function some( predicate, thisArg ) {
			var bool;
			var i;
			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			if ( !isFunction( predicate ) ) {
				throw new TypeError( 'invalid argument. First argument must be a function. Value: `' + predicate + '`.' );
			}
			for ( i = 0; i < nfields; i++ ) {
				bool = predicate.call( thisArg, tuple[ i ], i, fields[ indices[i] ], tuple );
				if ( bool ) {
					return true;
				}
			}
			return false;
		}

		/**
		* Create a new tuple over the same underlying `ArrayBuffer` and with the same underlying data type as the host tuple.
		*
		* @private
		* @memberof tuple
		* @param {NonNegativeInteger} [begin] - start element index (inclusive)
		* @param {NonNegativeInteger} [end] - end element index (exclusive)
		* @throws {TypeError} `this` must be the host tuple
		* @throws {RangeError} cannot create an empty named tuple
		* @throws {TypeError} first argument must be a nonnegative integer
		* @throws {TypeError} second argument must be a nonnegative integer
		* @returns {TypedArray} new tuple
		*/
		function subtuple( begin, end ) {
			var f;
			var i;
			var j;

			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			if ( arguments.length === 0 ) {
				return namedtypedtuple( tuple.buffer, tuple.byteOffset, dtype );
			}
			i = begin;
			if ( !isNonNegativeInteger( i ) ) {
				throw new TypeError( 'invalid argument. First argument must be a nonnegative integer. Value: `' + begin + '`.' );
			}
			if ( arguments.length === 1 ) {
				j = tuple.length;
			} else {
				j = end;
				if ( !isNonNegativeInteger( j ) ) {
					throw new TypeError( 'invalid argument. Second argument must be a nonnegative integer. Value: `' + end + '`.' );
				}
			}
			if ( i >= j ) {
				throw new RangeError( 'invalid arguments. Cannot create an empty named tuple. Ensure that the starting element index is less than the end element index.' );
			}
			f = [];
			for ( i = 0; i < j; i++ ) {
				f.push( fields[ indices[i] ] );
			}
			return factory( f, opts )( tuple.buffer, tuple.byteOffset+(begin*tuple.BYTES_PER_ELEMENT), dtype );
		}

		/**
		* Serializes a tuple as a string.
		*
		* @private
		* @memberof tuple
		* @throws {TypeError} `this` must be the host tuple
		* @returns {string} tuple string representation
		*/
		function toString() {
			var out;
			var i;

			if ( this !== tuple ) { // eslint-disable-line no-invalid-this
				throw new TypeError( 'invalid invocation. `this` is not host tuple.' );
			}
			out = opts.name + '(';
			for ( i = 0; i < nfields; i++ ) {
				out += fields[ indices[i] ];
				out += '=';
				out += tuple[ i ];
				if ( i < nfields-1 ) {
					out += ', ';
				}
			}
			out += ')';
			return out;
		}
	}

	/**
	* Creates a new tuple from a variable number of arguments.
	*
	* @private
	* @name of
	* @memberof namedtypedtuple
	* @type {Function}
	* @param {...number} element - tuple elements
	* @throws {TypeError} `this` must be the host tuple factory
	* @returns {TypedArray} new tuple
	*/
	defineProperty( namedtypedtuple, 'of', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': function of() { // eslint-disable-line no-restricted-syntax
			var args;
			var i;
			if ( this !== namedtypedtuple ) {
				throw new TypeError( 'invalid invocation. `this` is not the host tuple factory.' );
			}
			args = [];
			for ( i = 0; i < arguments.length; i++ ) {
				args.push( arguments[ i ] );
			}
			return namedtypedtuple( args );
		}
	});

	// TODO: (read-only) static method: from

	return namedtypedtuple;
}


// EXPORTS //

module.exports = factory;
