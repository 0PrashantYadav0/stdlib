'use strict';

// MODULES //

var isArray = require( '@stdlib/utils/is-array' );
var isObject = require( '@stdlib/utils/is-object' );
var isBoolean = require( '@stdlib/utils/is-boolean' ).isPrimitive;
var objectKeys = require( 'object-keys' ).shim();


// INVERT //

/**
* Inverts an object, such that keys become values and values become keys.
*
* @param {(Object|Array)} obj - input object
* @param {Options} [opts] - function options
* @param {boolean} [opts.duplicates=true] - boolean indicating whether to store duplicate keys
* @returns {Object} inverted object
*
* @example
* var out = invert({
* 	'a': 'beep',
*	'b': 'boop'
* });
* // returns {'beep':'a','boop':'b'}
*
* @example
* var out = invert({
* 	'a': 'beep',
* 	'b': 'beep'
* });
* // returns {'beep':['a','b']}
*
* @example
* var obj = {};
* obj.a = 'beep';
* obj.b = 'boop';
* obj.c = 'beep'; // inserted after `a`
*
* var out = invert( obj, {
* 	'duplicates': false
* });
* // returns {'beep':'c','boop':'b'}
*/
function invert( obj, opts ) {
	var allowDupes = true;
	var keys;
	var len;
	var key;
	var val;
	var out;
	var v;
	var i;
	if ( !isObject( obj ) && !isArray( obj ) ) {
		throw new TypeError( 'invalid input argument. First argument must be either a plain object or an array. Value: `' + obj + '`.' );
	}
	if ( arguments.length > 1 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'invalid input argument. Options arguments must be an object. Value: `' + opts + '`.' );
		}
		if ( opts.hasOwnProperty( 'duplicates' ) ) {
			allowDupes = opts.duplicates;
			if ( !isBoolean( allowDupes ) ) {
				throw new TypeError( 'invalid input argument. Duplicates option must be a boolean primitive. Option: `' + allowDupes + '`.' );
			}
		}
	}
	keys = objectKeys( obj );
	len = keys.length;
	out = {};
	if ( allowDupes ) {
		for ( i = 0; i < len; i++ ) {
			key = keys[ i ];
			val = obj[ key ];
			v = out[ val ];
			if ( v === void 0 ) {
				out[ val ] = key;
			}
			else if ( isArray( v ) ) {
				out[ val ].push( key );
			}
			else {
				out[ val ] = [ v, key ];
			}
		}
	} else {
		for ( i = 0; i < len; i++ ) {
			key = keys[ i ];
			out[ obj[ key ] ] = key;
		}
	}
	return out;
} // end FUNCTION invert()


// EXPORTS //

module.exports = invert;
