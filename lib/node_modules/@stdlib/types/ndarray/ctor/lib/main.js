'use strict';

// MODULES //

var BYTES_PER_ELEMENT = require( './bytes_per_element.json' );
var setterFactory = require( './set.js' );
var getterFactory = require( './get.js' );


// MAIN /

/**
* Returns an ndarray constructor.
*
* @param {string} dtype - data type
* @param {PositiveInteger} ndims - number of dimensions
* @returns {Function} ndarray constructor
*
* @example
* var ndarray = ctor( 'float64', 3 );
* // returns <Function>
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray( buffer, shape, strides, offset, 'row-major' );
*/
function ctor( dtype, ndims ) {
	var set = setterFactory( ndims );
	var get = getterFactory( ndims );
	/**
	* ndarray constructor.
	*
	* @private
	* @constructor
	* @param {(Array|TypedArray|Buffer)} buffer - data buffer
	* @param {NonNegativeIntegerArray} shape - array shape
	* @param {IntegerArray} strides - array strides
	* @param {NonNegativeInteger} offset - index offset
	* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
	* @returns {ndarray} ndarray instance
	*/
	function ndarray( buffer, shape, strides, offset, order ) {
		/* eslint-disable no-invalid-this, no-new-cap */
		var nbytes;
		var len;
		var i;
		if ( !(this instanceof ndarray) ) {
			return new ndarray( buffer, shape, strides, offset, order );
		}
		// Compute the number of elements...
		len = 1;
		for ( i = 0; i < ndims; i++ ) {
			len *= shape[ i ];
		}
		// Compute the number of bytes...
		if ( ndarray.BYTES_PER_ELEMENT ) {
			nbytes = ndarray.BYTES_PER_ELEMENT * len;
		} else {
			nbytes = null;
		}
		/**
		* Size (in bytes) of the array (if known).
		*
		* @private
		* @memberof this
		* @name byteLength
		* @type {(NonNegativeInteger|null)}
		*/
		Object.defineProperty( this, 'byteLength', {
			'configurable': false,
			'enumerable': false,
			'writable': false,
			'value': nbytes
		});

		/**
		* Pointer to the underlying data buffer.
		*
		* @private
		* @memberof this
		* @name data
		* @type {(Array|TypedArray|Buffer)}
		*/
		Object.defineProperty( this, 'data', {
			'configurable': false,
			'enumerable': false,
			'writable': false,
			'value': buffer
		});

		/**
		* Information about the memory layout of the array.
		*
		* @private
		* @memberof this
		* @name flags
		* @type {Object}
		*/
		Object.defineProperty( this, 'flags', {
			'configurable': false,
			'enumerable': false,
			'get': getInfo
		});

		/**
		* Length of the array.
		*
		* @private
		* @memberof this
		* @name length
		* @type {NonNegativeInteger}
		*/
		Object.defineProperty( this, 'length', {
			'configurable': false,
			'enumerable': false,
			'writable': false,
			'value': len
		});

		/**
		* Index offset which specifies the buffer index at which to start iterating over array elements.
		*
		* @private
		* @memberof this
		* @name offset
		* @type {NonNegativeInteger}
		*/
		Object.defineProperty( this, 'offset', {
			'configurable': false,
			'enumerable': false,
			'writable': false,
			'value': offset
		});

		/**
		* Array order.
		*
		* ## Notes
		*
		* -   The array order is either row-major (C-style) or column-major (Fortran-style).
		*
		*
		* @private
		* @memberof this
		* @name order
		* @type {string}
		*/
		Object.defineProperty( this, 'order', {
			'configurable': false,
			'enumerable': false,
			'writable': false,
			'value': order
		});

		/**
		* Shape of the array.
		*
		* @private
		* @memberof this
		* @name shape
		* @type {NonNegativeIntegerArray}
		*/
		Object.defineProperty( this, 'shape', {
			'configurable': false,
			'enumerable': false,
			'get': getShape
		});

		/**
		* Index strides which specify how to access data along corresponding array dimensions.
		*
		* @private
		* @memberof this
		* @name strides
		* @type {IntegerArray}
		*/
		Object.defineProperty( this, 'strides', {
			'configurable': false,
			'enumerable': false,
			'get': getStrides
		});

		/**
		* Returns an array element.
		*
		* @private
		* @memberof this
		* @name get
		* @type {Function}
		* @param {...integer} idx - indices
		* @returns {*} array element
		*/
		Object.defineProperty( this, 'get', {
			'configurable': false,
			'enumerable': false,
			'get': get( buffer, strides, offset )
		});

		/**
		* Sets an array element.
		*
		* @private
		* @memberof this
		* @name set
		* @type {Function}
		* @param {...integer} idx - indices
		* @param {*} v - value to set
		*/
		Object.defineProperty( this, 'set', {
			'configurable': false,
			'enumerable': false,
			'set': set( buffer, strides, offset )
		});

		return this;

		/**
		* Returns the array shape.
		*
		* @private
		* @returns {NonNegativeIntegerArray} array shape
		*/
		function getShape() {
			return shape.slice();
		} // end FUNCTION getShape()

		/**
		* Returns the array strides.
		*
		* @private
		* @returns {IntegerArray} array strides
		*/
		function getStrides() {
			return strides.slice();
		} // end FUNCTION getStrides()

		/**
		* Returns information regarding the memory layout of the array.
		*
		* @private
		* @returns {Object} array info
		*/
		function getInfo() {
			// TODO: reserved for later use
			return {};
		} // end FUNCTION getInfo()
	} // end FUNCTION ndarray()

	/**
	* Size (in bytes) of each array element (if known).
	*
	* @private
	* @memberof ndarray
	* @name BYTES_PER_ELEMENT
	* @type {(PositiveInteger|null)}
	*
	* @example
	* var nbytes = ndarray.BYTES_PER_ELEMENT;
	* // returns <number>
	*/
	Object.defineProperty( ndarray, 'BYTES_PER_ELEMENT', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': BYTES_PER_ELEMENT[ dtype ]
	});

	/**
	* Size (in bytes) of each array element (if known).
	*
	* @private
	* @memberof ndarray.prototype
	* @name BYTES_PER_ELEMENT
	* @type {(PositiveInteger|null)}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset );
	*
	* var nbytes = x.BYTES_PER_ELEMENT;
	* // returns <number>
	*/
	Object.defineProperty( ndarray.prototype, 'BYTES_PER_ELEMENT', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': ndarray.BYTES_PER_ELEMENT
	});

	/**
	* Underlying data type.
	*
	* @private
	* @memberof ndarray
	* @name dtype
	* @type {string}
	*
	* @example
	* var dtype = ndarray.dtype;
	* // returns <string>
	*/
	Object.defineProperty( ndarray, 'dtype', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': dtype
	});

	/**
	* Underlying data type.
	*
	* @private
	* @memberof ndarray.prototype
	* @name dtype
	* @type {string}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset );
	*
	* var dtype = x.dtype;
	* // returns <string>
	*/
	Object.defineProperty( ndarray.prototype, 'dtype', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': ndarray.dtype
	});

	/**
	* Number of dimensions.
	*
	* @private
	* @memberof ndarray
	* @name ndims
	* @type {PositiveInteger}
	*
	* @example
	* var ndims = ndarray.ndims;
	* // returns <number>
	*/
	Object.defineProperty( ndarray, 'ndims', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': ndims
	});

	/**
	* Number of dimensions.
	*
	* @private
	* @memberof ndarray.prototype
	* @name ndims
	* @type {PositiveInteger}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset );
	*
	* var ndims = x.ndims;
	* // returns <number>
	*/
	Object.defineProperty( ndarray.prototype, 'ndims', {
		'configurable': false,
		'enumerable': false,
		'writable': false,
		'value': ndims
	});

	return ndarray;
} // end FUNCTION ctor()


// EXPORTS //

module.exports = ctor;
