'use strict';

// MODULES //

var isObject = require( '@stdlib/assert/is-plain-object' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var isArrayLikeObject = require( '@stdlib/assert/is-array-like-object' );
var isTypedArrayLike = require( '@stdlib/assert/is-typed-array-like' );
var isBuffer = require( '@stdlib/assert/is-buffer' );
var isNonNegativeIntegerArray = require( '@stdlib/assert/is-nonnegative-integer-array' ).primitives;
var isIntegerArray = require( '@stdlib/assert/is-integer-array' ).primitives;
var isOrder = require( '@stdlib/types/ndarray/base/assert/is-order' );
var isDataType = require( '@stdlib/types/ndarray/base/assert/is-data-type' );


// MAIN //

/**
* Validates function options.
*
* @private
* @param {Object} opts - destination object
* @param {Options} options - function options
* @param {(ArrayLikeObject|TypedArrayLike|Buffer)} [options.buffer] - underlying data buffer
* @param {string} [options.dtype] - underlying storage data type
* @param {string} [options.order] - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @param {NonNegativeIntegerArray} [options.shape] - array shape
* @param {IntegerArray} [options.strides] - index strides which specify how to access data along corresponding array dimensions
* @returns {(Error|null)} null or an error object
*
* @example
* var opts = {};
* var options = {
*     'shape': [ 2, 3 ],
*     'strides': [ 3, 1 ],
*     'order': 'row-major',
*     'dtype': 'float64'
* };
* var err = validate( opts, options );
* if ( err ) {
*     throw err;
* }
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'invalid input argument. Options must be an object. Value: `' + options + '`.' );
	}
	if ( hasOwnProp( options, 'shape' ) ) {
		opts.shape = options.shape;
		if ( !isNonNegativeIntegerArray( opts.shape ) ) {
			return new TypeError( 'invalid option. `shape` option must be an array-like object containing nonnegative integers. Option: `' + opts.shape + '`.' );
		}
	}
	if ( hasOwnProp( options, 'buffer' ) ) {
		opts.buffer = options.buffer;
		if (
			!isArrayLikeObject( opts.buffer ) &&
			!isTypedArrayLike( opts.buffer ) &&
			!isBuffer( opts.buffer )
		) {
			return new TypeError( 'invalid option. `buffer` option must be an array-like object, typed-array-like, or a Buffer. Option: `' + opts.buffer + '`.' );
		}
	}
	if ( hasOwnProp( options, 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( !isDataType( opts.dtype ) ) {
			return new TypeError( 'invalid option. `dtype` option must be a recognized data type. Option: `' + opts.dtype + '`.' );
		}
	}
	if ( hasOwnProp( options, 'order' ) ) {
		opts.order = options.order;
		if ( !isOrder( opts.order ) ) {
			return new TypeError( 'invalid option. `order` option must be a recognized order. Option: `' + opts.order + '`.' );
		}
	}
	if ( hasOwnProp( options, 'strides' ) ) {
		opts.strides = options.strides;
		if ( !isIntegerArray( opts.strides ) ) {
			return new TypeError( 'invalid option. `strides` option must be an array-like object containing integers. Option: `' + opts.strides + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;
