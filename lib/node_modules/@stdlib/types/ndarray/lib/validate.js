'use strict';

// MODULES //

var isObject = require( '@stdlib/assert/is-plain-object' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var isArrayLike = require( '@stdlib/assert/is-array-like' );
var isNonNegativeInteger = require( '@stdlib/assert/is-nonnegative-integer' ).isPrimitive;
var isNonNegativeIntegerArray = require( '@stdlib/assert/is-nonnegative-integer-array' ).primitives;
var isIntegerArray = require( '@stdlib/assert/is-integer-array' ).primitives;
var indexOf = require( '@stdlib/utils/index-of' );
var ORDERS = require( './orders.json' );
var DTYPES = require( './dtypes.json' );


// MAIN //

/**
* Validates function options.
*
* @private
* @param {Object} opts - destination object
* @param {Options} options - function options
* @param {NonNegativeIntegerArray} options.shape - array shape
* @param {ArrayLike} [options.buffer] - underlying array buffer
* @param {string} [options.dtype] - underlying storage data type
* @param {NonNegativeInteger} [options.offset] - integer offset specifying where in the array buffer to begin indexing
* @param {string} [options.order] - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @param {IntegerArray} [options.strides] - index strides which specify how to access data along particular array dimensions
* @returns {(Error|null)} null or an error object
*
* @example
* var opts = {};
* var options = {
*     'shape': [ 2, 3 ],
*     'strides': [ 3, 1 ],
*     'offset': 10,
*     'order': 'row-major',
*     'dtype': 'float64'
* };
* var err = validate( opts, options );
* if ( err ) {
*     throw err;
* }
*/
function validate( opts, options ) {
	if ( !isObject( options ) ) {
		return new TypeError( 'invalid input argument. Options must be an object. Value: `' + options + '`.' );
	}
	opts.shape = options.shape;
	if ( !isNonNegativeIntegerArray( opts.shape ) ) {
		return new TypeError( 'invalid input argument. `shape` option must be an array-like object containing nonnegative integers. Option: `' + opts.shape + '`.' );
	}
	if ( hasOwnProp( options, 'buffer' ) ) {
		opts.buffer = options.buffer;
		if ( !isArrayLike( opts.buffer ) ) {
			return new TypeError( 'invalid option. `buffer` option must be array-like. Option: `' + opts.buffer + '`.' );
		}
	}
	if ( hasOwnProp( options, 'dtype' ) ) {
		opts.dtype = options.dtype;
		if ( indexOf( DTYPES, opts.dtype ) === -1 ) {
			return new TypeError( 'invalid option. `dtype` option must be a recognized data type. Supported data types: ' + DTYPES.join( ',' ) + '. Option: `' + opts.dtype + '`.' );
		}
	}
	if ( hasOwnProp( options, 'offset' ) ) {
		opts.offset = options.offset;
		if ( !isNonNegativeInteger( opts.offset ) ) {
			return new TypeError( 'invalid option. `offset` option must be a nonnegative integer. Option: `' + opts.offset + '`.' );
		}
	}
	if ( hasOwnProp( options, 'order' ) ) {
		opts.order = options.order;
		if ( indexOf( ORDERS, opts.order ) === -1 ) {
			return new TypeError( 'invalid option. `order` option must be a recognized order. Supported orders: ' + ORDERS.join( ',' ) + '. Option: `' + opts.order + '`.' );
		}
	}
	if ( hasOwnProp( options, 'strides' ) ) {
		opts.strides = options.strides;
		if ( !isIntegerArray( opts.strides ) ) {
			return new TypeError( 'invalid option. `strides` option must be an array-like object containing integers. Option: `' + opts.strides + '`.' );
		}
	}
	return null;
} // end FUNCTION validate()


// EXPORTS //

module.exports = validate;
