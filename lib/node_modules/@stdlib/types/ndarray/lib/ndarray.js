'use strict';

// MODULES //

var Int32Array = require( '@stdlib/types/array/int32' ); // eslint-disable-line no-redeclare
var Uint32Array = require( '@stdlib/types/array/uint32' ); // eslint-disable-line no-redeclare
var validate = require( './validate.js' );
var defaults = require( './defaults.json' );
var getType = require( './dtype.js' );
var createBuffer = require( './create_buffer.js' );
var castBuffer = require( './cast_buffer.js' );
var ctor = require( './get_ctor.js' );


// MAIN //

/**
* Returns a multidimensional array.
*
* @param {Options} options - function options
* @param {(ArrayLike|TypedArrayLike|Buffer)} [options.buffer] - underlying data buffer
* @param {string} [options.dtype="float64"] - underlying storage data type (if the input data is not of the same type, this option specifies the data type to which to cast the input data)
* @param {string} [options.order="row-major"] - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @param {NonNegativeIntegerArray} [options.shape] - array shape
* @param {IntegerArray} [options.strides] - index strides which specify how to access data along corresponding array dimensions
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {Error} must provide either a `shape` or `buffer` option
* @throws {Error} number of strides must match number of dimensions
* @throws {RangeError} buffer size must be compatible with desired array shape
* @returns {ndarray} ndarray instance
*
* @example
* TODO
*/
function ndarray( options ) {
	var strides;
	var offset;
	var buffer;
	var dtype;
	var shape;
	var ndims;
	var opts;
	var err;
	var len;
	var s;
	var i;

	opts = {};
	opts.order = defaults.order;

	err = validate( opts, options );
	if ( err ) {
		throw err;
	}
	// If not provided a shape, infer from a provided data buffer...
	if ( opts.shape ) {
		ndims = opts.shape.length;
		len = 1;

		// Compute the total number of elements...
		shape = new Uint32Array( ndims );
		for ( i = 0; i < ndims; i++ ) {
			shape[ i ] = opts.shape[ i ];
			len *= opts.shape[ i ];
		}
		if ( opts.buffer && len > opts.buffer.length ) {
			throw new RangeError( 'invalid input argument. Array shape is incompatible with provided buffer. To accommodate the requested shape, provide a bigger buffer.' );
		}
	} else if ( opts.buffer ) {
		ndims = 1;
		len = opts.buffer.length;

		// Assume a 1-dimensional array (vector):
		opts.shape = new Uint32Array( 1 );
		opts.shape[ 0 ] = len;
	} else {
		throw new Error( 'invalid input argument. Must provide either a `shape` or `buffer` option. Value: `' + JSON.stringify( options ) + '`.' );
	}
	// If not provided strides, compute them...
	if ( opts.strides ) {
		if ( opts.strides.length !== ndims ) {
			throw new Error( 'invalid option. Number of strides must match the number of dimensions.' );
		}
		strides = new Int32Array( ndims );
		for ( i = 0; i < ndims; i++ ) {
			strides[ i ] = opts.strides[ i ];
		}
		// TODO: validate that strides are compatible with shape
	} else {
		strides = new Int32Array( ndims );
		if ( opts.order === 'column-major' ) {
			s = 1;
			for ( i = 0; i < ndims; i++ ) {
				strides[ i ] = s;
				s *= shape[ i ];
			}
		} else { // row-major
			s = 1;
			for ( i = ndims-1; i >= 0; i-- ) {
				strides[ i ] = s;
				s *= shape[ i ];
			}
		}
	}
	// Determine the index "offset", accounting for negative strides, when indexing into the underlying buffer...
	offset = 0;
	for ( i = 0; i < ndims; i++ ) {
		if ( strides[ i ] < 0 ) {
			// Note that, since the stride is negative, this operation increments, not decrements, the offset...
			offset -= strides[ i ] * ( shape[ i ]-1 );
		}
	}
	// If not provided a data buffer, create it; otherwise, see if we need to cast a provided buffer to another data type...
	dtype = opts.dtype || defaults.dtype;
	if ( opts.buffer ) {
		if ( getType( opts.buffer ) === dtype ) {
			buffer = opts.buffer;
		} else {
			buffer = castBuffer( opts.buffer, len, dtype );
		}
	} else {
		buffer = createBuffer( len, dtype );
	}
	// Return a new ndarray:
	return ctor( dtype, ndims )( buffer, shape, strides, offset );
} // end FUNCTION ndarray()


// EXPORTS //

module.exports = ndarray;
