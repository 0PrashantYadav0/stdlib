'use strict';

// MODULES //

var shape2strides = require( '@stdlib/types/ndarray/base/shape2strides' );
var strides2offset = require( '@stdlib/types/ndarray/base/strides2offset' );
var numel = require( '@stdlib/types/ndarray/base/numel' );
var ctor = require( '@stdlib/types/ndarray/memoized-ctor' );
var validate = require( './validate.js' );
var defaults = require( './defaults.json' );
var getType = require( './dtype.js' );
var createBuffer = require( './create_buffer.js' );
var castBuffer = require( './cast_buffer.js' );


// MAIN //

/**
* Returns a multidimensional array.
*
* @param {Options} options - function options
* @param {(ArrayLikeObject|TypedArrayLike|Buffer)} [options.buffer] - underlying data buffer
* @param {string} [options.dtype="float64"] - underlying storage data type (if the input data is not of the same type, this option specifies the data type to which to cast the input data)
* @param {string} [options.order="row-major"] - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @param {NonNegativeIntegerArray} [options.shape] - array shape
* @param {IntegerArray} [options.strides] - index strides which specify how to access data along corresponding array dimensions
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {Error} must provide either a `shape` or `buffer` option
* @throws {Error} number of strides must match number of dimensions
* @throws {RangeError} buffer size must be compatible with desired array shape
* @returns {ndarray} ndarray instance
*
* @example
* TODO
*/
function ndarray( options ) {
	var strides;
	var offset;
	var buffer;
	var dtype;
	var shape;
	var ndims;
	var opts;
	var err;
	var len;

	opts = {};
	opts.order = defaults.order;

	// TODO: consider punting validation to constructor for certain options

	err = validate( opts, options );
	if ( err ) {
		throw err;
	}
	// If not provided a shape, infer from a provided data buffer...
	if ( opts.shape ) {
		shape = opts.shape;
		ndims = shape.length;
		len = numel( shape );
	} else if ( opts.buffer ) {
		ndims = 1;
		len = opts.buffer.length;

		// Assume a 1-dimensional array (vector):
		shape = new Array( 1 );
		shape[ 0 ] = len;
	} else {
		throw new Error( 'invalid input argument. Must provide either a `shape` or `buffer` option. Value: `' + JSON.stringify( options ) + '`.' );
	}
	// If not provided strides, compute them...
	if ( opts.strides ) {
		strides = opts.strides;

		// TODO: if not provided an order, infer the order (see strides2order)...
	} else {
		strides = shape2strides( shape, opts.order );
	}
	// Determine the index "offset":
	offset = strides2offset( shape, strides );

	// TODO: if provided an order differing from that inferred from strides, need to convert to that order. See https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.array.html#numpy.array.

	// TODO: support a `copy` option?

	// If not provided a data buffer, create it; otherwise, see if we need to cast a provided buffer to another data type...
	dtype = opts.dtype || defaults.dtype;
	if ( opts.buffer ) {
		if ( getType( opts.buffer ) === dtype ) {
			buffer = opts.buffer;
		} else {
			// TODO: beware when provided a buffer which is shorter than `len`. Are we zero-filling the rest? How to handle?
			buffer = castBuffer( opts.buffer, len, dtype );
		}
	} else {
		buffer = createBuffer( len, dtype );
	}
	// Return a new ndarray:
	return ctor( dtype, ndims )( buffer, shape, strides, offset, opts.order );
} // end FUNCTION ndarray()


// EXPORTS //

module.exports = ndarray;
