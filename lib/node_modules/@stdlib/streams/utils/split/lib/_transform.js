'use strict';

// MODULES //

var logger = require( 'debug' );
var Buffer = require( '@stdlib/buffer/ctor' );
var decode = require( './decode.js' );


// VARIABLES //

var debug = logger( 'split-stream' );


// MAIN //

/**
* Implements the `_transform` method.
*
* @private
* @param {(Buffer|string)} chunk - streamed chunk
* @param {string} encoding - Buffer encoding
* @param {Callback} clbk - callback to invoke after transforming the streamed chunk
*/
function transform( chunk, encoding, clbk ) {
	/* eslint-disable no-invalid-this */
	var splits;
	var split;
	var len;
	var i;

	this._idx += 1;
	debug( 'Received a new chunk. Chunk: %s. Encoding: %s. Index: %d.', chunk.toString(), encoding, this._idx );
	if ( encoding === 'buffer' ) {
		// Default Buffer decoding is 'utf8':
		chunk = chunk.toString();
	}
	else if ( encoding !== 'utf8' ) {
		// Decode the chunk as a 'utf8' string...
		chunk = new Buffer( chunk, encoding );
		chunk = chunk.toString( 'utf8' );
	}
	// Split the chunk:
	splits = chunk.split( this._sep );
	debug( 'Splits: %s. Index: %d.', JSON.stringify( splits ), this._idx );

	// How many splits do we have? We do not count the last "split", as it may be incomplete...
	len = splits.length - 1;
	debug( '%s splits. Index: %d.', len, this._idx );

	// If we do not have any splits, add the chunk to the buffer and wait for more data...
	if ( len === 0 ) {
		debug( 'No splits. Index: %d.', this._idx );
		this._buffer += splits[ len ];
	}
	// If we have split data, concat any previous partial split, re-decode (if need be) each split according to its original encoding, push each split to the destination, and set anything leftover as the new split buffer...
	else {
		debug( 'Processing splits. Index: %d.', this._index );
		split = this._buffer + splits[ 0 ];
		split = decode( split, encoding );

		debug( 'Split %d: %s. Index: %d.', 0, split.toString(), this._idx );
		this.push( split, encoding );
		for ( i = 1; i < len; i++ ) {
			split = decode( splits[ i ], encoding );
			debug( 'Split %d: %s. Index: %d.', i, split.toString(), this._idx );
			this.push( split, encoding );
		}
		debug( 'Remaining split: %s.', splits[len].toString() );
		this._buffer = splits[ len ];
	}
	clbk();
}


// EXPORTS //

module.exports = transform;
