'use strict';

// MODULES //

var debug = require( 'debug' )( 'plot:render:svg:marks' );
var xRugTransform = require( './utils/x_rug_transform.js' );
var yRugTransform = require( './utils/y_rug_transform.js' );


// RENDER //

/**
* Renders individual marks.
*
* @private
* @param {Object} state - state
* @returns {VTree} virtual tree
*/
function render( state ) {
	var rugTransformX;
	var rugTransformY;
	var lineStyle;
	var numStyles;
	var numColors;
	var numSyms;
	var symbol;
	var parent;
	var marks;
	var color;
	var xrug;
	var yrug;
	var line;
	var sym;
	var len;
	var tmp;
	var i;
	var j;
	var m;

	debug( 'Rendering marks group...' );
	parent = state.$.svg.marks.render();

	len = state.x.length;
	if ( len === 0 ) {
		debug( 'No individual marks to render.' );
		return parent;
	}
	sym = state.$.svg.symbols;
	line = state.$.svg.path;
	xrug = state.$.svg.xRug;
	yrug = state.$.svg.yRug;

	numStyles = state.lineStyles.length;
	numColors = state.colors.length;
	numSyms = state.symbols.length;

	debug( 'Rendering individual marks...' );
	for ( i = 0; i < len; i++ ) {
		marks = [];

		j = i + 1;
		debug( 'Rendering data %d of %d...', j, len );

		lineStyle = state.lineStyles[ i%numStyles ];
		debug( 'Line style: %s (%d).', lineStyle, j );

		color = state.colors[ i%numColors ];
		debug( 'Color: %s (%d).', color, j );

		// Lines...
		if ( lineStyle === '-' ) {
			debug( 'Rendering data as a line (%d)...', j );
			line.x = state.x[ i ];
			line.y = state.y[ i ];
			line.label = state.labels[ i ] || '';
			line.color = color || '';
			marks.push( line.render() );
		}

		symbol = state.symbols[ i%numSyms ];
		debug( 'Symbol: %s (%d).', symbol, j );

		// Symbols...
		if ( symbol !== 'none' ) {
			debug( 'Rendering data as symbols (%d)...', j );
			sym.x = state.x[ i ];
			sym.y = state.y[ i ];
			sym.symbol = symbol;
			sym.label = state.labels[ i ] || '';
			sym.color = color || '';
			sym.size = state.symbolSize; // TODO
			sym.opacity = state.symbolOpacity; // TODO
			marks.push( sym.render() );
		}
		// x-axis rugs...
		if ( state.xRug ) {
			debug( 'Rendering `x` values as a rug...' );
			xrug.data = state.x[ i ];
			xrug.label = state.labels[ i ] || '';
			xrug.color = color || '';
			xrug.size = 6; // TODO: prop(?)
			xrug.opacity = 0.1; // TODO: prop
			tmp = xrug.render();
			tmp.properties.className += ' x';
			if ( !rugTransformX ) {
				rugTransformX = xRugTransform( state.xAxisOrient, state.graphHeight );
			}
			if ( !tmp.properties.attributes ) {
				tmp.properties.attributes = {};
			}
			tmp.properties.attributes.transform = rugTransformX;
			marks.push( tmp );
		}
		// y-axis rugs...
		if ( state.yRug ) {
			debug( 'Rendering `y` values as a rug...' );
			yrug.data = state.y[ i ];
			yrug.label = state.labels[ i ] || '';
			yrug.color = color || '';
			yrug.size = 6; // TODO: prop(?)
			yrug.opacity = 0.1; // TODO: prop
			tmp = yrug.render();
			tmp.properties.className += ' y';
			if ( !rugTransformY ) {
				rugTransformY = yRugTransform( state.yAxisOrient, state.graphWidth );
			}
			if ( !tmp.properties.attributes ) {
				tmp.properties.attributes = {};
			}
			tmp.properties.attributes.transform = rugTransformY;
			marks.push( tmp );
		}
		if ( marks.length === 0 ) {
			debug( 'Unable to render data %d of %d.', j, len );
			continue;
		}
		debug( 'Inserting individual marks (%d) into marks group...', j );
		for ( m = 0; m < marks.length; m++ ) {
			parent.children.push( marks[ m ] );
			parent.count += marks[ m ].count;
		}
		debug( 'Finished rendering data %d of %d.', j, len );
	}
	debug( 'Finished rendering marks.' );
	return parent;
} // end FUNCTION render()


// EXPORTS //

module.exports = render;
