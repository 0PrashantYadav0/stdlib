'use strict';

// MODULES //

var debug = require( 'debug' )( 'plot:render:svg:marks' );
var Path = require( '@stdlib/plot/components/svg/path' );
var Symbols = require( '@stdlib/plot/components/svg/symbols' );
var Rug = require( '@stdlib/plot/components/svg/rug' );
var xRugTransform = require( './utils/x_rug_transform.js' );
var yRugTransform = require( './utils/y_rug_transform.js' );


// RENDER //

/**
* Renders individual marks.
*
* @private
* @param {Object} state - state
* @returns {VTree} virtual tree
*/
function render( state ) {
	var rugTransformX;
	var rugTransformY;
	var lineStyle;
	var numStyles;
	var numColors;
	var numSyms;
	var symbol;
	var parent;
	var color;
	var xrug;
	var yrug;
	var line;
	var sym;
	var len;
	var i;
	var j;

	debug( 'Rendering marks group...' );
	parent = state.$.svg.marks.render();

	len = state.x.length;
	if ( len === 0 ) {
		debug( 'No individual marks to render.' );
		return parent;
	}
	numStyles = state.lineStyles.length;
	numColors = state.colors.length;
	numSyms = state.symbols.length;

	debug( 'Rendering individual marks...' );
	for ( i = 0; i < len; i++ ) {
		line = null;
		sym = null;

		j = i + 1;
		debug( 'Rendering data %d of %d...', j, len );

		lineStyle = state.lineStyles[ i%numStyles ];
		debug( 'Line style: %s (%d).', lineStyle, j );

		color = state.colors[ i%numColors ];
		debug( 'Color: %s (%d).', color, j );

		// Lines...
		if ( lineStyle === '-' ) {
			debug( 'Rendering data as a line (%d)...', j );
			line = new Path({
				'x': state.x[ i ],
				'y': state.y[ i ],
				'xScale': state.xScale,
				'yScale': state.yScale,
				'isDefined': state.isDefined,
				'label': state.labels[ i ] || '',
				'color': color || '',
				'autoRender': false
			});
			line = line.render();
		}

		symbol = state.symbols[ i%numSyms ];
		debug( 'Symbol: %s (%d).', symbol, j );

		// Symbols...
		if ( symbol !== 'none' ) {
			debug( 'Rendering data as symbols (%d)...', j );
			sym = new Symbols({
				'symbol': symbol,
				'x': state.x[ i ],
				'y': state.y[ i ],
				'xScale': state.xScale,
				'yScale': state.yScale,
				'isDefined': state.isDefined,
				'label': state.labels[ i ] || '',
				'color': color || '',
				'size': state.symbolSize,
				'opacity': state.symbolOpacity,
				'autoRender': false
			});
			sym = sym.render();
		}

		// x-axis rugs...
		if ( state.xRug ) {
			debug( 'Rendering `x` values as a rug...' );
			xrug = new Rug({
				'data': state.x[ i ],
				'scale': state.xScale,
				'orientation': state.xAxisOrient, // TODO: prop (xRugOrient)
				'isDefined': state.isDefined,
				'label': state.labels[ i ] || '',
				'color': color || '',
				'size': 6, // TODO: prop(?)
				'opacity': 0.1, // TODO: prop
				'autoRender': false
			});
			xrug = xrug.render();
			xrug.properties.className += ' x';
			if ( !rugTransformX ) {
				rugTransformX = xRugTransform( state.xAxisOrient, state.graphHeight );
			}
			if ( !xrug.properties.attributes ) {
				xrug.properties.attributes = {};
			}
			xrug.properties.attributes.transform = rugTransformX;
		}

		// y-axis rugs...
		if ( state.yRug ) {
			debug( 'Rendering `y` values as a rug...' );
			yrug = new Rug({
				'data': state.y[ i ],
				'scale': state.yScale,
				'orientation': state.yAxisOrient, // TODO: prop (yRugOrient)
				'isDefined': state.isDefined,
				'label': state.labels[ i ] || '',
				'color': color || '',
				'size': 6, // TODO: prop(?)
				'opacity': 0.1, // TODO: prop
				'autoRender': false
			});
			yrug = yrug.render();
			yrug.properties.className += ' y';
			if ( !rugTransformY ) {
				rugTransformY = yRugTransform( state.yAxisOrient, state.graphWidth );
			}
			if ( !yrug.properties.attributes ) {
				yrug.properties.attributes = {};
			}
			yrug.properties.attributes.transform = rugTransformY;
		}

		if ( !line && !sym && !xrug && !yrug ) {
			debug( 'Unable to render data %d of %d.', j, len );
			continue;
		}
		debug( 'Finished rendering data %d of %d.', j, len );

		debug( 'Inserting data marks (%d) into marks group...', j );
		if ( line ) {
			parent.children.push( line );
			parent.count += line.count;
		}
		if ( sym ) {
			parent.children.push( sym );
			parent.count += sym.count;
		}
		if ( xrug ) {
			parent.children.push( xrug );
			parent.count += xrug.count;
		}
		if ( yrug ) {
			parent.children.push( yrug );
			parent.count += yrug.count;
		}
	}
	debug( 'Finished rendering marks.' );
	return parent;
} // end FUNCTION render()


// EXPORTS //

module.exports = render;
