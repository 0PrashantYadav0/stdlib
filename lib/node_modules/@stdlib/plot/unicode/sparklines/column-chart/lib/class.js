'use strict';

// MODULES //

var isTypedArray = require( '@stdlib/utils/is-typed-array' );
var isNumberArray = require( '@stdlib/utils/is-number' ).isPrimitiveNumberArray;
var isNumber = require( '@stdlib/utils/is-number' ).isPrimitive;
var isBoolean = require( '@stdlib/utils/is-boolean' ).isPrimitive;
var isNull = require( '@stdlib/utils/is-null' );
var isnan = require( '@stdlib/math/base/utils/is-nan' );
var isInfinite = require( '@stdlib/math/base/utils/is-infinite' );
var abs = require( '@stdlib/math/base/special/abs' );
var round = require( '@stdlib/math/base/special/round' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );
var NINF = require( '@stdlib/math/constants/float64-ninf' );
var validate = require( './validate.js' );


// VARIABLES //

// See [Block Elements]{@link https://en.wikipedia.org/wiki/Block_Elements}.
var UNICODE_BLOCK_ELEMENTS = [
	'▁', // U+2581, lower 1/8
	'▂', // U+2582, lower 2/8
	'▃', // U+2583, lower 3/8
	'▄', // U+2584, lower 4/8
	'▅', // U+2585, lower 5/8
	'▆', // U+2586, lower 6/8
	'▇', // U+2587, lower 7/8
	'█'  // U+2588, full block
];
var UNICODE_INF = '∞'; // U+221E
var MISSING_VALUE = ' ';


// COLUMN CHART //

/**
* Unicode column chart constructor.
*
* @constructor
* @param {Options} [options] - chart options
* @param {NumericArray} [options.data] - chart data
* @param {number} [options.ymin] - minimum value of the y-axis domain
* @param {number} [options.ymax] - maximum value of the y-axis domain
* @param {boolean} [options.infinities=false] - boolean indicating whether to encode infinite values
* @throws {TypeError} must provide valid options
* @returns {ColumnChart} chart instance
*
* @example
*
*/
function ColumnChart( options ) {
	var opts;
	var err;
	var d;
	var i;
	if ( !(this instanceof ColumnChart) ) {
		if ( arguments.length ) {
			return new ColumnChart( options );
		}
		return new ColumnChart();
	}
	opts = {};
	if ( arguments.length ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	Object.defineProperty( this, '_ymin', {
		'configurable': false,
		'enumerable': false,
		'writable': true,
		'value': null
	});
	Object.defineProperty( this, '_ymax', {
		'configurable': false,
		'enumerable': false,
		'writable': true,
		'value': null
	});
	Object.defineProperty( this, '_data', {
		'configurable': false,
		'enumerable': false,
		'writable': true,
		'value': []
	});
	Object.defineProperty( this, '_infinities', {
		'configurable': false,
		'enumerable': false,
		'writable': true,
		'value': false
	});
	if ( opts.ymin !== void 0 ) {
		this._ymin = opts.ymin;
	}
	if ( opts.ymax !== void 0 ) {
		this._ymax = opts.ymax;
	}
	if ( opts.infinities !== void 0 ) {
		this._infinities = opts.infinities;
	}
	if ( opts.data !== void 0 ) {
		this._data = new Array( opts.data.length );
		for ( i = 0; i < opts.data.length; i++ ) {
			d = {};
			d.y = opts.data[ i ];
			if ( isnan( d.y ) ) {
				d.flg = 'nan';
			}
			else if ( isInfinite( d.y ) ) {
				d.flg = 'inf';
			}
			this._data[ i ] = d;
		}
	}
	return this;
} // end FUNCTION ColumnChart()

/**
* Minimum value of the y-axis domain.
*
* @memberof ColumnChart.prototype
* @name ymin
* @type {(number|null)}
* @throws {TypeError} must be a number primitive or null
*
* @example
*
*/
Object.defineProperty( ColumnChart.prototype, 'ymin', {
	'configurable': false,
	'enumerable': true,
	'set': function setYMin( min ) {
		if ( !isNumber( min ) && !isNull( min ) ) {
			throw new TypeError( 'invalid option. `ymin` must be a number primitive or null. Value: `' + min + '`.' );
		}
		this._ymin = min;
	},
	'get': function getYMin() {
		return this._ymin;
	}
});

/**
* Maximum value of the y-axis domain.
*
* @memberof ColumnChart.prototype
* @name ymax
* @type {(number|null)}
* @throws {TypeError} must be a number primitive or null
*
* @example
*
*/
Object.defineProperty( ColumnChart.prototype, 'ymax', {
	'configurable': false,
	'enumerable': true,
	'set': function setYMax( max ) {
		if ( !isNumber( max ) && !isNull( max ) ) {
			throw new TypeError( 'invalid option. `ymax` must be a number primitive or null. Value: `' + max + '`.' );
		}
		this._ymax = max;
	},
	'get': function getYMax() {
		return this._ymax;
	}
});

/**
* Boolean indicating whether to encode infinite values.
*
* @memberof ColumnChart.prototype
* @name infinities
* @type {boolean}
* @default false
* @throws {TypeError} must be a boolean primitive
*
* @example
*
*/
Object.defineProperty( ColumnChart.prototype, 'infinities', {
	'configurable': false,
	'enumerable': true,
	'set': function setInfinities( bool ) {
		if ( !isBoolean( bool ) ) {
			throw new TypeError( 'invalid option. `infinities` must be a boolean primitive. Value: `' + bool + '`.' );
		}
		this._infinities = bool;
	},
	'get': function getInfinities() {
		return this._infinities;
	}
});

/**
* Chart data.
*
* @memberof ColumnChart.prototype
* @name data
* @type {NumericArray}
* @throws {TypeError} must be a numeric array
*
* @example
*
*/
Object.defineProperty( ColumnChart.prototype, 'data', {
	'configurable': false,
	'enumerable': true,
	'set': function setData( data ) {
		var d;
		var i;
		if (
			!isNumberArray( data ) &&
			!isTypedArray( data )
		) {
			throw new TypeError( 'invalid input argument. Must be a numeric array. Value: `' + data + '`.' );
		}
		this._data = new Array( data.length );
		for ( i = 0; i < data.length; i++ ) {
			d = {};
			d.y = data[ i ];
			if ( isnan( d.y ) ) {
				d.flg = 'nan';
			}
			else if ( isInfinite( d.y ) ) {
				d.flg = 'inf';
			}
			this._data[ i ] = d;
		}
	},
	'get': function getData() {
		// TODO: should this be a copy, as could mutate data and invalidate? Yes.
		return this._data;
	}
});

/**
* Renders a chart.
*
* @memberof ColumnChart.prototype
* @function render
* @returns {string} rendered chart
*
* @example
*
*/
ColumnChart.prototype.render = function render() {
	var blocks;
	var range;
	var str;
	var min;
	var max;
	var len;
	var idx;
	var d;
	var v;
	var n;
	var i;

	len = this._data.length;
	if ( len === 0 ) {
		return '';
	}
	if ( this._ymin === null ) {
		min = PINF;
	} else {
		min = this._ymin;
	}
	if ( this._ymax === null ) {
		max = NINF;
	} else {
		max = this._ymax;
	}
	for ( i = 0; i < len; i++ ) {
		d = this._data[ i ];
		if (
			d.flg === 'nan' ||
			d.flg === 'inf'
		) {
			continue;
		}
		if (
			this._ymin === null &&
			d.y < min
		) {
			min = d.y;
		}
		else if (
			this._ymax === null &&
			d.y > max
		) {
			max = d.y;
		}
	}
	range = abs( max - min );

	// Check if data is constant...
	if ( range === 0.0 ) {
		// If `max` is `0`, encode each datum as the smallest block glyph...
		if ( max === 0.0 ) {
			blocks = [ UNICODE_BLOCK_ELEMENTS[ 0 ] ];
		}
		// Otherwise, encode each datum as a mid-sized block glyph...
		else {
			blocks = [ UNICODE_BLOCK_ELEMENTS[ 3 ] ];
		}
	} else {
		blocks = UNICODE_BLOCK_ELEMENTS;
	}
	// Generate the sparkline chart, assigning a block glyph to each datum...
	n = blocks.length - 1;
	str = '';
	for ( i = 0; i < len; i++ ) {
		d = this._data[ i ];
		if ( d.flg ) {
			if (
				d.flg === 'inf' &&
				this._infinities
			) {
				str += UNICODE_INF;
			} else {
				str += MISSING_VALUE;
			}
			continue;
		}
		// Normalize the datum (aka feature scaling):
		v = ( d.y - min ) / range;

		// Determine the glyph index:
		idx = round( v * n );
		if ( idx < 0 ) {
			idx = 0;
		}
		// Add the glyph to the chart:
		str += UNICODE_BLOCK_ELEMENTS[ idx ];
	}
	return str;
}; // end METHOD render()

/**
* Serializes a chart as a string.
*
* @memberof ColumnChart.prototype
* @function toString
* @returns {string} serialized chart
*
* @example
*
*/
ColumnChart.prototype.toString = function toString() {
	return this.render();
}; // end METHOD toString()


// EXPORTS //

module.exports = ColumnChart;
