'use strict';

// MODULES //

var isTypedArray = require( '@stdlib/utils/is-typed-array' );
var isNumberArray = require( '@stdlib/utils/is-number' ).isPrimitiveNumberArray;
var isnan = require( '@stdlib/math/base/utils/is-nan' );
var isInfinite = require( '@stdlib/math/base/utils/is-infinite' );
var abs = require( '@stdlib/math/base/special/abs' );
var round = require( '@stdlib/math/base/special/round' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );
var NINF = require( '@stdlib/math/constants/float64-ninf' );
var validate = require( './validate.js' );


// VARIABLES //

// See [Block Elements]{@link https://en.wikipedia.org/wiki/Block_Elements}.
var UNICODE_BLOCK_ELEMENTS = [
	'▁', // U+2581, lower 1/8
	'▂', // U+2582, lower 2/8
	'▃', // U+2583, lower 3/8
	'▄', // U+2584, lower 4/8
	'▅', // U+2585, lower 5/8
	'▆', // U+2586, lower 6/8
	'▇', // U+2587, lower 7/8
	'█'  // U+2588, full block
];
var UNICODE_INF = '∞'; // U+221E
var MISSING_VALUE = ' ';


// COLUMN CHART //

/**
* Generates a Unicode sparkline column chart.
*
* @param {NumericArray} data - chart data
* @param {Options} [options] - chart options
* @param {number} [options.ymin] - minimum value of the y-axis domain
* @param {number} [options.ymax] - maximum value of the y-axis domain
* @param {boolean} [options.infinities=false] - boolean indicating whether to encode infinite values
* @throws {TypeError} must provide valid data
* @throws {TypeError} must provide valid options
* @returns {string} sparkline column chart
*
* @example
*
*/
function columnChart( data, options ) {
	var blocks;
	var range;
	var flgs;
	var opts;
	var err;
	var str;
	var min;
	var max;
	var len;
	var idx;
	var d;
	var n;
	var i;
	if (
		!isNumberArray( data ) &&
		!isTypedArray( data )
	) {
		throw new TypeError( 'invalid input argument. First argument must be a numeric array. Value: `' + data + '`.' );
	}
	len = data.length;
	if ( len === 0 ) {
		return '';
	}
	opts = {};
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( opts.ymin === void 0 ) {
		min = PINF;
	} else {
		min = opts.ymin;
	}
	if ( opts.ymax === void 0 ) {
		max = NINF;
	} else {
		max = opts.ymax;
	}
	// Filter input data and, if necessary, update the min and max values...
	flgs = {};
	for ( i = 0; i < len; i++ ) {
		d = data[ i ];
		if ( isnan( d ) ) {
			flgs[ i ] = MISSING_VALUE;
		}
		else if ( isInfinite( d ) ) {
			if ( opts.infinities ) {
				flgs[ i ] = UNICODE_INF;
			} else {
				flgs[ i ] = MISSING_VALUE;
			}
		}
		else if (
			opts.ymin === void 0 &&
			d < min
		) {
			min = d;
		}
		else if (
			opts.ymax === void 0 &&
			d > max
		) {
			max = d;
		}
	}
	range = abs( max - min );

	// Check if data is constant...
	if ( range === 0.0 ) {
		// If `max` is `0`, encode each datum as the smallest block glyph...
		if ( max === 0.0 ) {
			blocks = [ UNICODE_BLOCK_ELEMENTS[ 0 ] ];
		}
		// Otherwise, encode each datum as a mid-sized block glyph...
		else {
			blocks = [ UNICODE_BLOCK_ELEMENTS[ 3 ] ];
		}
	} else {
		blocks = UNICODE_BLOCK_ELEMENTS;
	}
	// Generate the sparkline chart, assigning a block glyph to each datum...
	n = blocks.length - 1;
	str = '';
	for ( i = 0; i < len; i++ ) {
		if ( flgs[ i ] ) {
			str += flgs[ i ];
			continue;
		}
		// Normalize the datum (aka feature scaling):
		d = ( data[i] - min ) / range;

		// Determine the glyph index:
		idx = round( d * n );
		if ( idx < 0 ) {
			idx = 0;
		}
		// Add the glyph to the chart:
		str += UNICODE_BLOCK_ELEMENTS[ idx ];
	}
	return str;
} // end FUNCTION columnChart()


// EXPORTS //

module.exports = columnChart;
