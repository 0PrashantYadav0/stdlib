'use strict';

// MODULES //

var abs = require( '@stdlib/math/base/special/abs' );
var round = require( '@stdlib/math/base/special/round' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );
var NINF = require( '@stdlib/math/constants/float64-ninf' );


// VARIABLES //

// See [Braille Patterns]{@link https://en.wikipedia.org/wiki/Braille_Patterns}.
var UNICODE_BRAILLE_ELEMENTS = [
	[ '⣀', '⡠', '⡐', '⡈' ], // U+28C0, U+2860, U+2850, U+2848
	[ '⢄', '⠤', '⠔', '⠌' ], // U+2884, U+2824, U+2814, U+2802
	[ '⢂', '⠢', '⠒', '⠊' ], // U+2882, U+2822, U+2812, U+280A
	[ '⢁', '⠡', '⠑', '⠉' ]  // U+2881, U+2821, U+2811, U+2809
];
var UNICODE_INF = '∞'; // U+221E
var MISSING_VALUE = ' ';


// RENDER //

/**
* Renders a chart.
*
* @private
* @returns {string} rendered chart
*/
function render() {
	/* jshint validthis: true */ // TODO: eslint
	var glyphs;
	var range;
	var str;
	var min;
	var max;
	var len;
	var idx;
	var d;
	var v;
	var n;
	var i;
	var j;

	len = this._data.length;
	if ( len === 0 ) {
		return '';
	}
	if ( this._yMin === null ) {
		min = PINF;
		for ( i = 0; i < len; i++ ) {
			d = this._data[ i ];
			if ( !d.flg && d.y < min ) {
				min = d.y;
			}
		}
	} else {
		min = this._yMin;
	}
	if ( this._yMax === null ) {
		max = NINF;
		for ( i = 0; i < len; i++ ) {
			d = this._data[ i ];
			if ( !d.flg && d.y > max ) {
				max = d.y;
			}
		}
	} else {
		max = this._yMax;
	}
	range = abs( max - min );

	// Check if data is constant...
	if ( range === 0.0 ) {
		// If `max` is `0`, encode each finite datum as the lowest Braille glyph...
		if ( max === 0.0 ) {
			glyphs = [ [ UNICODE_BRAILLE_ELEMENTS[0][0] ] ];
		}
		// Otherwise, encode each finite datum as a mid-sized Braille glyph...
		else {
			glyphs = [ [ UNICODE_BRAILLE_ELEMENTS[2][2] ] ];
		}
	} else {
		glyphs = UNICODE_BRAILLE_ELEMENTS;
	}
	// Assign each datum to a bin...
	idx = new Array( len );
	n = glyphs.length - 1;
	for ( i = 0; i < len; i++ ) {
		d = this._data[ i ];
		if ( d.flg ) {
			continue;
		}
		// Normalize the datum (aka feature scaling):
		if ( range ) {
			v = ( d.y - min ) / range;
		} else {
			v = 0.0;
		}
		// Determine the bin index:
		j = round( v * n );
		if ( j < 0 ) {
			j = 0;
		} else if ( j > n ) {
			j = n;
		}
		idx[ i ] = j;
	}

	// TODO: color encoding: one color for both pos and neg or two colors for separate colors
	// TODO: negative values diff color (red)

	// For each datum, we peek ahead to determine if the next value is greater than or less than the current value. The magnitude of the difference determines the glyph slope.
	str = '';
	for ( i = 0; i < len; i++ ) {
		d = this._data[ i ];
		if ( d.flg ) {
			if (
				d.flg === 'inf' &&
				this._infinities
			) {
				str += UNICODE_INF;
			} else {
				str += MISSING_VALUE;
			}
			continue;
		}
		if ( i === len-1 ) {
			// The final glyph is flat, as the next value is unknown...
			j = idx[ i ];
			str += glyphs[ j ][ j ];
			break;
		}
		j = i + 1;
		n = this._data[ j ];
		if ( n.flg ) {
			if ( n.y === PINF ) {
				j = 3; // highest bin
			} else if ( n.y === NINF ) {
				j = 0; // lowest bin
			} else {
				j = idx[ i ]; // same bin, as no slope can be inferred from a missing value
			}
		} else {
			j = idx[ j ]; // slope toward the next value's bin
		}
		str += glyphs[ idx[i] ][ j ];
	}
	return str;
} // end FUNCTION render()


// EXPORTS //

module.exports = render;
