/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var isPositiveInteger = require( '@stdlib/assert/is-positive-integer' ).isPrimitive;
var isMatrixLike = require( '@stdlib/assert/is-matrix-like' );
var isVectorLike = require( '@stdlib/assert/is-vector-like' );
var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var minstd = require( '@stdlib/random/base/minstd-shuffle' );
var createMatrix = require( './matrix.js' );
var copyMatrix = require( './copy_matrix.js' );
var createVector = require( './vector.js' );
var sample = require( './init_sample.js' );
var kmeansplusplus = require( './init_kmeansplusplus.js' );
var validate = require( './validate.js' );
var INIT_DEFAULTS = require( './init_defaults.json' );


// VARIABLES //

// Number of cluster statistics:
var NSTATS = 4; // [ n_obs, sum_dist, mean_dist, stdev_dist ]


// FUNCTIONS //

/**
* Returns a results object.
*
* @private
* @param {PositiveInteger} k - number of clusters
* @param {PositiveInteger} ndims - number of dimensions
* @returns {Object} results object
*/
function createResults( k, ndims ) {
	var out = {};
	out.centroids = createMatrix( k, ndims, false ); // high-level
	out.stats = createMatrix( k, NSTATS, false ); // high-level
	return out;
}


// MAIN //

/**
* Returns an accumulator function which incrementally partitions data into `k` clusters.
*
* @param {(PositiveInteger|ndarray)} K - number of clusters or a `kxd` matrix containing initial centroids (where `d` is the number of dimensions)
* @param {Options} [options] - function options
* @param {string} [options.metric="euclidean"] - distance metric
* @param {ArrayLikeObject} [options.init] - method for determining initial centroids
* @param {boolean} [options.normalize=true] - boolean indicating whether to normalize incoming data (only relevant for non-Euclidean distance metrics)
* @param {*} [options.seed] - PRNG seed
* @throws {TypeError} first argument must be a positive integer
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {RangeError} when using sampling to generate initial centroids, the sample size must be greater than or equal to the number of clusters
* @returns {Function} accumulator function
*
* @example
* TODO
*/
function incrkmeans( K, options ) {
	var centroids;
	var results;
	var buffer;
	var stats;
	var ndims;
	var opts;
	var err;
	var k;

	if ( isMatrixLike( K ) ) {
		k = centroids.shape[ 0 ];
		ndims = centroids.shape[ 1 ];
		centroids = createMatrix( k, ndims, true ); // low-level
		centroids = copyMatrix( centroids, K );
	} else if ( isPositiveInteger( K ) ) {
		k = K;
	} else {
		throw new TypeError( 'invalid input argument. First argument must either be a positive integer specifying the number of clusters or a matrix containing initial centroids. Value: `' + K + '`.' );
	}
	opts = {
		'metric': 'euclidean',
		'init': INIT_DEFAULTS[ 'kmeans++' ].slice(),
		'seed': minstd(),
		'normalize': true
	};
	opts.init[ 1 ] = k;
	if ( arguments.length > 1 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	if ( opts.init[ 1 ] < k ) {
		throw new RangeError( 'invalid option. First `init` parameter option must be greater than or equal to the number of clusters. Options: `' + opts.init[ 1 ] + '`.' );
	}
	// Initialize a results object:
	results = createResults( k, ndims );

	// Initialize an internal matrix for tabulating cluster statistics:
	stats = createMatrix( k, NSTATS, true ); // low-level

	setReadOnly( accumulator, 'SEED', opts.seed );
	setReadOnly( accumulator, 'predict', predict );
	return accumulator;

	/**
	* If provided a data vector, the accumulator function returns updated centroids. If not provided a data vector, the accumulator function returns the current centroids.
	*
	* @private
	* @param {ndarray} [v] - data vector
	* @throws {TypeError} must provide a 1-dimensional ndarray
	* @throws {Error} vector length must match centroid dimensions
	* @returns {(ndarray|null)} centroids or null
	*/
	function accumulator( v ) {
		var i;
		var j;
		if ( arguments.length === 0 ) {
			if ( centroids === void 0 ) {
				return null;
			}
			return results;
		}
		if ( !isVectorLike( v ) ) {
			throw new TypeError( 'invalid input argument. Must provide a 1-dimensional ndarray. Value: `' + v + '`.' );
		}
		// Check if we have yet to determine input vector dimensionality...
		if ( ndims === void 0 ) {
			// Determine the dimensionality from the first provided data vector:
			ndims = v.shape[ 0 ];
		} else if ( v.shape[ 0 ] !== ndims ) {
			throw new Error( 'invalid input argument. Vector length must match centroid dimensions. Expected: ' + ndims + '. Actual: ' + v.shape[ 0 ] + '.' );
		}
		// Check if we have yet to compute initial centroids...
		if ( centroids === void 0 ) {
			// If this is the first data vector, we need to begin caching data vectors for future centroid initialization...
			if ( buffer === void 0 ) {
				// Create a data buffer:
				buffer = createMatrix( k, ndims, true ); // low-level

				// Copy data into the buffer (why? because (1) we have no guarantee that program execution is synchronous, and, thus, we have no guarantee that data vectors will not have been mutated before sampling, and (2) we can freely mutate buffer data, as may be needed during normalization):
				for ( j = 0; j < ndims; j++ ) {
					buffer.set( 0, j, v.get( j ) );
				}
				buffer.count = 1;
				return null;
			}
			// Check if we are still building our cache of data vectors...
			if ( buffer.count < opts.init[ 1 ] ) {
				i = buffer.count;
				for ( j = 0; j < ndims; j++ ) {
					buffer.set( i, j, v.get( j ) );
				}
				buffer.count += 1;
				return null;
			}
			// Initialize a matrix for storing centroids:
			centroids = createMatrix( k, ndims, true ); // low-level

			// Compute initial centroids...
			if ( opts.init[ 0 ] === 'kmeans++' ) {
				centroids = kmeansplusplus( centroids, buffer, opts.metric, opts.normalize, opts.init[ 2 ], opts.seed ); // eslint-disable-line max-len
			} else if ( opts.init[ 0 ] === 'sample' ) {
				centroids = sample( centroids, buffer, opts.seed );
			} else {
				// TODO: random data point generation based on range (?)
			}
			// Release the cached data vectors:
			buffer.length = 0;
		} else {
			// TODO: update k-means model
		}
		// Update the results object:
		copyMatrix( results.centroids, centroids );
		copyMatrix( results.stats, stats );

		return results;
	}

	/**
	* Computes data point distances to centroids and returns centroid assignment predictions.
	*
	* @private
	* @param {ndarray} X - matrix containing data points (`n x d`, where `n` is the number of data points and `d` is the number of dimensions)
	* @throws {TypeError} must provide a matrix
	* @throws {Error} number of matrix columns must match centroid dimensions
	* @returns {ndarray} vector containing centroid (index) predictions
	*/
	function predict( X ) {
		var out;
		if ( !isMatrixLike( X ) ) {
			throw new TypeError( 'invalid argument. Must provide a 2-dimensional ndarray. Value: `' + X + '`.' );
		}
		if ( X.shape[ 1 ] !== ndims ) {
			throw new Error( 'invalid input argument. Number of matrix columns must match centroid dimensions. Expected: ' + ndims + '. Actual: ' + X.shape[ 1 ] + '.' );
		}
		out = createVector( out.shape[ 0 ], false ); // high-level

		// TODO: compute distances and assign data points to centroids

		return out;
	}
}


// EXPORTS //

module.exports = incrkmeans;
