/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable array-element-newline */

'use strict';

var discreteUniform = require( '@stdlib/random/base/discrete-uniform' );
var normal = require( '@stdlib/random/base/normal' ).factory;
var ndarray = require( '@stdlib/ndarray/ctor' );
var Float64Array = require( '@stdlib/array/float64' );
var incrkmeans = require( './../lib' );

var clusters;
var results;
var randn;
var ctor;
var acc;
var N;
var k;
var c;
var v;
var x;
var y;
var i;

// Define the number of data points to simulate:
N = 1e4;

// Define the number of clusters:
k = 5;

// Define cluster properties:
ctor = ndarray( 'float64', 2 );
clusters = new Float64Array([
	0.0, 1.0, 0.0, 1.0, // meanX, stdevX, meanY, stdevY
	-5.0, 1.0, 5.0, 1.0,
	5.0, 1.0, 5.0, 1.0,
	-5.0, 1.0, -5.0, 1.0,
	-5.0, 1.0, 5.0, 1.0
]);
clusters = ctor( clusters, [ k, 4 ], [ 4, 1 ], 0, 'row-major' );

// Initialize a 2-dimensional k-means accumulator:
acc = incrkmeans( k, 2, {
	'metric': 'euclidean',
	'init': [ 'kmeans++', 100 ]
});

// Create PRNGs for generating pseudorandom numbers drawn from 2-d uncorrelated normal distributions...
ctor = ndarray( 'generic', 2 );
randn = ctor( new Array( k*2 ), [ k, 2 ], [ 2, 1 ], 0, 'row-major' );
for ( i = 0; i < k; i++ ) {
	randn.set( i, 0, normal( clusters.get( i, 0 ), clusters.get( i, 1 ) ) );
	randn.set( i, 1, normal( clusters.get( i, 2 ), clusters.get( i, 3 ) ) );
}

// Create a 2-d vector for storing simulated data:
ctor = ndarray( 'float64', 1 );
v = ctor( new Float64Array( 2 ), [ 2 ], [ 1 ], 0, 'row-major' );

// Simulate data points and incrementally perform k-means clustering...
for ( i = 0; i < N; i++ ) {
	// Pick a random cluster from which to sample:
	c = discreteUniform( 0, k-1 );

	// Generate a random cluster data point:
	x = randn.get( c, 0 )();
	y = randn.get( c, 1 )();
	v.set( 0, x );
	v.set( 1, y );

	console.log( 'cluster %d: (%d, %d)', c, x.toFixed( 3 ), y.toFixed( 3 ) );

	// Update the accumulator:
	acc( v );
}

// Print cluster results:
results = acc();

console.log( 'Centroids:' );
for ( i = 0; i < k; i++ ) {
	console.log( 'Centroid %d: (%d, %d)', i, results.centroids.get( i, 0 ), results.centroids.get( i, 1 ) );
	console.log( 'Centroid %d: %d data points', i, results.stats.get( i, 0 ) );
}
