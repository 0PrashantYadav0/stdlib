'use strict';

// MODULES //

var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var isArrayLike = require( '@stdlib/utils/is-array-like' );
var isString = require( '@stdlib/utils/is-string' ).isPrimitive;
var absdiff = require( '@stdlib/math/base/utils/absolute-difference' );
var floor = require( '@stdlib/math/base/special/floor' );
var randu = require( '@stdlib/math/base/random/randu' ).factory;
var EPS = require( '@stdlib/math/constants/float64-eps' );
var validate = require( './validate.js' );


// FACTORY //

/**
* Returns a function to sample elements from an array-like object.
*
* @param {PositiveInteger} seed - integer-valued seed
* @returns {Function} function to sample elements from an array-like object.
*
* @example
* var sample = factory( 323 );
*/
function factory( seed ) {
	var rand = randu({
		'seed': seed
	});

	/**
	* Sample elements from an array-like object.
	*
	* #### Method
	*
	* * When sampling with replacement and non-uniform probabilities, Vose's alias method is used.
	* * When sampling without replacement and uniform probabilities, a Fisher–Yates shuffle is used.
	*
	* #### Notes
	*
	* * Implementation of Vose's alias method is based on discussion at http://keithschwarz.com/darts-dice-coins/.
	*
	* #### References
	*
	* * Vose, M. D. (1991). A linear algorithm for generating random numbers with a given distribution. IEEE Transactions on Software Engineering, 17(9), 972–975. doi:10.1109/32.92917
	* * Knuth, D. E. (1973). The Art of Computer Programming: Seminumerical Algorithms. Reading MA. doi:10.2307/2283757
	*
	* @param {ArrayLike} x - array-like object to sample elements from
	* @param {Options} [options] - function options
	* @param {NonNegativeInteger} [options.size=x.length] - sample size
	* @param {NumberArray} [options.probs=[1/x.length,...,1/x.length]] - element probabilities
	* @param {boolean} [options.replace=true] - boolean indicating if to sample with replacement
	* @throws {TypeError} first argument must be array-like
	* @throws {TypeError} options argument must be an object
	* @throws {TypeError} must provide valid options
	* @throws {TypeError} `size` option must be smaller or equal to the length of `x` when `replace` is set to false
	* @throws {RangeError} elements in option `probs` must be probabilities and sum up to one
	* @returns {Array} new array with elements sampled from x
	*
	* @example
	* var sample = factory( 323 );
	* var out = sample( [ 3, null, NaN, 'abc', function(){} ] );
	* // returns [ 3, 'abc', null, 3, null ]
	*/
	function sample( x, options ) {
		var aliasArr;
		var probArr;
		var nElems;
		var large;
		var probs;
		var small;
		var xcopy;
		var opts;
		var psum;
		var size;
		var ret;
		var tmp;
		var pos;
		var sum;
		var err;
		var g;
		var i;
		var j;
		var k;
		var l;
		var u;

		if ( !isArrayLike( x ) ) {
			throw new TypeError( 'invalid input argument. First argument must be an array-like object. Value: `' + x + '`.' );
		}
		if ( isString( x ) ) {
			x = x.split( '' );
		}
		opts = {};
		if ( arguments.length > 1 ) {
			err = validate( opts, options );
			if ( err ) {
				throw err;
			}
		}
		if ( opts.size ) {
			if ( opts.replace === false && opts.size > x.length ) {
				throw new TypeError( 'invalid input option. `size` option must be smaller or equal to the length of `x` when `replace` option is set to false. Value: `' + opts.size + '`.' );
			}
			size = opts.size;
		} else {
			size = x.length;
		}
		nElems = x.length;
		small = [];
		large = [];
		if ( opts.probs ) {
			sum = 0;
			for ( i = 0; i < opts.probs.length; i++ ) {
				if ( opts.probs[ i ] < 0.0 || opts.probs[ i ] > 1.0 ) {
					throw new RangeError( 'invalid input option. The elements of `probs` must be probabilities.  Value: `' + opts.probs + '`.' );
				}
				sum += opts.probs[ i ];
			}
			if ( absdiff( sum, 1.0 ) > EPS ) {
				throw new RangeError( 'invalid input option. The elements of `probs` must sum up to one.  Value: `' + opts.probs + '`.' );
			}

			if ( opts.replace !== false ) {
				probs = [];
				for ( i = 0; i < nElems; i++ ) {
					probs[ i ] = opts.probs[ i ];
					probs[ i ] *= nElems;
					if ( probs[ i ] < 1 ) {
						small.push( i );
					} else {
						large.push( i );
					}
				}
				aliasArr = new Array( nElems );
				probArr = new Array( nElems );
				while ( small.length !== 0 && large.length !== 0 ) {
					l = small.shift();
					g = large.shift();
					probArr[ l ] = probs[ l ];
					aliasArr[ l ] = g;
					probs[ g ] = probs[ g ] + probs[ l ] - 1;
					if ( probs[ g ] < 1 ) {
						small.push( g );
					} else {
						large.push( g );
					}
				}
				while ( large.length !== 0 ) {
					g = large.shift();
					probArr[ g ] = 1;
				}
				while ( small.length !== 0 ) {
					l = small.shift();
					probArr[ l ] = 1;
				}
				ret = [];
				for ( i = 0; i < size; i++ ) {
					pos = floor( nElems * rand() );
					if ( rand() < probArr[ pos ] ) {
						ret[ i ] = x[ pos ];
					} else {
						ret[ i ] = x[ aliasArr[ pos ] ];
					}
				}
				return ret;
			} else {
				probs = [];
				for ( i = 0; i < nElems; i++ ) {
					probs[ i ] = opts.probs[ i ];
				}
				ret = [];
				for ( i = 0; i < size; i++ ) {
					u = rand();
					psum = 0;
					for ( j = 0; j < nElems; j++ ) {
						psum += probs[ j ];
						if ( u < psum ) {
							break;
						}
					}
					for ( k = 0; k < nElems; k++ ) {
						if ( k === j ) {
							continue;
						}
						probs[ k ] = probs[ k ] / ( 1 - probs[ j ] );
					}
					probs[ j ] = 0;
					ret.push( x[ j ] );
				}
				return ret;
			}
		}
		// CASE 2: No probabilities supplied, all elements equally likely
		if ( opts.replace !== false ) {
			ret = [];
			for ( i = 0; i < size; i++ ) {
				pos = floor( nElems * rand() );
				ret[ i ] = x[ pos ];
			}
		} else {
			xcopy = Array.prototype.slice.call( x );
			for ( j = nElems - 1; j > 0; j-- ) {
				u = rand();
				k = floor( j * u );
				tmp = xcopy[ j ];
				xcopy[ j ] = xcopy[ k ];
				xcopy[ k ] = tmp;
			}
			ret = Array.prototype.slice.call( xcopy, 0, size );
		}
		return ret;
	} // end FUNCTION sample()

	setReadOnly( sample, 'SEED', rand.SEED );
	return sample;
} // end FUNCTION factory()


// EXPORTS //

module.exports = factory;
