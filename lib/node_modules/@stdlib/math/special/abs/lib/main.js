/**
* @license Apache-2.0
*
* Copyright (c) 2020 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var isNumber = require( '@stdlib/assert/is-number' ).isPrimitive;
var isndarrayLike = require( '@stdlib/assert/is-ndarray-like' );
var isArrayLikeObject = require( '@stdlib/assert/is-array-like-object' );
var isSingleSegmentCompatible = require( '@stdlib/ndarray/base/assert/is-single-segment-compatible' );
var isFloat64Array = require( '@stdlib/assert/is-float64array' );
var isFloat32Array = require( '@stdlib/assert/is-float32array' );
var ndarray = require( '@stdlib/ndarray/ctor' );
var buffer = require( '@stdlib/ndarray/base/buffer' );
var shape2strides = require( '@stdlib/ndarray/base/shape2strides' );
var iterationOrder = require( '@stdlib/ndarray/base/iteration-order' );
var dtype = require( '@stdlib/ndarray/base/buffer-dtype' );
var base = require( '@stdlib/math/base/special/abs' );
var dabs = require( '@stdlib/math/strided/special/dabs' );
var sabs = require( '@stdlib/math/strided/special/sabs' );
var gabs = require( '@stdlib/math/strided/special/abs' );


// MAIN //

/**
* Computes the absolute value.
*
* @param {(ndarray|ArrayLikeObject|number)} x - input value
* @throws {TypeError} must provide either an ndarray, array-like object, or number
* @returns {(ndarray|number)} results
*
* @example
* var y = abs( -1.0 );
* // returns 1.0
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
*
* var x = new Float64Array( [ 1.0, -1.0, 0.0 ] );
*
* var y = abs( x );
* // returns <ndarray>
*
* var d = y.data;
* // returns <Float64Array>[ 1.0, 1.0, 0.0 ]
*
* @example
* var array = require( '@stdlib/ndarray/array' );
*
* var x = array( [ [ 1.0, -2.0 ], [ -3.0, 4.0 ] ] );
* // returns <ndarray>
*
* var y = abs( x );
* // returns <ndarray>
*
* var v = y.get( 0, 1 );
* // 2.0
*/
function abs( x ) {
	var strides;
	var offset;
	var order;
	var ndims;
	var shape;
	var data;
	var ctor;
	var buf;
	var xc;
	var dt;
	var N;
	var s;
	var y;
	var i;

	if ( isNumber( x ) ) {
		return base( x );
	}
	// TODO: add complex number support; should probably coincide with complex number array support

	if ( isndarrayLike( x ) ) {
		// Cache ndarray properties to avoid repeatedly calling ndarray accessors...
		N = x.length;
		ndims = x.ndims;
		shape = x.shape;
		strides = x.strides;
		offset = x.offset;
		order = x.order;
		data = x.data;
		dt = x.dtype;

		// Create an output ndarray...
		ctor = ndarray( dt, ndims );
		buf = buffer( dt, N );
		y = ctor( buf, shape, shape2strides( shape, order ), 0, order );

		// Determine whether we can use one-dimensional type-optimized implementations...
		if ( ndims === 1 ) {
			if ( dt === 'float64' ) {
				dabs.ndarray( N, data, strides[ 0 ], offset, buf, 1, 0 );
			} else if ( dt === 'float32' ) {
				sabs.ndarray( N, data, strides[ 0 ], offset, buf, 1, 0 );
			} else {
				gabs.ndarray( N, data, strides[ 0 ], offset, buf, 1, 0 );
			}
			return y;
		}
		// Determine whether we can ignore shape (and strides) and treat `x` as a linear array...
		s = iterationOrder( strides ); // +/-1
		if ( s !== 0 && isSingleSegmentCompatible( shape, strides, offset ) ) { // Note: equivalent to @stdlib/ndarray/base/assert/is-contiguous, but in-lined so we can retain iteration order
			if ( dt === 'float64' ) {
				dabs.ndarray( N, data, s, offset, buf, 1, 0 );
			} else if ( dt === 'float32' ) {
				sabs.ndarray( N, data, s, offset, buf, 1, 0 );
			} else {
				gabs.ndarray( N, data, s, offset, buf, 1, 0 );
			}
			return y;
		}
		// At this point, `x` is a non-contiguous n-dimensional array, so we cannot directly use lower-level strided array functionality...

		// TODO: consider cache oblivious iteration, rather than data copy...
		xc = buffer( dt, N );
		for ( i = 0; i < N; i++ ) {
			xc[ i ] = x.iget( i );
		}
		// The buffer copy is contiguous so we can now use lower-level strided array functionality...
		if ( dt === 'float64' ) {
			dabs( N, xc, 1, buf, 1 );
		} else if ( dt === 'float32' ) {
			sabs( N, xc, 1, buf, 1 );
		} else {
			gabs( N, xc, 1, buf, 1 );
		}
		return y;
	}
	if ( !isArrayLikeObject( x ) ) {
		throw new TypeError( 'invalid argument. Must provide either an ndarray, array-like object, or number. Value: `' + x + '`.' );
	}
	N = x.length;
	dt = dtype( x ) || 'generic';

	// Create an output array...
	ctor = ndarray( dt, 1 );
	buf = buffer( dt, N );
	y = ctor( buf, [ N ], [ 1 ], 0, 'row-major' );

	if ( isFloat64Array( x ) ) {
		dabs( x.length, x, 1, buf, 1 );
	} else if ( isFloat32Array( x ) ) {
		sabs( x.length, x, 1, buf, 1 );
	} else {
		gabs( x.length, x, 1, buf, 1 );
	}
	return y;
}


// EXPORTS //

module.exports = abs;
