'use strict';

// MODULES //

var path = require( 'path' );
var getKeys = require( 'object-keys' ).shim();
var resolve = require( 'resolve' ).sync;
var copy = require( '@stdlib/utils/copy' );
var hasOwnProp = require( '@stdlib/utils/has-own-property' );
var parentPath = require( '@stdlib/fs/resolve-parent-path' ).sync;
var dirname = require( '@stdlib/utils/dirname' );
var CONF = require( './CONF.json' );


// FUNCTIONS //

/**
* Returns an array of unique values.
*
* @private
* @param {Array} arr - input array
* @returns {Array} array with unique values
*/
function unique( arr ) {
	var obj;
	var i;
	obj = {};
	for ( i = 0; i < arr.length; i++ ) {
		obj[ arr[i] ] = true;
	}
	return getKeys( obj );
} // end FUNCTION unique()


// MAIN //

/**
* Returns a configuration.
*
* @private
* @param {Options} [options] - options
* @throws {Error} must provide options which match a configuration
* @returns {Object} configuration
*/
function main( options ) {
	var mpath;
	var ropts;
	var opts;
	var deps;
	var obj;
	var key;
	var tmp;
	var o;
	var i;
	var j;
	var k;

	// Handle input options...
	opts = copy( CONF.defaults );
	if ( arguments.length ) {
		for ( i = 0; i < CONF.options.length; i++ ) {
			key = CONF.options[ i ];
			if ( hasOwnProp( options, key ) ) {
				opts[ key ] = options[ key ];
			}
		}
	}
	// Resolve package configuration based on provided options...
	for ( i = 0; i < CONF.confs.length; i++ ) {
		o = CONF.confs[ i ];

		// Require that all options must match in order to match a configuration...
		for ( j = 0; j < CONF.options.length; j++ ) {
			key = CONF.options[ j ];
			if (
				!hasOwnProp( o, key ) ||
				o[ key ] !== opts[ key ]
			) {
				break;
			}
		}
		// If we exhausted all the options, then we found a match...
		if ( j === CONF.options.length ) {
			obj = copy( o );
			break;
		}
	}
	if ( obj === void 0 ) {
		throw new Error( 'invalid input argument. Unable to find matching configuration. Value: `'+JSON.stringify( opts )+'`.' );
	}
	// Resolve dependencies (WARNING: circular dependencies will cause an infinite loop)...
	deps = obj.dependencies;
	ropts = {
		'basedir': __dirname
	};
	for ( i = 0; i < deps.length; i++ ) {
		// Resolve a dependency's main entry point:
		mpath = resolve( deps[ i ], ropts );

		// Resolve a dependency's path by finding the dependency's `package.json`:
		mpath = dirname( parentPath( 'package.json' ) );

		// Load the dependency configuration:
		o = require( path.join( mpath, 'conf.js' ) )( opts );

		// Merge each field into the main configuration making sure to resolve absolute paths...
		for ( j = 0; j < CONF.fields.length; j++ ) {
			key = CONF.fields[ i ].field;
			if ( hasOwnProp( o, key ) ) {
				tmp = o[ key ];
				if ( CONF.fields[ i ].resolve ) {
					for ( k = 0; k < tmp.length; k++ ) {
						tmp[ k ] = path.resolve( mpath, tmp[ k ] );
					}
				}
				obj[ key ] = obj[ key ].concat( tmp );
			}
		}
	}
	// Dedupe values (dependencies may share common dependencies)...
	for ( i = 0; i < CONF.fields.length; i++ ) {
		key = CONF.fields[ i ].field;
		if ( hasOwnProp( obj, key ) ) {
			obj[ key ] = unique( obj[ key ] );
		}
	}
	return obj;
} // end FUNCTION main()


// EXPORTS //

module.exports = main;
