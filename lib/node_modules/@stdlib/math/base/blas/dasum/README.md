# dasum

> Compute the sum of [absolute values][absolute-value] ([*L1* norm][l1norm]).


<section class="intro">

The [*L1* norm][l1norm] is defined as

<!-- <equation class="equation" label="eq:l1norm" align="center" raw="\|\mathbf{x}\|_1 = \sum_{i=0}^{n-1} \vert x_i \vert" alt="L1 norm definition."> -->

<div class="equation" align="center" data-raw-text="\|\mathbf{x}\|_1 = \sum_{i=0}^{n-1} \vert x_i \vert" data-equation="eq:l1norm">
    <img src="" alt="L1 norm definition.">
    <br>
</div>

<!-- </equation> -->

</section>

<!-- /.intro -->


<section class="usage">

## Usage

``` javascript
var dasum = require( '@stdlib/math/base/blas/dasum' );
```

#### dasum( N, x, stride )

Computes the sum of [absolute values][absolute-value].

``` javascript
var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];

var sum = dasum( x.length, x, 1 );
// returns 19.0
```

The function accepts the following parameters:

* __N__: number of elements to sum.
* __x__: input [`array`][array] or [`typed array`][typed-array].
* __stride__: index increment.

The `N` and `stride` parameters determine which elements in `x` are used to compute the sum. For example, to sum every other value,

``` javascript
var floor = require( '@stdlib/math/base/special/floor' );

var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];

var N = floor( x.length / 2 );
var stride = 2;

var sum = dasum( N, x, stride );
// returns 10.0
```

Note that indexing is relative to the first index. To introduce an offset, use [`typed array`][typed-array] views.

``` javascript
var floor = require( '@stdlib/math/base/special/floor' );

// Initial array...
var x0 = new Float64Array( [ 1.0, -2.0, 3.0, -4.0, 5.0, -6.0 ] );

// Create an offset view...
var x1 = new Float64Array( x0.buffer, x0.BYTES_PER_ELEMENT*1 ); // start at 2nd element

var N = floor( x0.length / 2 );

// Sum every other value...
var sum = dasum( N, x1, 2 );
// returns 12.0
```

If either `N` or `stride` is less than `0`, the function returns `0`.


#### dasum.ndarray( N, x, stride, offset )

Computes the sum of [absolute values][absolute-value], with alternative indexing semantics.

``` javascript
var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];

var sum = dasum.ndarray( x.length, x, 1, 0 );
// returns 19.0
```

The function accepts the following additional parameters:

* __offset__: starting index.

While [`typed array`][typed-array] views mandate a view offset based on the underlying `buffer`, the `offsetX` parameter supports indexing semantics based on a starting index. For example, to sum the last three elements,

``` javascript
var x = [ 1.0, -2.0, 3.0, -4.0, 5.0, -6.0 ];

var sum = dasum.ndarray( 3, x, -1, x.length-1 );
// returns 15.0
```

</section>

<!-- /.usage -->


<section class="notes">

## Notes

* If `N <= 0`, both functions return `0`.
* `dasum()` corresponds to the [BLAS][blas] level 1 function [`dasum`][dasum].

</section>

<!-- /.notes -->


<section class="examples">

## Examples

``` javascript
var randu = require( '@stdlib/math/base/random/randu' );
var dasum = require( '@stdlib/math/base/blas/dasum' );

var rand;
var sign;
var x;
var i;

x = new Float64Array( 100 );
for ( i = 0; i < x.length; i++ ) {
    rand = round( randu()*100.0 );
    sign = randu();
    if ( sign < 0.5 ) {
        sign = -1.0;
    } else {
        sign = 1.0;
    }
    x[ i ] = sign * rand;
}
console.log( dasum( x.length, x, 1 ) );
```

</section>

<!-- /.examples -->


<section class="links">

[blas]: http://www.netlib.org/blas
[dasum]: http://www.netlib.org/lapack/explore-html/de/da4/group__double__blas__level1.html
[array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
[typed-array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray
[l1norm]: http://en.wikipedia.org/wiki/Norm_%28mathematics%29

<!-- FIXME: link -->

[absolute-value]: https://github.com/math-io/abs

</section>

<!-- /.links -->
