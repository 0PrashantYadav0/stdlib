'use strict';

// MODULES //

var isPositiveInteger = require( '@stdlib/utils/is-positive-integer' ).isPrimitive;
var INT32_MAX = require( '@stdlib/math/constants/int32-max' );
var randint32 = require( './rand_int32.js' );


// VARIABLES //

var MAX_SEED = INT32_MAX - 1;
var A = 16807|0; // asm type annotation


// FACTORY //

/**
* Returns a linear congruential pseudorandom number generator (LCG) based on Park and Miller.
*
* @param {PositiveInteger} [seed] - pseudorandom number generator seed
* @throws {TypeError} must provide a positive integer
* @throws {RangeError} must provide a positive integer less than the maximum signed 32-bit integer
* @returns {Function} LCG
*
* @example
* var minstd = factory();
*
* var v = minstd();
* // returns <number>
*
* @example
* // Return a seeded LCG:
* var minstd = factory( 1234 );
*
* var v = minstd();
* // returns 20739838
*/
function factory( seed ) {
	var state;
	if ( arguments.length ) {
		if ( !isPositiveInteger( seed ) ) {
			throw new TypeError( 'invalid input argument. Must provide a positive integer. Value: `' + seed + '`.' );
		}
		if ( seed > MAX_SEED ) {
			throw new RangeError( 'invalid input argument. Must provide a positive integer less than the maximum signed 32-bit integer. Value: `' + seed + '`.' );
		}
		state = seed|0; // asm type annotation
	} else {
		state = randint32();
	}

	/**
	* Generates a pseudorandom integer on the interval \\( [1,2^{31}-1) \\).
	*
	* #### Method
	*
	* Linear congruential generators (LCGs) use the recurrence relation
	*
	* ``` tex
	* X_{n+1} = ( a \cdot X_n + c ) \operatorname{mod}(m)
	* ```
	*
	* where the modulus \\( m \\) is a prime number or power of a prime number and \\( a \\) is a primitive root modulo \\( m \\).
	*
	* <!-- <note> -->
	* For an LCG to be a Lehmer RNG, the seed \\( X_0 \\) must be coprime to \\( m \\).
	* <!-- </note> -->
	*
	* In this implementation, the constants \\( a \\), \\( c \\), and \\( m \\) have the values
	*
	* ``` tex
	* \begin{align*}
	* a &= 7^5 = 16807 \\
	* c &= 0 \\
	* m &= 2^{31} - 1 = 2147483647
	* \end{align*}
	* ```
	*
	* <!-- <note> -->
	* The constant \\( m \\) is a Mersenne prime (modulo \\(31\\)).
	* <!-- </note> -->
	*
	* <!-- <note> -->
	* The constant \\( a \\) is a primitive root (modulo \\(31\\)).
	* <!-- </note> -->
	*
	* Accordingly, the maximum possible product is
	*
	* ``` tex
	* 16807 \cdot (m - 1) \approx 2^{46}
	* ```
	*
	* The values for \\( a \\), \\( c \\), and \\( m \\) are taken from Park and Miller, "Random Number Generators: Good Ones Are Hard To Find". Park's and Miller's article is also the basis for a recipe in the second edition of *Numerical Recipes in C*.
	*
	*
	* #### Notes
	*
	* * The generator has a period of approximately \\(2.1\mbox{e}9\\) (see [Numerical Recipes in C, 2nd Edition](#references), p. 279).
	*
	*
	* #### References
	*
	* * S.K. Park and K.W. Miller (1988). "Random Number Generators: Good Ones Are Hard To Find". Communications of the ACM 31 (10): 1192-1201.
	* * William H. Press, et. al., _Numerical Recipes in C: The Art of Scientific Computing_, Section 7.1 "Uniform Deviates" (2nd ed. 1992).
	*
	*
	* @returns {PositiveInteger} pseudorandom integer
	*
	* @example
	* var v = minstd();
	* // returns <number>
	*/
	return function minstd() {
		state = ( A * state ) % INT32_MAX;
		return state|0; // asm type annotation
	};
} // end FUNCTION factory()


// EXPORTS //

module.exports = factory;
