'use strict';

// MODULES //

var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var factorialln = require( '@stdlib/math/base/special/factorialln' );
var isPositive = require( '@stdlib/utils/is-positive-number' ).isPrimitive;
var isObject = require( '@stdlib/utils/is-object' );
var randu = require( '@stdlib/math/base/random/randu' ).factory;
var floor = require( '@stdlib/math/base/special/floor' );
var sign = require( '@stdlib/math/base/special/signum' );
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var abs = require( '@stdlib/math/base/special/abs' );
var exp = require( '@stdlib/math/base/special/exp' );
var ln = require( '@stdlib/math/base/special/ln' );
var LN_SQRT_TWO_PI = require( '@stdlib/math/constants/float64-ln-sqrt-two-pi' );


// FACTORY //

/**
* Returns a pseudorandom number generator for generating Poisson distributed random numbers.
*
* #### Method
* * When lambda < 30, use Knuth's method.
* * When lambda >= 30, use transformed rejection method as Knuth's method does not scale well with lambda.
*
* #### References
* * Donald E. Knuth (1969). Seminumerical Algorithms. The Art of Computer Programming, Volume 2. Addison Wesley.
* * HÃ¶rmann, W. (1993). The transformed rejection method for generating Poisson random variables. Insurance: Mathematics and Economics.
*
* @param {PositiveNumber} [lambda] - mean parameter
* @param {Options} [opts] - function options
* @param {*} [opts.seed] - pseudorandom number generator seed
* @throws {TypeError} lambda must be a positive number
* @throws {TypeError} options must be an object
* @returns {Function} pseudorandom number generator
*
* @example
* var rpois = factory( 5.0 );
* var v = rpois();
* // returns <number>
*
* @example
* var rpois = factory( 8.0, {
* 	'seed': 297
* });
* var v = rpois();
* // returns <number>
*
* @example
* var rpois = factory()
* var v = rpois( 0.5 );
* // returns <number>
*/
function factory() {
	var lambda;
	var nargs;
	var args;
	var opts;
	var rand;
	var ret;

	args = arguments;
	nargs = args.length;
	if ( nargs === 0 ) {
		rand = randu();
	}
	else {
		if ( isObject( args[ 0 ] ) ) {
			opts = args[ 0 ];
			rand = randu( opts );
		} else {
			lambda = args[ 0 ];
			if ( !isPositive( lambda ) ) {
				throw new TypeError( 'invalid input argument. First argument `lambda` must be a positive number. Value: `' + lambda + '`.' );
			}
			if ( nargs > 1 ) {
				opts = args[ 1 ];
				if ( !isObject( opts ) ) {
					throw new TypeError( 'invalid input argument. If supplied, second argument must be an options object. Value: `' + opts + '`.' );
				}
				rand = randu( opts );
			} else {
				rand = randu();
			}
		}
	}

	if ( lambda !== void 0 ) {
		ret = rpois1;
	}
	else {
		ret = rpois2;
	}
	setReadOnly( ret, 'NAME', 'poisson' );
	setReadOnly( ret, 'SEED', rand.SEED );
	setReadOnly( ret, 'PRNG', rand.PRNG );
	return ret;

	/**
	* Returns Poisson random variates with bound parameter `lambda`.
	*
	* @private
	* @returns {number} pseudorandom number
	*/
	function rpois1() {
		return sampler( lambda );
	} // end FUNCTION rpois1()

	/**
	* Performs type-checking and then calls sampler function to generate random number.
	*
	* @private
	* @param {PositiveNumber} lambda - mean parameter
	* @throws {TypeError} must provide a positive number
	* @returns {number} pseudorandom number
	*/
	function rpois2( lambda ) {
		if ( !isPositive( lambda ) ) {
			throw new TypeError( 'invalid input argument. First argument `lambda` must be a positive number. Value: `' + lambda + '`.' );
		}
		return sampler( lambda );
	} // end FUNCTION rpois2()

	/**
	* Returns a random number drawn from a Poisson distribution with parameter `lambda`.
	*
	* @private
	* @param {PositiveNumber} lambda - mean parameter
	* @returns {number} pseudorandom number
	*/
	function sampler( lambda ) {
		var slambda;
		var ainv;
		var us;
		var vr;
		var l;
		var p;
		var k;
		var b;
		var a;
		var u;
		var v;

		slambda = sqrt( lambda );
		b = 0.931 + 2.54 * slambda;
		a = -0.059 + 0.02483 * b;
		ainv = 1.1239 + 1.1328 / ( b - 3.4 );
		vr = 0.9277 - 3.6224 / ( b - 2.0 );
		if ( lambda < 30.0 ) {
			l = exp( -lambda );
			k = 0;
			p = 1.0;
			do {
				k += 1;
				u = rand();
				p *= u;
			} while ( p > l );
			return k - 1;
		}
		return (function exec() {
			v = rand();
			if ( v <= 0.86 * vr ) {
				u = v / vr - 0.43;
				return floor( ( 2.0*a / (0.5-abs(u) ) + b ) * u + lambda + 0.445 );
			}
			if ( v >= vr ) {
				u = rand() - 0.5;
			} else {
				u = v / vr - 0.93;
				u = sign( u ) * 0.5 - u;
				v = vr * rand();
			}
			us = 0.5 - abs( u );
			if ( us < 0.013 && v > us ) {
				return exec();
			}
			k = floor( ( 2.0*a/us + b ) * u + lambda + 0.445 );
			v = v * ainv  / ( a/(us*us) + b );
			if (
				k >= 10 &&
				ln( v * slambda ) <= (k+0.5) * ln(lambda/k) -
					lambda - LN_SQRT_TWO_PI  + k - (1/12-1/(360*k*k))/k
			) {
				return k;
			}
			if (
				0 <= k &&
				k <= 9 &&
				ln( v ) <= k * ln( lambda ) - lambda - factorialln( k )
			) {
				return k;
			} else {
				return exec();
			}
		})();
	} // end FUNCTION sampler()

} // end FUNCTION factory()


// EXPORTS //

module.exports = factory;
