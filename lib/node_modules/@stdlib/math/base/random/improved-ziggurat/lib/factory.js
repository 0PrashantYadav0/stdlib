'use strict';

// MODULES //

var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var isFunction = require( '@stdlib/utils/is-function' );
var isObject = require( '@stdlib/utils/is-object' ); // TODO: plain object
var randu = require( '@stdlib/math/base/random/randu' ).factory;
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var abs = require( '@stdlib/math/base/special/abs' );
var exp = require( '@stdlib/math/base/special/exp' );
var pow = require( '@stdlib/math/base/special/pow' );
var ln = require( '@stdlib/math/base/special/ln' );
var dRanNormalTail = require( './d_ran_normal_tail.js' );


// CONSTANTS //

var TWO_P_32 = pow( 2, 32);
var ZIGNOR_C = 128; // Number of blocks...
var ZIGNOR_R = 3.442619855899; // Start of the right tail...
// (R * phi(R) + Pr(X>=R)) * sqrt(2\pi)
var ZIGNOR_V = 9.91256303526217e-3;


// VARIABLES //

// s_adZigX holds coordinates, such that each rectangle has same area:
var s_adZigX = new Array( ZIGNOR_C + 1 );
// s_adZigR holds s_adZigX[i + 1] / s_adZigX[i]:
var s_adZigR = new Array( ZIGNOR_C );


// FACTORY //

/**
* Returns a pseudorandom number generator which implements the improved Ziggurat method to generate normally distributed pseudorandom numbers.
*
* @param {Options} options - function options
* @param {Function} [options.prng] - pseudorandom number generator which generates uniformly distributed pseudorandom numbers
* @param {*} [options.seed] - pseudorandom number generator seed
* @throws {TypeError} must provide an object
* @throws {TypeError} must provide valid options
* @returns {Function} pseudorandom number generator
*
* @example
* var randn = factory();
*
* var r = randn();
* // returns <number>
*
* @example
* // Return a seeded PRNG:
* var randn = factory({
*     'seed': 12345
* });
*
* var r = randn();
* // returns <number>
*/
function factory( options ) {
	var rand;
	var seed;
	if ( arguments.length ) {
		if ( !isObject( options ) ) {
			throw new TypeError( 'invalid input argument. Must provide an object. Value: `' + options + '`.' );
		}
		if ( options.hasOwnProperty( 'prng' ) ) {
			if ( !isFunction( options.prng ) ) {
				throw new TypeError( 'invalid option. `prng` option must be a pseudorandom number generator function. Option: `' + options.prng + '`.' );
			}
			// TODO: should we verify a provided `prng` conforms to internal PRNG api? e.g., has `MAX`, `MIN`, `SEED` properties?
			rand = options.prng;
		}
		if ( options.hasOwnProperty( 'seed' ) ) {
			seed = options.seed;
		}
	}
	if ( rand === void 0 ) {
		if ( seed === void 0 ) {
			rand = randu();
		} else {
			rand = randu({
				'seed': seed
			});
		}
	}

	/**
	* Generates a normally distributed pseudorandom number.
	*
	* #### Method
	* The basic Ziggurat method works as follows:
	*
	* * One partitions the standard normal density into C blocks of equal area. This partitioning is found by solving the following non-linear equation:
	*
	*   ``` tex
	*   x_{C-1}(r) \left[ f(0) - f\left( x_{C-1}(r) \right) \right] - V(r) = 0,
	*   ```
	*
	*   where \\( V(r) = r \; f(r) + \int_r^\infty \; f(x) \; dx \\) and \\( r \\) denotes the right-most \\( x_1 \\).
	*
	* * We then use the following rejection algorithm:
	*
	*   - Draw a box at random with probability \\( \tfrac{1}{C} \\), say \\( B_i \\)
	*   - Draw a random number from the box as \\( z = U_0 x_i \\) for \\( i > 0 \\) and \\( z = U_0 V / f(x_1) \\)
	*   - If \\( z < x_{i+1} \\), accept \\( z \\).
	*   - If \\( i = 0 \\), accept a \\( v \\) by transforming the tail of the normal distribution to the unit interval and then use rejection technique by Marsaglia, G. (1964) to generate standard normal variable. Else, if \\( i > 0 \\) and \\( U_1 \left[ f(x_i) - f(x_{i+1})\right] < f(z) - f(x_{i+1}) \\) accept \\( z \\)
	*   - Go back to the first step.
	*
	* The improved version by Doornik (2005) changes step four in order to correct a deficiency of the original Ziggurat algorithm. The updated version requires the generation of two random numbers, a uniform variable drawn from \\( U(-1,1) \\) and the last seven bits of a random integer.
	*
	* #### References
	*
	* * Doornik, J. a. (2005). An Improved Ziggurat Method to Generate Normal Random Samples.
	* * Marsaglia, G., & Tsang, W. W. (2000). The Ziggurat method for generating random variables. Journal of Statistical Software, 5, 1â€“7. doi:10.1145/355744.355749
	*
	*
	* @returns {number} pseudorandom number
	*
	* @example
	* var r = randn();
	* // returns <number>
	*/
	function randn() {
		var i;
		var f;

		f = exp( -0.5 * ZIGNOR_R * ZIGNOR_R );
		s_adZigX[ 0 ] = ZIGNOR_V / f; // [0] is bottom block: V / f(R)
		s_adZigX[ 1 ] = ZIGNOR_R;
		s_adZigX[ ZIGNOR_C ] = 0;
		for ( i = 2; i < ZIGNOR_C; i++ ) {
			s_adZigX[i] = sqrt( -2 * ln( ZIGNOR_V / s_adZigX[i - 1] + f ) );
			f = exp( -0.5 * s_adZigX[i] * s_adZigX[i] );
		}
		for ( i = 0; i < ZIGNOR_C; i++ ) {
			s_adZigR[ i ] = s_adZigX[ i+1 ] / s_adZigX[ i ];
		}
		var x, u, f0, f1;
		for (;;) {
			u = 2 * rand() - 1;
			i = TWO_P_32 * rand() & 0x7F;
			// First try the rectangular boxes...
			if ( abs( u ) < s_adZigR[ i ] ) {
				return u * s_adZigX[ i ];
			}
			// Bottom box: sample from the tail...
			if ( i === 0 ) {
				return dRanNormalTail( ZIGNOR_R, u < 0, rand );
			}
			// Is this a sample from the wedges?
			x = u * s_adZigX[ i ];
			f0 = exp( -0.5 * ( s_adZigX[i] * s_adZigX[i] - x * x ) );
			f1 = exp( -0.5 * ( s_adZigX[i+1] * s_adZigX[i+1] - x * x ) );
			if ( f1 + rand() * (f0 - f1) < 1.0 ) {
				return x;
			}
		}
	} // end FUNCTION randn()

	setReadOnly( randn, 'NAME', 'improved-ziggurat' );
	setReadOnly( randn, 'SEED', rand.SEED );
	// FIXME: Figure out correct minimum and maximum values.
	setReadOnly( randn, 'MIN', NaN );
	setReadOnly( randn, 'MAX', NaN );

	return randn;
} // end FUNCTION factory()


// EXPORTS //

module.exports = factory;
