'use strict';

// MODULES //

var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var isFunction = require( '@stdlib/utils/is-function' );
var isObject = require( '@stdlib/utils/is-plain-object' );
var hasOwnProp = require( '@stdlib/utils/has-own-property' );
var randu = require( '@stdlib/math/base/random/randu' ).factory;
var randint = require( '@stdlib/math/base/random/minstd-shuffle' ).factory;
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var abs = require( '@stdlib/math/base/special/abs' );
var exp = require( '@stdlib/math/base/special/exp' );
var ln = require( '@stdlib/math/base/special/ln' );
var sampleTail = require( './sample_tail.js' );


// VARIABLES //

// Number of blocks:
var NUM_BLOCKS = 128;

// Start of right tail (R):
var START_RIGHT_TAIL = 3.442619855899;

// (R*phi(R) + Pr(X>=R))*sqrt(2\pi)
var V = 9.91256303526217e-3;

// `X` holds coordinates, such that each rectangle has same area:
var X = new Array( NUM_BLOCKS + 1 );

// `R` holds `X[ i+1 ] / X[ i ]`:
var R = new Array( NUM_BLOCKS );

// 127 => 0x7F => 01111111
var LAST_7_BITS_MASK = 127|0; // asm type annotation


// MAIN //

/**
* Returns a pseudorandom number generator which implements the improved Ziggurat method to generate normally distributed pseudorandom numbers.
*
* @param {Options} options - function options
* @param {Function} [options.prng] - pseudorandom number generator which generates uniformly distributed pseudorandom numbers
* @param {*} [options.seed] - pseudorandom number generator seed
* @throws {TypeError} must provide an object
* @throws {TypeError} must provide valid options
* @returns {Function} pseudorandom number generator
*
* @example
* var randn = factory();
*
* var r = randn();
* // returns <number>
*
* @example
* // Return a seeded PRNG:
* var randn = factory({
*     'seed': 12345
* });
*
* var r = randn();
* // returns <number>
*/
function factory( options ) {
	var randi;
	var rand;
	var seed;
	if ( arguments.length ) {
		if ( !isObject( options ) ) {
			throw new TypeError( 'invalid input argument. Must provide an object. Value: `' + options + '`.' );
		}
		if ( hasOwnProp( options, 'prng' ) ) {
			if ( !isFunction( options.prng ) ) {
				throw new TypeError( 'invalid option. `prng` option must be a pseudorandom number generator function. Option: `' + options.prng + '`.' );
			}
			rand = options.prng;
		}
		if ( hasOwnProp( options, 'seed' ) ) {
			seed = options.seed;
		}
	}
	if ( rand === void 0 ) {
		if ( seed === void 0 ) {
			rand = randu();
		} else {
			rand = randu({
				'seed': seed
			});
		}
	}
	if ( hasOwnProp( rand, 'SEED' ) ) {
		randi = randint( rand.SEED );
	} else {
		randi = randint();
	}

	/**
	* Generates a normally distributed pseudorandom number.
	*
	* #### Method
	*
	* The basic Ziggurat method works as follows:
	*
	* * One partitions the standard normal density into \\( C \\) blocks of equal area. This partitioning is found by solving the following non-linear equation:
	*
	*   ``` tex
	*   x_{C-1}(r) \left[ f(0) - f\left( x_{C-1}(r) \right) \right] - V(r) = 0
	*   ```
	*
	*   where
	*
	*   ``` tex
	*   V(r) = r \; f(r) + \int_r^\infty \; f(x) \; dx
	*   ```
	*
	*   and \\( r \\) denotes the right-most \\( x_1 \\).
	*
	* * We then use the following rejection algorithm:
	*
	*   - Draw a box \\( B_i \\) at random with probability \\( \tfrac{1}{C} \\).
	*   - Draw a random number from the box as \\( z = U_0 x_i \\) for \\( i > 0 \\) and \\( z = U_0 V / f(x_1) \\).
	*   - If \\( z < x_{i+1} \\), accept \\( z \\).
	*   - If \\( i = 0 \\), accept a \\( v \\) by transforming the tail of the normal distribution to the unit interval and then use rejection technique by Marsaglia, G. (1964) to generate a standard normal variable. Otherwise, if \\( i > 0 \\) and \\( U_1 \left[ f(x_i) - f(x_{i+1})\right] < f(z) - f(x_{i+1}) \\) accept \\( z \\).
	*   - Go back to the first step.
	*
	*  * The improved version by Doornik (2005) changes step four in order to correct a deficiency of the original Ziggurat algorithm. The updated version requires the generation of two random numbers, a uniform variable drawn from \\( U(-1,1) \\) and the last seven bits of a random integer.
	*
	* #### References
	*
	* * Doornik, J. a. (2005). An Improved Ziggurat Method to Generate Normal Random Samples.
	* * Marsaglia, G., & Tsang, W. W. (2000). The Ziggurat method for generating random variables. Journal of Statistical Software, 5, 1–7. doi:10.1145/355744.355749
	* * Marsaglia, G. (1964). Generating a Variable from the Tail of the Normal Distribution. Technometrics, 6(1), 101–102. doi:10.1080/00401706.1964.10490150
	*
	*
	* @returns {number} pseudorandom number
	*
	* @example
	* var r = randn();
	* // returns <number>
	*/
	function randn() {
		var f0;
		var f1;
		var f;
		var x;
		var u;
		var i;

		f = exp( -0.5 * START_RIGHT_TAIL * START_RIGHT_TAIL );
		X[ 0 ] = V / f; // [0] is bottom block: V / f(R)
		X[ 1 ] = START_RIGHT_TAIL;
		X[ NUM_BLOCKS ] = 0.0;
		for ( i = 2; i < NUM_BLOCKS; i++ ) {
			X[ i ] = sqrt( -2.0 * ln( V / X[i-1] + f ) );
			f = exp( -0.5 * X[ i ] * X[ i ] );
		}
		for ( i = 0; i < NUM_BLOCKS; i++ ) {
			R[ i ] = X[ i+1 ] / X[ i ];
		}
		while ( true ) {
			u = 2.0 * rand() - 1.0;
			i = randi() & LAST_7_BITS_MASK;

			// First try the rectangular boxes...
			if ( abs( u ) < R[ i ] ) {
				return u * X[ i ];
			}
			// If bottom box, sample from the tail...
			if ( i === 0 ) {
				return sampleTail( rand, START_RIGHT_TAIL, u < 0.0 );
			}
			// Is this a sample from the wedges?
			x = u * X[ i ];
			f0 = exp( -0.5 * ( X[ i ]*X[ i ] - x*x ) );
			f1 = exp( -0.5 * ( X[ i+1 ]*X[ i+1 ] - x*x ) );
			if ( f1 + rand()*(f0-f1) < 1.0 ) {
				return x;
			}
		}
	} // end FUNCTION randn()

	setReadOnly( randn, 'NAME', 'improved-ziggurat' );
	setReadOnly( randn, 'PRNG', rand );

	if ( hasOwnProp( rand, 'SEED' ) ) {
		seed = rand.SEED;
	} else {
		seed = null;
	}
	setReadOnly( randn, 'SEED', seed );

	return randn;
} // end FUNCTION factory()


// EXPORTS //

module.exports = factory;
