'use strict';

// MODULES //

var isPositiveInteger = require( '@stdlib/utils/is-positive-integer' ).isPrimitive;
var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var isNumber = require( '@stdlib/utils/is-number' ).isPrimitive;
var isObject = require( '@stdlib/utils/is-plain-object' );
var isnan = require( '@stdlib/utils/is-nan' );
var randu = require( '@stdlib/math/base/random/randu' ).factory;
var floor = require( '@stdlib/math/base/special/floor' );
var sign = require( '@stdlib/math/base/special/signum' );
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var abs = require( '@stdlib/math/base/special/abs' );
var ln = require( '@stdlib/math/base/special/ln' );
var fc = require( './fc.js' );


// FACTORY //

/**
* Returns a pseudorandom number generator for generating binomial distributed random numbers.
*
* @param {PositiveInteger} [n] - number of trials
* @param {Probability} [p] - success probability
* @param {Options} [opts] - function options
* @param {*} [opts.seed] - pseudorandom number generator seed
* @throws {TypeError} n argument must be a positive integer
* @throws {TypeError} p argument must be numeric
* @throws {RangeError} p argument must be a number between 0 and 1
* @throws {TypeError} options must be an object
* @returns {Function} pseudorandom number generator
*
* @example
* var binomial = factory( 17, 0.5 );
* var v = binomial();
* // returns <number>
*
* @example
* var binomial = factory( 8, 0.8, {
* 	'seed': 297
* });
* var v = binomial();
* // returns <number>
*
* @example
* var binomial = factory()
* var v = binomial( 20, 0.5 );
* // returns <number>
*/
function factory() {
	var nargs;
	var args;
	var opts;
	var rand;
	var ret;
	var n;
	var p;

	args = arguments;
	nargs = args.length;
	if ( nargs === 0 ) {
		rand = randu();
	}
	else {
		if ( isObject( args[ 0 ] ) ) {
			opts = args[ 0 ];
			rand = randu( opts );
		} else {
			n = args[ 0 ];
			p = args[ 1 ];
			if ( !isPositiveInteger( n ) ) {
				throw new TypeError( 'invalid input argument. First argument `n` must be a positive integer. Value: `' + p + '`.' );
			}
			if ( !isNumber( p ) || isnan( p ) ) {
				throw new TypeError( 'invalid input argument. Second argument `p` must be a number primitive. Value: `' + p + '`.' );
			}
			if ( p < 0.0 || p > 1.0 ) {
				throw new RangeError( 'invalid input argument. Second argument `p` must be a probability. Value: `' + p + '`.' );
			}
			if ( nargs > 2 ) {
				opts = args[ 2 ];
				if ( !isObject( opts ) ) {
					throw new TypeError( 'invalid input argument. If supplied, third argument must be an options object. Value: `' + opts + '`.' );
				}
				rand = randu( opts );
			} else {
				rand = randu();
			}
		}
	}

	if ( n !== void 0 ) {
		ret = binomial1;
	}
	else {
		ret = binomial2;
	}
	setReadOnly( ret, 'NAME', 'binomial' );
	setReadOnly( ret, 'SEED', rand.SEED );
	setReadOnly( ret, 'PRNG', rand.PRNG );
	return ret;

	/**
	* Returns a random number drawn from a binomial distribution with bound parameter values.
	*
	* @private
	* @returns {NonNegativeInteger} pseudorandom number
	*
	* @example
	* var r = binomial();
	* // returns <NonNegativeInteger>
	*/
	function binomial1() {
		return sampler( n, p );
	} // end FUNCTION binomial1()

	/**
	* Performs type-checking and then calls sampler function to generate beta random number.
	*
	* @private
	* @param {PositiveInteger} n - number of trials
	* @param {Probability} p - success probability
	* @throws {TypeError} n argument must be a positive integer
	* @throws {TypeError} p argument must be numeric
	* @throws {RangeError} p argument must be a number between 0 and 1
	* @returns {NonNegativeInteger} pseudorandom number
	*
	* @example
	* var r = binomial( 20, 0.8 );
	* // returns <NonNegativeInteger>
	*/
	function binomial2( n, p ) {
		if ( !isPositiveInteger( n ) ) {
			throw new TypeError( 'invalid input argument. First argument `n` must be a positive integer. Value: `' + p + '`.' );
		}
		if ( !isNumber( p ) || isnan( p ) ) {
			throw new TypeError( 'invalid input argument. Second argument `p` must be a number primitive. Value: `' + p + '`.' );
		}
		if ( p < 0.0 || p > 1.0 ) {
			throw new RangeError( 'invalid input argument. Second argument `p` must be a probability. Value: `' + p + '`.' );
		}
		return sampler( n, p );
	} // end FUNCTION binomial2()

	/**
	* Returns a random number drawn from a binomial distribution with parameters `n` and `p`.
	*
	* #### Method
	* * For `n * p < 10`, the function simulates Bernoulli draws and returns their sum.
	* * Otherwise, the BTRD algorithm by W. Hörmann is used.
	*
	* #### References
	* * Hörmann, W. (1993). The generation of binomial random variates. Journal of Statistical Computation and Simulation. doi:10.1080/00949659308811496
	*
	* @private
	* @param {PositiveInteger} n - number of trials
	* @param {Probability} p - success probability
	* @returns {NonNegativeInteger} pseudorandom number
	*
	* @example
	* var r = sampler( 20, 0.8 );
	* // returns <NonNegativeInteger>
	*/
	function sampler( n, p ) {
		var alpha;
		var goto;
		var urvr;
		var npq;
		var ret;
		var rho;
		var nm;
		var nr;
		var us;
		var km;
		var nk;
		var vr;
		var f;
		var a;
		var k;
		var c;
		var i;
		var h;
		var b;
		var m;
		var r;
		var t;
		var u;
		var v;

		if ( p > 0.5 ) {
			return n - sampler( n, 1.0 - p );
		}
		if ( n * p < 10.0 ) {
			// Just simulate Bernoulli random variables...
			ret = 0;
			for ( i = 0; i < n; i++ ) {
				if ( rand() <= p ) {
					ret++;
				}
			}
			return ret;
		}
		m = floor( ( n + 1 ) * p );
		r = p / ( 1 - p );
		nr = ( n + 1 ) * r;
		npq = n * p * ( 1 - p);
		b = 1.15 + 2.53 * sqrt( npq );
		a = -0.0873 + 0.0248 * b + 0.01 * p;
		c = n * p + 0.5;
		alpha = ( 2.83 + 5.1/b ) * sqrt( npq );
		vr = 0.92 - 4.2/b;
		urvr = 0.86 * vr;
		nm = n - m + 1;
		h = (m+0.5) * ln( (m+1)/(r*nm) ) + fc( m ) + fc( n - m );
		goto = 1;
		while ( true ) {
			switch ( goto ) {
			case 1:
				v = rand();
				if ( v <= urvr ) {
					u = v/vr - 0.43;
					return floor( ( 2*a / ( 0.5 - abs(u) ) + b ) * u + c );
				}
				goto = 2;
			break;
			case 2:
				if ( v >= vr ) {
					u = rand() - 0.5;
				} else {
					u = v/vr - 0.93;
					u = sign( u ) * 0.5 - u;
					v = vr * rand();
				}
				goto = 3;
			break;
			case 3:
				us = 0.5 - abs(u);
				k = floor( ( 2 * a/us + b ) * u + c );
				if ( k < 0 || k > n ) {
					goto = 1;
					break;
				}
				v = v * alpha / ( a/(us*us) + b );
				km = abs( k - m );
				if ( km > 15 ) {
					goto = 5;
					break;
				}
				goto = 4;
			break;
			case 4:
				f = 1;
				if ( m < k ) {
					for ( i = m; i <= k; i++ ) {
						f *= nr/i - r;
					}
				}
				if ( m > k ) {
					for ( i = k; i <= m; i++ ) {
						v *= nr/i - r;
					}
				}
				if ( v <= f ) {
					return k;
				} else {
					goto = 1;
				}
			break;
			case 5:
				v = ln( v );
				rho = ( km / npq ) * ( ( ( km/3 + 0.625 ) * km + 1/6 ) / npq + 0.5 );
				t = -( km * km ) / ( 2 * npq );
				if ( v < t - rho ) {
					return k;
				}
				if ( v > t + rho ) {
					goto = 1;
					break;
				}
				goto = 6;
			break;
			case 6:
				nk = n - k + 1;
				if ( v <= h + (n+1) * ln( nm/nk ) + (k+0.5) * ln( nk*r/(k+1) ) - fc( k ) - fc( n - k ) ) {
					return k;
				} else {
					goto = 1;
				}
			break;
			}
		}
	} // end FUNCTION sampler()

} // end FUNCTION factory()


// EXPORTS //

module.exports = factory;
