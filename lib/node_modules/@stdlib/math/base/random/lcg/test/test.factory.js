'use strict';

// MODULES //

var tape = require( 'tape' );
var INT32_MAX = require( '@stdlib/math/constants/int32-max' );
var round = require( '@stdlib/math/base/special/round' );
var factory = require( './../lib/factory.js' );


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.equal( typeof factory, 'function', 'main export is a function' );
	t.end();
});

tape( 'if provided a value which is not a positive integer, the factory function throws an error', function test( t ) {
	var values;
	var i;

	values = [
		'5',
		3.14,
		0.0,
		-5.0,
		NaN,
		true,
		null,
		undefined,
		[],
		{},
		function(){}
	];

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), TypeError, 'throws a type error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			factory( value );
		};
	}
});

tape( 'the function throws a range error if provided an integer greater than or equal to the maximum signed 32-bit integer', function test( t ) {
	var values;
	var i;

	values = [
		INT32_MAX,
		INT32_MAX + 1,
		INT32_MAX + 2
	];

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[i] ), RangeError, 'throws a range error when provided '+values[i] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			factory( value );
		};
	}
});

tape( 'the function returns a pseudorandom number generator (no seed)', function test( t ) {
	var lcg;
	var v;
	var i;

	lcg = factory();
	for ( i = 0; i < 1e4; i++ ) {
		v = lcg();
		t.equal( typeof v, 'number', 'returns a number' );
		t.equal( v > 0.0 && v < 1.0, true, 'returns a number between 0 and 1' );
	}
	t.end();
});

tape( 'the function returns a seeded pseudorandom number generator', function test( t ) {
	var seed;
	var lcg1;
	var lcg2;
	var v1;
	var v2;
	var i;

	seed = round( Date.now() / 1000 );

	lcg1 = factory( seed );
	lcg2 = factory( seed );

	t.notEqual( lcg1, lcg2, 'separate generators' );

	for ( i = 0; i < 1e3; i++ ) {
		v1 = lcg1();
		v2 = lcg2();
		t.equal( v1, v2, 'both return same number' );
	}
	t.end();
});
