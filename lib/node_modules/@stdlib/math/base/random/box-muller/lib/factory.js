'use strict';

// MODULES //

var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var isObject = require( '@stdlib/utils/is-plain-object' );
var isFunction = require( '@stdlib/utils/is-function' );
var hasOwnProp = require( '@stdlib/utils/has-own-property' );
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var ln = require( '@stdlib/math/base/special/ln' );
var sin = require( '@stdlib/math/base/special/sin' );
var cos = require( '@stdlib/math/base/special/cos' );
var TWO_PI = require( '@stdlib/math/constants/float64-two-pi' );
var randu = require( '@stdlib/math/base/random/randu' ).factory;
var getMin = require( './min.js' );
var getMax = require( './max.js' );


// MAIN //

/**
* Returns a pseudorandom number generator which implements the Box-Muller transform to generate standard normally distributed pseudorandom numbers.
*
* @param {Options} options - function options
* @param {Function} [options.prng] - pseudorandom number generator which generates uniformly distributed pseudorandom numbers
* @param {*} [options.seed] - pseudorandom number generator seed
* @throws {TypeError} must provide an object
* @throws {TypeError} must provide valid options
* @returns {Function} pseudorandom number generator
*
* @example
* var randn = factory();
*
* var r = randn();
* // returns <number>
*
* @example
* // Return a seeded PRNG:
* var randn = factory({
*     'seed': 12345
* });
*
* var r = randn();
* // returns <number>
*/
function factory( options ) {
	var rand;
	var seed;
	var flg;
	var v;
	var r;
	if ( arguments.length ) {
		if ( !isObject( options ) ) {
			throw new TypeError( 'invalid input argument. Must provide an object. Value: `' + options + '`.' );
		}
		if ( hasOwnProp( options, 'prng' ) ) {
			if ( !isFunction( options.prng ) ) {
				throw new TypeError( 'invalid option. `prng` option must be a pseudorandom number generator function. Option: `' + options.prng + '`.' );
			}
			rand = options.prng;
		}
		if ( hasOwnProp( options, 'seed' ) ) {
			seed = options.seed;
		}
	}
	if ( rand === void 0 ) {
		if ( seed === void 0 ) {
			rand = randu();
		} else {
			rand = randu({
				'seed': seed
			});
		}
	}
	// Flag indicating whether to generate new normal random variates or return a cached normal random variate:
	flg = true;

	/**
	* Generates a standard normally distributed pseudorandom number.
	*
	* @private
	* @returns {number} pseudorandom number
	*
	* @example
	* var r = randn();
	* // returns <number>
	*/
	function randn() {
		var u1;
		var u2;
		var a;
		var b;
		if ( flg ) {
			// Note: if `u1` is `0`, the natural log blows up, so we keep trying until we get a non-zero rand. Rarely should we need more than one iteration.
			do {
				u1 = rand();
				u2 = rand();
			} while (
				u1 === 0.0
			);
			a = sqrt( -2.0 * ln(u1) );
			b = TWO_PI * u2;
			r = a * cos( b ); // cache for next call
			flg = false;
			return a * sin( b );
		}
		flg = true;
		return r;
	} // end FUNCTION randn()

	setReadOnly( randn, 'NAME', 'box-muller' );
	setReadOnly( randn, 'PRNG', rand );

	if ( hasOwnProp( rand, 'SEED' ) ) {
		v = rand.SEED;
	} else {
		v = null;
	}
	setReadOnly( randn, 'SEED', v );

	if ( hasOwnProp( rand, 'MIN' ) ) {
		v = getMin( rand.MIN );
	} else {
		v = null;
	}
	setReadOnly( randn, 'MIN', v );

	if ( hasOwnProp( rand, 'MIN' ) ) {
		v = getMax( rand.MIN );
	} else {
		v = null;
	}
	setReadOnly( randn, 'MAX', v );

	return randn;
} // end FUNCTION factory()


// EXPORTS //

module.exports = factory;
