'use strict';

// MODULES //

var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var isObject = require( '@stdlib/utils/is-plain-object' );
var isFunction = require( '@stdlib/utils/is-function' );
var hasOwnProp = require( '@stdlib/utils/has-own-property' );
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var ln = require( '@stdlib/math/base/special/ln' );
var sin = require( '@stdlib/math/base/special/sin' );
var cos = require( '@stdlib/math/base/special/cos' );
var TWO_PI = require( '@stdlib/math/constants/float64-two-pi' );
var randu = require( '@stdlib/math/base/random/randu' ).factory;


// FUNCTIONS //

/**
* Returns the minimum possible normally distributed pseudorandom number.
*
* @private
* @returns {number} minimum possible number
*/
function getMin( rand ) {
	var a = sqrt( -2.0 * ln( rand.MIN ) );
	var b = TWO_PI * 0.5; // => π
	return a * cos( b );
} // end FUNCTION getMin()

/**
* Returns the maximum possible normally distributed pseudorandom number.
*
* @private
* @returns {number} maximum possible number
*/
function getMax( rand ) {
	var a = sqrt( -2.0 * ln( rand.MIN ) );
	var b = TWO_PI * rand.MIN;
	return a * cos( b );
} // end FUNCTION getMax()


// FACTORY //

/**
* Returns a pseudorandom number generator which implements the Box-Muller transform to generate standard normally distributed pseudorandom numbers.
*
* @param {Options} options - function options
* @param {Function} [options.prng] - pseudorandom number generator which generates uniformly distributed pseudorandom numbers
* @param {*} [options.seed] - pseudorandom number generator seed
* @throws {TypeError} must provide an object
* @throws {TypeError} must provide valid options
* @returns {Function} pseudorandom number generator
*
* @example
* var randn = factory();
*
* var r = randn();
* // returns <number>
*
* @example
* // Return a seeded PRNG:
* var randn = factory({
*     'seed': 12345
* });
*
* var r = randn();
* // returns <number>
*/
function factory( options ) {
	var rand;
	var seed;
	var flg;
	var r;
	if ( arguments.length ) {
		if ( !isObject( options ) ) {
			throw new TypeError( 'invalid input argument. Must provide an object. Value: `' + options + '`.' );
		}
		if ( hasOwnProp( options, 'prng' ) ) {
			if ( !isFunction( options.prng ) ) {
				throw new TypeError( 'invalid option. `prng` option must be a pseudorandom number generator function. Option: `' + options.prng + '`.' );
			}
			// TODO: should we verify a provided `prng` conforms to internal PRNG api? e.g., has `MAX`, `MIN`, `SEED` properties?
			rand = options.prng;
		}
		if ( hasOwnProp( options, 'seed' ) ) {
			seed = options.seed;
		}
	}
	if ( rand === void 0 ) {
		if ( seed === void 0 ) {
			rand = randu();
		} else {
			rand = randu({
				'seed': seed
			});
		}
	}
	// Flag indicating whether to generate new normal random variates or return a cached normal random variate:
	flg = true;

	/**
	* Generates a standard normally distributed pseudorandom number.
	*
	* #### Method
	*
	* * Given two independent uniformly distributed random variables \\( U_1 \\) and \\( U_2 \\) in the interval \\( [0,1) \\), let
	*
	* ``` tex
	* \begin{align*}
	* Z_1 &= R \cos(\theta) = \sqrt{-2 \ln(U_1)} \cos(2\pi U_2) \\
	* Z_2 &= R \sin(\theta) = \sqrt{-2 \ln(U_1)} \sin(2\pi U_2)
	* \end{align*}
	* ```
	*
	* where \\( Z_1 \\) and \\( Z_2 \\) are independent random variables with a standard normal distribution.
	*
	* * As two uniform random variates are mapped to two standard normal random variates, one of the random variates is cached and returned upon the following invocation.
	*
	*
	* #### Notes
	*
	* * The minimum and maximum pseudorandom numbers which can be generated are dependent on the number of bits an underlying uniform pseudorandom number generator (PRNG) uses. For instance, if a PRNG uses \\( 32 \\) bits, the smallest non-zero number that can be generated is \\( 2^{-32}). When \\( U_1 \\) equals this value and \\( U_2 \\) equals \\( 0 \\),
	*
	*   ``` tex
	*   r = \sqrt{-2\ln(2^{-32})} \cos(2\pi) \approx 6.66
	*   ```
	*
	*   which means that the algorithm cannot produce random variates more than \\( 6.66 \\) standard deviations from the mean.
	*
	*   <!-- <note> -->
	*   This corresponds to a \\( 2.74 \times 10^{-11} \\) loss due to tail truncation.
	*   <!-- </note> -->
	*
	*
	* #### References
	*
	* * G. E. P. Box and Mervin E. Muller (1958). "A Note on the Generation of Random Normal Deviates". The Annals of Mathematical Statistics 29 (2): 610–611.
	* * J. Bell (1968). "Algorithm 334: Normal random deviates". Communications of the ACM 11 (7).
	* * R. Knopp (1969). "Remark on algorithm 334 [G5]: normal random deviates". Communications of the ACM 12 (5).
	* * G. Marsaglia and T. A. Bray. "A convenient method for generating normal variables". SIAM Rev. 6: 260–264.
	* * Thomas, D. B., Luk. W., Leong, P. H. W., and Villasenor, J. D. (2007). "Gaussian random number generators". ACM Comput Surv 39, 4, Article 11, 1-38. [DOI: 10.1145/1287620.1287622]{@link http://doi.acm.org/10.1145/1287620.1287622}.
	*
	*
	* @returns {number} pseudorandom number
	*
	* @example
	* var r = randn();
	* // returns <number>
	*/
	function randn() {
		var u1;
		var u2;
		var a;
		var b;
		if ( flg ) {
			// Note: if `u1` is `0`, the natural log blows up, so we keep trying until we get a non-zero rand. Rarely should we need more than one iteration.
			do {
				u1 = rand();
				u2 = rand();
			} while (
				u1 === 0.0
			);
			a = sqrt( -2.0 * ln(u1) );
			b = TWO_PI * u2;
			r = a * cos( b ); // cache for next call
			flg = false;
			return a * sin( b );
		}
		flg = true;
		return r;
	} // end FUNCTION randn()

	setReadOnly( randn, 'NAME', 'box-muller' );
	setReadOnly( randn, 'SEED', rand.SEED );
	setReadOnly( randn, 'MIN', getMin( rand ) );
	setReadOnly( randn, 'MAX', getMax( rand ) );

	return randn;
} // end FUNCTION factory()


// EXPORTS //

module.exports = factory;
