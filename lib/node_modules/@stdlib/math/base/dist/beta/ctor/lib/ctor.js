/* eslint-disable no-restricted-syntax, no-invalid-this */
'use strict';

// MODULES //

var betaQuantile = require( '@stdlib/math/base/dist/beta/quantile' );
var betaLogPDF = require( '@stdlib/math/base/dist/beta/logpdf' );
var betaCDF = require( '@stdlib/math/base/dist/beta/cdf' );
var betaMGF = require( '@stdlib/math/base/dist/beta/mgf' );
var betaPDF = require( '@stdlib/math/base/dist/beta/pdf' );
var kurtosis = require( '@stdlib/math/base/dist/beta/kurtosis' );
var skewness = require( '@stdlib/math/base/dist/beta/skewness' );
var variance = require( '@stdlib/math/base/dist/beta/variance' );
var entropy = require( '@stdlib/math/base/dist/beta/entropy' );
var median = require( '@stdlib/math/base/dist/beta/median' );
var mode = require( '@stdlib/math/base/dist/beta/mode' );
var mean = require( '@stdlib/math/base/dist/beta/mean' );
var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var isPositive = require( '@stdlib/assert/is-positive-number').isPrimitive;


// MAIN //

/**
* Distribution constructor.
*
* @constructor
* @param {PositiveNumber} [alpha=1.0] - first shape parameter
* @param {PositiveNumber} [beta=1.0] - second shape parameter
* @returns {BetaDist} distribution instance
*
* @example
* var dist = new Beta( 1.0, 1.0 );
* var out = dist.cdf( 0.8 );
* // returns 0.8
*
* @example
* var dist = Beta( 1.0, 1.0 );
* var out = dist.mean;
* // returns 0.5
*/
function Beta( alpha, beta ) {
	if ( !(this instanceof Beta) ) {
		if ( arguments.length === 0 ) {
			return new Beta();
		}
		return new Beta( alpha, beta );
	}

	Object.defineProperty( this, 'alpha', {
		'enumerable': true,
		'get': function getter() {
			return this._alpha;
		},
		'set': function setter( value ) {
			if ( !isPositive( value ) ) {
				throw new TypeError( 'invalid input argument. First shape parameter `alpha` must be a positive number. Value: `' + value + '`' );
			}
			this._alpha = value;
		}
	});

	Object.defineProperty( this, 'beta', {
		'enumerable': true,
		'get': function getter() {
			return this._beta;
		},
		'set': function setter( value ) {
			if ( !isPositive( value ) ) {
				throw new TypeError( 'invalid input argument. Second shape parameter `beta` must be a positive number. Value: `' + value + '`' );
			}
			this._beta = value;
		}
	});
	if ( arguments.length === 0 ) {
		// Use default parameters:
		this.alpha = 1.0;
		this.beta = 1.0;
	} else {
		this.alpha = alpha;
		this.beta = beta;
	}
	return this;
} // end FUNCTION Beta()


Object.defineProperty( Beta.prototype, 'entropy', {
	'enumerable': true,
	'get': function getter() {
		return entropy( this._alpha, this._beta );
	}
});

Object.defineProperty( Beta.prototype, 'kurtosis', {
	'enumerable': true,
	'get': function getter() {
		return kurtosis( this._alpha, this._beta );
	}
});

Object.defineProperty( Beta.prototype, 'mean', {
	'enumerable': true,
	'get': function getter() {
		return mean( this._alpha, this._beta );
	}
});

Object.defineProperty( Beta.prototype, 'median', {
	'enumerable': true,
	'get': function getter() {
		return median( this._alpha, this._beta );
	}
});

Object.defineProperty( Beta.prototype, 'mode', {
	'enumerable': true,
	'get': function getter() {
		return mode( this._alpha, this._beta );
	}
});

Object.defineProperty( Beta.prototype, 'skewness', {
	'enumerable': true,
	'get': function getter() {
		return skewness( this._alpha, this._beta );
	}
});

Object.defineProperty( Beta.prototype, 'variance', {
	'enumerable': true,
	'get': function getter() {
		return variance( this._alpha, this._beta );
	}
});

/**
* Evaluates the cumulative distribution function (CDF).
*
* @param {number} x - input value
* @returns {number} evaluated CDF
*/
setReadOnly( Beta.prototype, 'cdf', function cdf( x ) {
	return betaCDF( x, this._alpha, this._beta );
}); // end METHOD cdf()

/**
* Evaluates the logarithm of the probability density function (PDF).
*
* @param {number} x - input value
* @returns {number} evaluated logPDF
*/
setReadOnly( Beta.prototype, 'logpdf', function logpdf( x ) {
	return betaLogPDF( x, this._alpha, this._beta );
}); // end METHOD logpdf()

/**
* Evaluates the moment-generating function (MGF).
*
* @param {number} t - input value
* @returns {number} evaluated MGF
*/
setReadOnly( Beta.prototype, 'mgf', function mgf( t ) {
	return betaMGF( t, this._alpha, this._beta );
}); // end METHOD mgf()

/**
* Evaluates the probability density function (PDF).
*
* @param {number} x - input value
* @returns {number} evaluated PDF
*/
setReadOnly( Beta.prototype, 'pdf', function pdf( x ) {
	return betaPDF( x, this._alpha, this._beta );
}); // end METHOD pdf()

/**
* Evaluates the quantile function.
*
* @param {number} x - input value
* @returns {number} evaluated quantile function
*/
setReadOnly( Beta.prototype, 'quantile', function quantile( x ) {
	return betaQuantile( x, this._alpha, this._beta );
}); // end METHOD quantile()


// EXPORTS //

module.exports = Beta;
