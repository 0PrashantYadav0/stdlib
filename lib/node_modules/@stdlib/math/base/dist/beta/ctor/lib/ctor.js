/* eslint-disable no-restricted-syntax */
'use strict';

// MODULES //

var betaQuantile = require( '@stdlib/math/base/dist/beta/quantile' );
var betaLogPDF = require( '@stdlib/math/base/dist/beta/logpdf' );
var betaCDF = require( '@stdlib/math/base/dist/beta/cdf' );
var betaMGF = require( '@stdlib/math/base/dist/beta/mgf' );
var betaPDF = require( '@stdlib/math/base/dist/beta/pdf' );
var kurtosis = require( '@stdlib/math/base/dist/beta/kurtosis' );
var skewness = require( '@stdlib/math/base/dist/beta/skewness' );
var variance = require( '@stdlib/math/base/dist/beta/variance' );
var entropy = require( '@stdlib/math/base/dist/beta/entropy' );
var median = require( '@stdlib/math/base/dist/beta/median' );
var mode = require( '@stdlib/math/base/dist/beta/mode' );
var mean = require( '@stdlib/math/base/dist/beta/mean' );
var isPositive = require( '@stdlib/assert/is-positive-number').isPrimitive;


// MAIN //

/**
* Distribution constructor.
*
* @constructor
* @param {PositiveNumber} [alpha=1.0] - first shape parameter
* @param {PositiveNumber} [beta=1.0] - second shape parameter
* @returns {BetaDist} distribution instance
*
* @example
* var dist = new Beta( 1.0, 1.0 );
* var out = dist.cdf( 0.8 );
* // returns 0.8
*
* @example
* var dist = Beta( 1.0, 1.0 );
* var out = dist.mean;
* // returns 0.5
*/
function BetaDist( alpha, beta ) {
	if ( !(this instanceof BetaDist) ) {
		if ( arguments.length === 0 ) {
			return new BetaDist();
		}
		return new BetaDist( alpha, beta );
	}

	Object.defineProperty( this, 'alpha', {
		'enumerable': true,
		'get': function getter() {
			return this._alpha;
		},
		'set': function setter( value ) {
			if ( !isPositive( value ) ) {
				throw new TypeError( 'invalid input argument. First shape parameter `alpha` must be a positive number. Value: `' + value + '`' );
			}
			this._alpha = value;
		}
	});

	Object.defineProperty( this, 'beta', {
		'enumerable': true,
		'get': function getter() {
			return this._beta;
		},
		'set': function setter( value ) {
			if ( !isPositive( value ) ) {
				throw new TypeError( 'invalid input argument. Second shape parameter `beta` must be a positive number. Value: `' + value + '`' );
			}
			this._beta = value;
		}
	});
	if ( arguments.length === 0 ) {
		// Use default parameters:
		this.alpha = 1.0;
		this.beta = 1.0;
	} else {
		this.alpha = alpha;
		this.beta = beta;
	}
	// Attach properties:
	Object.defineProperty( this, 'entropy', {
		'enumerable': true,
		'get': function getter() {
			return entropy( this._alpha, this._beta );
		}
	});
	Object.defineProperty( this, 'kurtosis', {
		'enumerable': true,
		'get': function getter() {
			return kurtosis( this._alpha, this._beta );
		}
	});
	Object.defineProperty( this, 'mean', {
		'enumerable': true,
		'get': function getter() {
			return mean( this._alpha, this._beta );
		}
	});
	Object.defineProperty( this, 'median', {
		'enumerable': true,
		'get': function getter() {
			return median( this._alpha, this._beta );
		}
	});
	Object.defineProperty( this, 'mode', {
		'enumerable': true,
		'get': function getter() {
			return mode( this._alpha, this._beta );
		}
	});
	Object.defineProperty( this, 'skewness', {
		'enumerable': true,
		'get': function getter() {
			return skewness( this._alpha, this._beta );
		}
	});
	Object.defineProperty( this, 'variance', {
		'enumerable': true,
		'get': function getter() {
			return variance( this._alpha, this._beta );
		}
	});
	return this;
} // end FUNCTION BetaDist()


// METHODS //

/**
* Evaluates the cumulative distribution function (CDF).
*
* @private
* @param {number} x - input value
* @returns {number} evaluated CDF
*/
BetaDist.prototype.cdf = function cdf( x ) {
	return betaCDF( x, this._alpha, this._beta );
}; // end METHOD cdf()

/**
* Evaluates the logarithm of the probability density function (PDF).
*
* @private
* @param {number} x - input value
* @returns {number} evaluated logPDF
*/
BetaDist.prototype.logpdf = function logpdf( x ) {
	return betaLogPDF( x, this._alpha, this._beta );
}; // end METHOD logpdf()

/**
* Evaluates the moment-generating function (MGF).
*
* @private
* @param {number} t - input value
* @returns {number} evaluated MGF
*/
BetaDist.prototype.mgf = function mgf( t ) {
	return betaMGF( t, this._alpha, this._beta );
}; // end METHOD pdf()

/**
* Evaluates the probability density function (PDF).
*
* @private
* @param {number} x - input value
* @returns {number} evaluated PDF
*/
BetaDist.prototype.pdf = function pdf( x ) {
	return betaPDF( x, this._alpha, this._beta );
}; // end METHOD pdf()

/**
* Evaluates the quantile function.
*
* @private
* @param {number} x - input value
* @returns {number} evaluated quantile function
*/
BetaDist.prototype.quantile = function quantile( x ) {
	return betaQuantile( x, this._alpha, this._beta );
}; // end METHOD quantile()


// EXPORTS //

module.exports = BetaDist;
