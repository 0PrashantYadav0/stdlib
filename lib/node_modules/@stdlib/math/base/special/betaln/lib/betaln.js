'use strict';

/*
* The code is adapted from the Fortran routine from the FNLIB library of the [SLATEC Common Mathematical Library]{@link http://www.netlib.no/netlib/slatec/fnlib/albeta.f}.
*
* The original code was developed by W. Fullerton of Los Alamos Scientific Laboratory, a governmental institution, and is therefore public domain software.
*/

// MODULES //

var gammaln = require( '@stdlib/math/base/special/gammaln' );
var log1p = require( '@stdlib/math/base/special/log1p' );
var gamma = require( '@stdlib/math/base/special/gamma' );
var NINF = require( '@stdlib/math/constants/float64-ninf' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );
var ln = require( '@stdlib/math/base/special/ln' );
var correction = require( './gamma_correction.js' );


// FUNCTIONS //

var max = Math.max;
var min = Math.min;


// CONSTANTS //

// log(sqrt(2*pi)
var SQ2PIL = 0.918938533204672741780329736406;


// BETALN //

/**
* Evaluate the natural logarithm of the beta function.
*
* @param {NonNegativeNumber} x - input value
* @param {NonNegativeNumber} y - input value
* @returns {number} evaluated beta function
*
* @example
* var v = betaln( 0.0, 0.0 );
* // returns Number.POSITIVE_INFINITY
* @example
* var v = betaln( 1.0, 1.0 );
* // returns 0.0
* @example
* var v = betaln( -1.0, 2.0 );
* // return NaN
* @example
* var v = betaln( 5.0, 0.2 );
* // returns ~1.218
* @example
* var v = betaln( 4.0, 1.0 );
* // returns ~-1.386
* @example
* var v = betaln( NaN, 2.0 );
* // returns NaN
*/
function betaln( a, b ) {
	var corr;
	var p;
	var q;

	p = min( a, b );
	q = max( a, b );

	if ( p < 0.0 ) {
		return NaN;
	}
	else if ( p === 0.0 ) {
		return PINF;
	}
	else if ( q === PINF ) {
		return NINF;
	}

	// Case: p and q are big
	if ( p >= 10.0 ) {
		corr = correction( p ) + correction( q ) - correction( p + q );
		return -0.5 * ln( q ) + SQ2PIL + corr + ( p - 0.5 ) * ln( p/(p+q) ) +
			q * log1p( -p/(p+q) );
	}
	// Case: p is small, but q is big
	else if ( q >= 10.0 ) {
		corr = correction( q ) - correction( p + q );
		return gammaln( p ) + corr + p - p * ln( p + q ) +
			( q - 0.5 ) * log1p( -p/(p+q) );
	}
	// Case: p and q are small
	else {

		return ln( gamma( p ) * ( gamma(q) / gamma(p+q) ) );
	}

} // end FUNCTION betaln()


// EXPORTS //

module.exports = betaln;
