'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/special_functions/beta.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* (C) Copyright John Maddock 2006.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var continuedFraction = require( '@stdlib/math/base/tools/continued-fraction' );
var ibeta_power_terms = require( './ibeta_power_terms.js' );


// MAIN //

/**
* Continued fraction for the incomplete beta:
*
* @private
*/
function ibeta_fraction2_t( a, b, x, y ) {
	var m = 0;
	return function next() {
		var denom;
		var aN;
		var bN;

		aN = (a + m - 1) * (a + b + m - 1) * m * (b - m) * x * x;
		denom = (a + 2 * m - 1);
		aN /= denom * denom;

		bN = m;
		bN += (m * (b - m) * x) / (a + 2*m - 1);
		bN += ( (a + m) * ( a * y - b * x + 1 + m *(2 - x) ) ) / (a + 2*m + 1);

		++m;
		return [ aN, bN ];
	};
} // end FUNCTION ibeta_fraction2_t()


/**
* Evaluate the incomplete beta via the continued fraction representation.
*
* @private
*/
function ibeta_fraction2( a, b, x, y, normalised, pderiv ) {
	var result;
	var fract;
	var f;

	result = ibeta_power_terms( a, b, x, y, normalised );
	if ( pderiv ) {
		pderiv.value = result;
	}
	if ( result === 0.0 ) {
		return result;
	}
	f = ibeta_fraction2_t( a, b, x, y );
	fract = continuedFraction( f, {
		'keep': true
	});
	return result / fract;
} // end FUNCTION ibeta_fraction2()


// EXPORTS

module.exports = ibeta_fraction2;
