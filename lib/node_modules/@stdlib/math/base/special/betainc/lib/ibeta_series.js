'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/special_functions/beta.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* (C) Copyright John Maddock 2006.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var sumSeries = require( '@stdlib/math/base/tools/sum-series' );
var log1p = require( '@stdlib/math/base/special/log1p' );
var exp = require( '@stdlib/math/base/special/exp' );
var pow = require( '@stdlib/math/base/special/pow' );
var ln = require( '@stdlib/math/base/special/ln' );
var MIN_VALUE = require( '@stdlib/math/constants/float64-smallest-normal' );
var MAX_LN = require( '@stdlib/math/constants/float64-max-ln' );
var MIN_LN = require( '@stdlib/math/constants/float64-min-ln' );
var lower_gamma_series = require( './lower_gamma_series.js' );
var upper_gamma_fraction = require( './upper_gamma_fraction.js' );


// MAIN //

/**
* Series approximation to the incomplete beta.
*
* @private
*/
function ibeta_series_t( a_, b_, x_, mult ) {
	var result = mult,
		x = x_,
		apn = a_,
		poch = 1 - b_,
		n = 1;
	return function next() {
		var r = result / apn;
		apn += 1;
		result *= poch * x / n;
		++n;
		poch += 1;
		return r;
	};
} // end FUNCTION ibeta_series_t()


/**
* Incomplete Beta series again without Lanczos support.
*
* @private
*/
function ibeta_series( a, b, x, s0, normalised, pderiv, y ) {
	var result;
	var lb1;
	var lb2;
	var lb;
	var lc;
	var sa;
	var sb;
	var sc;
	var b1;
	var b2;
	var e1;
	var la;
	var c;
	var p;
	var s;

	if ( normalised ) {
		c = a + b;
		// Figure out integration limits for the gamma function:
		la = a + 5;
		lb = b + 5;
		lc = a + b + 5;
		// Calculate the gamma parts:
		sa = lower_gamma_series( a, la ) / a;
		sa += upper_gamma_fraction( a, la );
		sb = lower_gamma_series( b, lb ) / b;
		sb += upper_gamma_fraction( b, lb );
		sc = lower_gamma_series( c, lc ) / c;
		sc += upper_gamma_fraction( c, lc );
		// And their combined power-terms:
		b1 = ( x * lc ) / la;
		b2 = lc / lb;
		e1 = lc - la - lb;
		lb1 = a * ln( b1 );
		lb2 = b * ln( b2 );

		if (
			lb1 >= MAX_LN || lb1 <= MIN_LN ||
			lb2 >= MAX_LN || lb2 <= MIN_LN ||
			e1 >= MAX_LN || e1 <= MIN_LN
		) {
			p = lb1 + lb2 - e1;
			result = exp( p );
		} else {
			result = pow( b1, a );
			if ( a * b < lb * 10 ) {
				result *= exp( b * log1p( a / lb ) );
			} else {
				result *= pow( b2, b );
			}
			result /= exp( e1 );
		}
		// Combine the results:
		result /= sa * sb / sc;

		if ( pderiv ) {
			pderiv.value = result * pow( y, b );
		}
	} else {
		// Non-normalised, just compute the power:
		result = pow( x, a );
	}
	if ( result < MIN_VALUE ) {
		// Safeguard: series can't cope with denorms...
		return s0;
	}
	s = ibeta_series_t( a, b, x, result );
	result = sumSeries( s, {
		'initialValue': s0
	});
	return result;
} // end FUNCTION ibeta_series()


// EXPORTS

module.exports = ibeta_series;
