'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_64_0/boost/math/special_functions/detail/lgamma_small.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* (C) Copyright John Maddock 2006-7, 2013-14.
* (C) Copyright Paul A. Bristow 2007, 2013-14.
* (C) Copyright Nikhar Agrawal 2013-14.
* (C) Copyright Christopher Kormanyos 2013-14.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var evalrational = require( '@stdlib/math/base/tools/evalrational' ).factory;
var ln = require( '@stdlib/math/base/special/ln' );
var EPS = require( '@stdlib/math/constants/float64-eps' );


// VARIABLES //

var Y1 = 0.158963680267333984375;
var Y2 = 0.52815341949462890625;
var Y3 = 0.452017307281494140625;

var P1 = [
	-0.180355685678449379109e-1,
	0.25126649619989678683e-1,
	0.494103151567532234274e-1,
	0.172491608709613993966e-1,
	-0.259453563205438108893e-3,
	-0.541009869215204396339e-3,
	-0.324588649825948492091e-4,
	0.0
];
var Q1 = [
	0.1e1,
	0.196202987197795200688e1,
	0.148019669424231326694e1,
	0.541391432071720958364e0,
	0.988504251128010129477e-1,
	0.82130967464889339326e-2,
	0.224936291922115757597e-3,
	-0.223352763208617092964e-6
];

var P2 = [
	0.490622454069039543534e-1,
	-0.969117530159521214579e-1,
	-0.414983358359495381969e0,
	-0.406567124211938417342e0,
	-0.158413586390692192217e0,
	-0.240149820648571559892e-1,
	-0.100346687696279557415e-2
];
var Q2 = [
	0.1e1,
	0.302349829846463038743e1,
	0.348739585360723852576e1,
	0.191415588274426679201e1,
	0.507137738614363510846e0,
	0.577039722690451849648e-1,
	0.195768102601107189171e-2
];

var P3 = [
	-0.292329721830270012337e-1,
	0.144216267757192309184e0,
	-0.142440390738631274135e0,
	0.542809694055053558157e-1,
	-0.850535976868336437746e-2,
	0.431171342679297331241e-3,
	0.0
];
var Q3 = [
	0.1e1,
	-0.150169356054485044494e1,
	0.846973248876495016101e0,
	-0.220095151814995745555e0,
	0.25582797155975869989e-1,
	-0.100666795539143372762e-2,
	-0.827193521891290553639e-6
];


// FUNCTIONS //

// Compile functions to evaluate rational functions based on the above coefficients...
var rateval1 = evalrational( P1, Q1 );
var rateval2 = evalrational( P2, Q2 );
var rateval3 = evalrational( P3, Q3 );


// MAIN //

/**
* Evaluates the natural logarithm of the gamma function for small arguments.
*
* #### Method
*
* 1. For \\( z > 2 \\), begin by performing argument reduction until \\( z \\) is in [2,3). Use the following form:
*
*    ``` tex
*    \operatorname{gammaln}(z) = (z-2)(z+1)(Y + R(z-2))
*    ```
*
*    where \\( R(z-2) \\) is a rational approximation optimized for low absolute error. As long as the absolute error is small compared to the constant \\( Y \\), then any rounding error in the computation will get wiped out.
*
* 2. If \\( z < 1 \\), use recurrence to shift to \\( z \\) in the interval [1,2]. Then use either of two approximations, on for \\( z \\) in [1,1.5] and one for \\( z \\) in [1.5,2]:
*
*    - For \(( z \\) in [1,1.5], use
*
*      ``` tex
*      \operatorname{gammaln}(z) = (z-1)(z-2)(Y + R(z-1))
*      ```
*
*   where \\( R(z-1) \\) is a rational approximation optimized for low absolute error - as long as it's absolute error is small compared to the constant \\( Y \\) - then any rounding error in it's computation will get wiped out.
*
*   - For \\( z \\) in [1.5,2], use
*
*     ``` tex
*     \operatorname{gammaln}(z) = (2-z)(1-z)(Y + R(2-z))
*     ```
*
*     where \\( R(2-z) \\) is a rational approximation optimized for low absolute error - as long as it's absolute error is small compared to the constant \\( Y \\) - then any rounding error in it's computation will get wiped out.
*
* #### Notes
*
* * Relative error:
*
*   | function | peak         | maximum deviation |
*   |:--------:|:------------:|:-----------------:|
*   | R(Z-2)   | 4.231e-18    | 5.900e-24         |
*   | R(Z-1)   | 1.230011e-17 | 3.139e-021        |
*   | R(2-Z)   | 1.797565e-17 | 2.151e-021        |
*
* @private
* @param {number} z - input value
* @param {number} zm1 - z minus one
* @param {number} zm2 - z minus two
* @returns {number} function value
*/
function lgammaSmallImp( z, zm1, zm2 ) {
	var prefix;
	var result;
	var r;
	var R;

	if ( z < EPS ) {
		return -ln( z );
	}
	if ( zm1 === 0.0 || zm2 === 0.0 ) {
		return 0.0;
	}
	result = 0.0;
	if ( z > 2.0 ) {
		if ( z >= 3.0 ) {
			do {
				z -= 1.0;
				zm2 -= 1.0;
				result += ln(z);
			} while ( z >= 3.0 );
			// Update zm2, we need it below:
			zm2 = z - 2.0;
		}
		r = zm2 * ( z + 1.0 );
		R = rateval1( zm2 );
		result += ( r * Y1 ) + ( r * R );
		return result;
	}
	if ( z < 1.0 ) {
		result += -ln(z);
		zm2 = zm1;
		zm1 = z;
		z += 1.0;
	}
	if ( z <= 1.5 ) {
		r = rateval2( zm1 );
		prefix = zm1 * zm2;
		result += ( prefix * Y2 ) + ( prefix * r );
		return result;
	}
	// Case: 1.5 < z <= 2
	r = zm2 * zm1;
	R = rateval3( -zm2 );
	result += ( r * Y3 ) + ( r * R );
	return result;
} // end FUNCTION lgammaSmallImp()


// EXPORTS //

module.exports = lgammaSmallImp;
