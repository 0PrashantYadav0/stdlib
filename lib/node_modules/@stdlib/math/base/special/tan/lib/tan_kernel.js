'use strict';

/*
* The following copyright, license, and long comment were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/k_tan.c?view=co}.
*
* The implementation follows the original, but has been modified for JavaScript.
*/

/*
* ====================================================
* Copyright 2004 Sun Microsystems, Inc.  All Rights Reserved.
*
* Permission to use, copy, modify, and distribute this
* software is freely granted, provided that this notice
* is preserved.
* ====================================================
*/

// MODULES //

var getHighWord = require( '@stdlib/math/base/utils/float64-get-high-word' );
var setLowWord = require( '@stdlib/math/base/utils/float64-set-low-word' );


// CONSTANTS //

var PIO4 = 7.85398163397448278999e-01;
var PIO4LO = 3.06161699786838301793e-17;
var T = [
	3.33333333333334091986e-01,	/* 3FD55555, 55555563 */
	1.33333333333201242699e-01,	/* 3FC11111, 1110FE7A */
	5.39682539762260521377e-02,	/* 3FABA1BA, 1BB341FE */
	2.18694882948595424599e-02,	/* 3F9664F4, 8406D637 */
	8.86323982359930005737e-03,	/* 3F8226E3, E96E8493 */
	3.59207910759131235356e-03,	/* 3F6D6D22, C9560328 */
	1.45620945432529025516e-03,	/* 3F57DBC8, FEE08315 */
	5.88041240820264096874e-04,	/* 3F4344D8, F2F26501 */
	2.46463134818469906812e-04,	/* 3F3026F7, 1A8D1068 */
	7.81794442939557092300e-05,	/* 3F147E88, A03792A6 */
	7.14072491382608190305e-05,	/* 3F12B80F, 32F0A7E9 */
	-1.85586374855275456654e-05,	/* BEF375CB, DB605373 */
	2.59073051863633712884e-05	/* 3EFB2A70, 74BF7AD4 */
];


// KERNEL TAN //

/**
* Computes the tan function on \\( \approx[-\pi/4, \pi/4] \\) (except on -0), \\( \pi/4 \approx 0.7854 \\)
*
* #### Method
*
* * Since \\( \tan(-x) = -\tan(x) \\), we need only to consider positive x.
* * Callers must return \\( \tan(-0) = -0 \\) without calling here since our odd polynomial is not evaluated in a way that preserves -0. Callers may do the optimization \\( \tan(x) \approx x \\) for tiny x.
* * \\( \tan(x) \\) is approximated by a odd polynomial of degree 27 on \\( [0,0.67434] \\)
*
*   ``` tex
*   \tan(x) \approx x + T_1 x^3 + \ldots + T_{13} x^{27}
*   ```
*   where
*
*   ``` tex
*   \left| \frac{\tan(x)}{x} - \left( 1 + T_1 x^2 + T_2 x^4 + \ldots + T_{13} x^{26} \right) \right|  \le 2^{-59.2}
*   ```
*
* * Note: \\( \tan(x+y) = \tan(x) + \tan'(x) \cdot y \approx \tan(x) + ( 1 + x \cdot x ) \cdot y \\). Therefore, for better accuracy in computing \\( \tan(x+y) \\), let
*
*   ``` tex
*    r = x^3 \cdot \left( T_2+x^2 \cdot (T_3+x^2 \cdot (\ldots+x^2 \cdot (T_{12}+x^2 \cdot T_{13}))) \right)
*   ```
*
*   then
*
*   ``` tex
*   \tan(x+y) = x^3 + \left( T_1 \cdot x^2 + (x \cdot (r+y)+y) \right)
*   ```
*
* * For x in \\( [0.67434,\pi/4] \\),  let \\( y = \pi/4 - x \\), then
*
*   ``` tex
*   \tan(x) = \tan\left(\tfrac{\pi}{4}-y\right) = \frac{1-\tan(y)}{1+\tan(y)} \\
*   = 1 - 2 \cdot \left( \tan(y) - \tfrac{\tan(y)^2}{1+\tan(y)} \right)
*   ```
*
* @param {number} x - input value (assumed to be bounded by ~pi/4 in magnitude)
* @param {number} y - tail of x.
* @param {number} k - indicates whether tan (if k = 1) or -1/tan (if k = -1) is returned.
* @param {number} tangent (in radians)
*/
function tanKernel( x, y, k ) {
	var hx;
	var ix;
	var a;
	var r;
	var s;
	var t;
	var v;
	var w;
	var z;

	hx = getHighWord( x );
	// High word of |x|:
	ix = hx & 0x7fffffff;

	// Case: |x| >= 0.6744
	if ( ix >= 0x3FE59428 ) {
		if ( x < 0 ) {
			x = -x;
			y = -y;
		}
		z = PIO4 - x;
		w = PIO4LO - y;
		x = z + w;
		y = 0.0;
	}
	z = x * x;
	w = z * z;
	// Break x^5*(T[1]+x^2*T[2]+...) into x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +
	// x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))
	r = T[1] + w * (T[3] + w * (T[5] + w * (T[7] + w * (T[9] +
		w * T[11]))));
	v = z * (T[2] + w * (T[4] + w * (T[6] + w * (T[8] + w * (T[10] +
		w * T[12])))));
	s = z * x;
	r = y + z * (s * (r + v) + y);
	r += T[0] * s;
	w = x + r;
	if ( ix >= 0x3FE59428 ) {
		v = k;
		return ( 1.0 - ( (hx >> 30) & 2 ) ) *
			( v - 2.0 * (x - (w * w / (w + v) - r)) );
	}
	if ( k === 1 ) {
		return w;
	}
	else {
		// Compute -1.0 / (x+r) accurately:
		z = w;
		setLowWord( z, 0 );
		v = r - (z - x); // z + v = r + x
		t = a = -1.0 / w; // a = -1.0 / w
		setLowWord( t, 0 );
		s = 1.0 + t * z;
		return t + a * (s + t * v);
	}
} // end FUNCTION tanKernel()


// EXPORTS //

module.exports = tanKernel;
