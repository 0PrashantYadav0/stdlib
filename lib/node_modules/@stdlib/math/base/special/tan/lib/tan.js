'use strict';

/*
* The following copyright, license, and long comment were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/s_tan.c?view=log}.
*
* The implementation follows the original, but has been modified for JavaScript.
*/

/*
* ====================================================
* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
*
* Developed at SunPro, a Sun Microsystems, Inc. business.
* Permission to use, copy, modify, and distribute this
* software is freely granted, provided that this notice
* is preserved.
* ====================================================
*/

// MODULES //

var getHighWord = require( '@stdlib/math/base/utils/float64-get-high-word' );
var tanKernel = require( './tan_kernel.js' );
var remPio2 = require( './rem_pio2.js' );


// TAN //

/**
* Evaluates the tangent of a number.
*
* #### Method
*
* Let S,C and T denote the sin, cos and tan respectively on [-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2 in [-pi/4 , +pi/4], and let n = k mod 4. We have
*
* | n   |  sin(x)  |  cos(x)  |  tan(x)  |
* | --- |----------|----------|----------|
* |  0  |     S    |     C    |    T     |
* |  1  |     C    |    -S    |   -1/T   |
* |  2  |    -S    |    -C    |    T     |
* |  3  |    -C    |     S    |   -1/T   |
*
* @param {number} x - input value
* @returns {number} tangent (in radians)
*
* @example
* var v = tan( 0.0 );
* // returns ~0.0
* @example
* var v = tan( -Math.PI/4.0 );
* // returns ~-1.0
* @example
* var v = tan( Math.PI/4.0 );
* // returns ~1.0
* @example
* var v = tan( NaN );
* // returns NaN
*/
function tan( x ) {
	var y;
	var z;
	var n;
	var ix;

	z = 0.0;
	y = new Array( 2 );
	ix = getHighWord( x );
	ix &= 0x7fffffff;

	// Case: |x| ~< pi/4
	if ( ix <= 0x3fe921fb ) {
		// Case: x < 2**-27
		if ( ix < 0x3e400000 ) {
			if ( (x|0) === 0  ) {
				// Generate inexact...
				return x;
			}
		}
		return tanKernel( x, z, 1 );
	}
	// Case: tan(Inf or NaN) is NaN
	else if ( ix >= 0x7ff00000 ) {
		return NaN;
	}
	// Argument reduction needed...
	else {
		n = remPio2( x, y );
		return tanKernel( y[0], y[1], (n & 1) ? -1 : 1 );
	}
} // end FUNCTION tan()


// EXPORTS //

// FIXME: replace Math.tan by tan as soon as accuracy is on-par
module.exports = Math.tan;
