'use strict';

// MODULES //

var isnan = require( '@stdlib/math/base/utils/is-nan' );
var isInfinite = require( '@stdlib/math/base/utils/is-infinite' );
var pow = require( '@stdlib/math/base/special/pow' );
var round = require( '@stdlib/math/base/special/round' );
var MAX_SAFE_INTEGER = require( '@stdlib/math/constants/float64-max-safe-integer' );


// VARIABLES //

var MAX_INT = MAX_SAFE_INTEGER + 1;


// ROUNDN //

/**
* Rounds a numeric value to the nearest multiple of 10^n.
*
* @param {number} x - input value
* @param {number} n - integer power of 10
* @returns {number} rounded value
*
* @example
* // Round a value to 2 decimal places:
* var v = roundn( Math.PI, -2 );
* // returns 3.14
* @example
* // If n = 0, `roundn` behaves like `round`:
* var v = roundn( Math.PI, 0 );
* // returns 3.0
* @example
* // Round a value to the nearest thousand:
* var v = roundn( 12368.0, 3 );
* // returns 12000.0
*/
function roundn( x, n ) {
	var m;
	var s;
	var t;
	var y;

	// FIXME: add note to README about situations like `x = 0.2 + 0.1 = 0.30000000000000004` => `roundn(x,-16) = 0.3000000000000001`, which is due to `x * 10^16 = 3000000000000000.5`; i.e., no guarantee that a scaled number will have the same digit sequence due to binary format. May be able to flag this in code by checking if the user is attempting to round the second-to-last or last digit of a decimal number. Julia includes a note (http://docs.julialang.org/en/release-0.4/stdlib/math/#Base.round) as does Python (https://docs.python.org/2/library/functions.html#round and https://docs.python.org/3/library/functions.html#round)
	// Note: alternative algorithm => https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round which uses exponential notation and string conversion (not particularly performant)
	// see also https://hg.python.org/releasing/2.7.9/file/tip/Objects/floatobject.c#l1082 and https://hg.python.org/releasing/2.7.9/file/tip/Objects/floatobject.c#l1226
	// TODO: include method notes in JSDOC

	if (
		isnan( x ) ||
		isnan( n ) ||
		isInfinite( n )
	) {
		return NaN;
	}
	if (
		// Handle infinities...
		isInfinite( x ) ||

		// Handle +-0...
		x === 0.0 ||

		// If `n` exceeds the maximum number of feasible decimal places (such as with subnormal numbers), nothing to round...
		n < -324 ||

		// If `x` is large enough, no decimals to round...
		( x > MAX_INT && n < 0 )
	) {
		return x;
	}
	// The maximum absolute double is ~1.8e308. Accordingly, any possible finite `x` rounded to the nearest >=10^309 is 0.0.
	if ( n > 308 ) {
		return 0.0 * x; // preserve the sign (same behavior as round)
	}
	// If we overflow, return `x`, as the number of digits to the right of the decimal is too small (i.e., `x` is too large / lacks sufficient fractional precision) for there to be any effect when rounding...
	if ( n < -308 ) {
		// Break into two steps...
		m = n + 308;
		s = pow( 10.0, -n );
		y = x * s;
		t = pow( 10.0, -m );
		y = y * t;
		if ( isInfinite( y ) ) {
			return x;
		}
		return ( round(y) / s ) / t;
	}
	s = pow( 10.0, -n );
	y = x * s;
	if ( isInfinite( y ) ) {
		return x;
	}
	return round( y ) / s;
} // end FUNCTION roundn()


// EXPORTS //

module.exports = roundn;
