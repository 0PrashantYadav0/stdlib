'use strict';

// MODULES //

var isnan = require( '@stdlib/math/base/utils/is-nan' );
var isInfinite = require( '@stdlib/math/base/utils/is-infinite' );
var pow = require( '@stdlib/math/base/special/pow' );
var round = require( '@stdlib/math/base/special/round' );
var MAX_SAFE_INTEGER = require( '@stdlib/math/constants/float64-max-safe-integer' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );


// VARIABLES //

var MAX_INT = MAX_SAFE_INTEGER + 1;


// ROUNDN //

/**
* Rounds a numeric value to the nearest multiple of 10^n.
*
* @param {number} x - input value
* @param {number} n - integer power of 10
* @returns {number} rounded value
*
* @example
* // Round a value to 2 decimal places:
* var v = roundn( Math.PI, -2 );
* // returns 3.14
* @example
* // If n = 0, `roundn` behaves like `round`:
* var v = roundn( Math.PI, 0 );
* // returns 3.0
* @example
* // Round a value to the nearest thousand:
* var v = roundn( 12368.0, 3 );
* // returns 12000.0
*/
function roundn( x, n ) {
	var m;
	var s;
	var t;
	var y;
	if ( x === 0.0 ) {
		return x; // handles +-0
	}
	if ( isnan( x ) || isnan( n ) ) {
		return NaN;
	}
	if ( isInfinite( x ) ) {
		return x;
	}
	if ( isInfinite( n ) ) {
		return NaN;
	}
	if ( x > MAX_INT && n < 0 ) {
		// `x` is always an integer value, so no decimals to round...
		return x;
	}
	// If at any point we overflow, return `x`, as the precision of `x` is too low (i.e., `x` is too large) for there to be any effect when rounding...
	if ( n < -308 ) {
		// Break into two steps...
		m = n + 308;

		s = pow( 10.0, -n );
		y = x * s;
		if ( y === PINF ) {
			return x;
		}
		t = pow( 10.0, -m );
		y = y * t;
		if ( y === PINF ) {
			return x;
		}
		return ( round(y) / s ) / t;
	}
	s = pow( 10.0, -n );
	y = x * s;
	if ( y === PINF ) {
		return x;
	}
	return round( y ) / s;
} // end FUNCTION roundn()


// EXPORTS //

module.exports = roundn;
