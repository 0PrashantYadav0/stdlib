'use strict';

// MODULES //

var isnan = require( '@stdlib/math/base/utils/is-nan' );
var isInfinite = require( '@stdlib/math/base/utils/is-infinite' );
var pow = require( '@stdlib/math/base/special/pow' );
var round = require( '@stdlib/math/base/special/round' );
var MAX_SAFE_INTEGER = require( '@stdlib/math/constants/float64-max-safe-integer' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );


// VARIABLES //

var MAX_INT = MAX_SAFE_INTEGER + 1;


// ROUNDN //

/**
* Rounds a numeric value to the nearest multiple of 10^n.
*
* @param {number} x - input value
* @param {number} n - integer power of 10
* @returns {number} rounded value
*
* @example
* // Round a value to 2 decimal places:
* var v = roundn( Math.PI, -2 );
* // returns 3.14
* @example
* // If n = 0, `roundn` behaves like `round`:
* var v = roundn( Math.PI, 0 );
* // returns 3.0
* @example
* // Round a value to the nearest thousand:
* var v = roundn( 12368.0, 3 );
* // returns 12000.0
*/
function roundn( x, n ) {
	var m;
	var s;
	var t;
	var y;

	// TODO: investigate a more elegant solution. Does an algorithm possibly exist which can achieve the same end by just manipulating the float exponent?
	// FIXME: add note to README about situations like `x = 0.2 + 0.1 = 0.30000000000000004` => `roundn(x,-16) = 0.3000000000000001`, which is due to `x * 10^16 = 3000000000000000.5`; i.e., no guarantee that a scaled number will have the same digit sequence due to binary format. May be able to flag this in code by checking if the user is attempting to round the second-to-last or last digit of a decimal number
	if ( x === 0.0 ) {
		return x; // handles +-0
	}
	if ( isnan( x ) || isnan( n ) ) {
		return NaN;
	}
	if ( isInfinite( x ) ) {
		return x;
	}
	if ( isInfinite( n ) ) {
		return NaN;
	}
	if ( x > MAX_INT && n < 0 ) {
		// `x` is always an integer value, so no decimals to round...
		return x;
	}
	// If at any point we overflow, return `x`, as the precision of `x` is too low (i.e., `x` is too large) for there to be any effect when rounding...
	if ( n < -308 ) {
		// Break into two steps...
		m = n + 308;

		s = pow( 10.0, -n );
		y = x * s;
		if ( y === PINF ) {
			return x;
		}
		t = pow( 10.0, -m );
		y = y * t;
		if ( y === PINF ) {
			return x;
		}
		return ( round(y) / s ) / t;
	}
	s = pow( 10.0, -n );
	y = x * s;
	if ( y === PINF ) {
		return x;
	}
	return round( y ) / s;
} // end FUNCTION roundn()


// EXPORTS //

module.exports = roundn;
