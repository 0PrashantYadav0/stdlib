'use strict';

/*
* The following copyright, license, and long comment were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/s_pow.c?view=markup}.
*
* The implementation follows the original, but has been modified for JavaScript.
*/

/*
* ====================================================
* Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.
*
* Developed at SunPro, a Sun Microsystems, Inc. business.
* Permission to use, copy, modify, and distribute this
* software is freely granted, provided that this notice
* is preserved.
* ====================================================
*/

// MODULES //

var isnan = require( '@stdlib/math/base/utils/is-nan' );
var isOdd = require( '@stdlib/math/base/utils/is-odd' );
var isInfinite = require( '@stdlib/math/base/utils/is-infinite' );
var isInteger = require( '@stdlib/math/base/utils/is-integer' );
var copysign = require( '@stdlib/math/base/special/copysign' );
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var abs = require( '@stdlib/math/base/special/abs' );
var NINF = require( '@stdlib/math/constants/float64-ninf' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );


// POW //

/**
* Evaluates the exponential function.
*
* #### Method
*
* 1. Let \\(x = 2^n (1+f)\\).
*
* 2. Compute \\(\operatorname{log2}(x)\\) as
*
*   ``` tex
*   \operatorname{log2}(x) = w_1 + w_2
*   ```
*
*   where \\(w_1\\) has \\(53 - 24 = 29\\) bit trailing zeros.
*
* 3. Compute
*
*   ``` tex
*   y \cdot \operatorname{log2}(x) = n + y^\prime
*   ```
*
*   by simulating multi-precision arithmetic, where \\(|y^\prime| \leq 0.5\\).
*
* 4. Return
*
*   ``` tex
*   x^y = 2^n e^{y^\prime \cdot \mathrm{log2}}
*   ```
*
* #### Special Cases
*
* ``` tex
* \begin{align*}
* x^{\mathrm{NaN}} &= \mathrm{NaN} & \\
* (\mathrm{NaN})^y &= \mathrm{NaN} & \\
* 1^y &= 1 & \\
* x^0 &= 1 & \\
* x^1 &= x & \\
* (\pm 0)^\infty &= +0 & \\
* (\pm 0)^{-\infty} &= +\infty & \\
* (+0)^y &= +0 & \mathrm{if}\ y > 0 \\
* (+0)^y &= +\infty & \mathrm{if}\ y < 0 \\
* (-0)^y &= -\infty & \mathrm{if}\ y\ \mathrm{is\ an\ odd\ integer\ and}\ y < 0 \\
* (-0)^y &= +\infty & \mathrm{if}\ y\ \mathrm{is\ not\ an\ odd\ integer\ and}\ y < 0 \\
* (-0)^y &= -0 & \mathrm{if}\ y\ \mathrm{is\ an\ odd\ integer\ and}\ y > 0 \\
* (-0)^y &= +0 & \mathrm{if}\ y\ \mathrm{is\ not\ an\ odd\ integer\ and}\ y > 0 \\
* (-1)^{\pm\infty} &= \mathrm{NaN} & \\
* x^{\infty} &= +\infty & |x| > 1 \\
* x^{\infty} &= +0 & |x| < 1 \\
* x^{-\infty} &= +0 & |x| > 1 \\
* x^{-\infty} &= +\infty & |x| < 1 \\
* (-\infty)^y &= (-0)^y & \\
* \infty^y &= +0 & y < 0 \\
* \infty^y &= +\infty & y > 0 \\
* x^y &= \mathrm{NaN} & \mathrm{if}\ y\ \mathrm{is\ not\ a\ finite\ integer\ and}\ x < 0
* \end{align*}
* ```
*
*
* #### Notes
*
* - \\(\operatorname{pow}(x,y)\\) returns \\(x^y\\) nearly rounded. In particular, \\(\operatorname{pow}(<\mathrm{integer}>,<\mathrm{integer}>)\\) __always__ returns the correct integer, provided the value is representable.
* - The hexadecimal values shown in the source code are the intended values for used constants. Decimal values may be used, provided the compiler will accurately convert decimal to binary in order to produce the hexadecimal values.
*
*
* @param {number} x - input value
* @returns {number} function value
*
* @example
* var v = pow( 2.0, 3.0 );
* // returns 8.0
* @example
* var v = pow( 4.0, 0.5 );
* // returns 2.0
* @example
* var v = pow( 100.0, 0.0 );
* // returns 1.0
* @example
* var v = pow( Math.PI, 5.0 );
* // returns ~306.0197
* @example
* var v = pow( Math.PI, -0.2 );
* // returns ~0.7954
* @example
* var v = pow( NaN, 3.0 );
* // returns NaN
* @example
* var v = pow( 5.0, NaN );
* // returns NaN
* @example
* var v = pow( NaN, NaN );
* // returns NaN
*/
function pow( x, y ) {
	if ( isnan( x ) || isnan( y ) ) {
		return NaN;
	}
	if ( x === 1.0 || y === 0.0 ) {
		return 1.0;
	}
	if ( y === 1.0 ) {
		return x;
	}
	if ( y === 0.5 ) {
		return sqrt( x );
	}
	if ( y === -0.5 ) {
		return 1.0 / sqrt( x );
	}
	if ( x === 0.0 ) {
		if ( y === NINF ) {
			return PINF;
		}
		if ( y === PINF ) {
			return 0.0;
		}
		if ( y > 0.0 ) {
			if ( isOdd( y ) ) {
				return x; // handles +-0
			}
			return 0.0;
		}
		// y < 0.0
		if ( isOdd( y ) ) {
			return copysign( PINF, x ); // handles +-0
		}
		return PINF;
	}
	if ( isInfinite( y ) ) {
		if ( x === -1.0 ) {
			// Julia (0.4.2) and Python (2.7.9) return `1.0` (WTF???). JavaScript (`Math.pow`), R, and libm return `NaN`. We choose `NaN`, as the value is indeterminate; i.e., we cannot determine whether `y` is odd, even, or somewhere in between.
			return NaN;
		}
		// (|x| > 1 && y === NINF) || (|x| < 1 && y === PINF)
		if ( (abs(x) < 1.0) === (y === PINF) ) {
			return 0.0;
		}
		// (|x| > 1 && y === PINF) || (|x| < 1 && y === NINF)
		return PINF;
	}
	if ( isInfinite( x ) ) {
		if ( x === NINF ) {
			// pow( 1/x, -y )
			return pow( -0.0, -y );
		}
		if ( y < 0.0 ) {
			return 0.0;
		}
		return PINF;
	}
	if (
		x < 0 &&
		isInteger( y ) === false
	) {
		return NaN;
	}
	return Math.pow( x, y );
} // end FUNCTION pow()


// EXPORTS //

module.exports = pow;
