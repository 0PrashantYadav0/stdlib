'use strict';

/*
* The following copyright, license, and long comment were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/s_pow.c?view=markup}.
*
* The implementation follows the original, but has been modified for JavaScript.
*/

/*
* ====================================================
* Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.
*
* Developed at SunPro, a Sun Microsystems, Inc. business.
* Permission to use, copy, modify, and distribute this
* software is freely granted, provided that this notice
* is preserved.
* ====================================================
*/

// MODULES //

var evalpoly = require( '@stdlib/math/base/tools/evalpoly' ).factory;
var isnan = require( '@stdlib/math/base/utils/is-nan' );
var isOdd = require( '@stdlib/math/base/utils/is-odd' );
var isInfinite = require( '@stdlib/math/base/utils/is-infinite' );
var isInteger = require( '@stdlib/math/base/utils/is-integer' );
var copysign = require( '@stdlib/math/base/special/copysign' );
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var abs = require( '@stdlib/math/base/special/abs' );
// var ldexp = require( '@stdlib/math/base/special/ldexp' ); // TODO: replace with `scalbn`
var getHighWord = require( '@stdlib/math/base/utils/float64-get-high-word' );
var getLowWord = require( '@stdlib/math/base/utils/float64-get-low-word' );
var setLowWord = require( '@stdlib/math/base/utils/float64-set-low-word' );
var setHighWord = require( '@stdlib/math/base/utils/float64-set-high-word' );
var NINF = require( '@stdlib/math/constants/float64-ninf' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );
var LN2 = require( '@stdlib/math/constants/float64-ln2' );


// CONSTANTS //

// 0x7fffffff = 2147483647 => 0 11111111111 11111111111111111111
var ABS_MASK = 0x7fffffff;

// 0x000fffff = 1048575 => 0 00000000000 11111111111111111111
var HIGH_SIGNIFICAND_MASK = 0x000fffff;

// 0x00100000 = 1048576 => 0 00000000001 00000000000000000000 => biased exponent: 1 = -1022+1023 => 2^-1022
var HIGH_MIN_NORMAL_EXP = 0x00100000;

// 0x3fefffff = 1072693247 => 0 01111111110 11111111111111111111 => biased exponent: 1022 = -1+1023 => 2^-1
var HIGH_MAX_NEAR_UNITY = 0x3fefffff;

// 0x41e00000 = 1105199104 => 0 10000011110 00000000000000000000 => biased exponent: 1054 = 31+1023 => 2^31
var HIGH_BIASED_EXP_31 = 0x41e00000;

// 0x43f00000 = 1139802112 => 0 10000111111 00000000000000000000 => biased exponent: 1087 = 64+1023 => 2^64
var HIGH_BIASED_EXP_64 = 0x43f00000;

// 0x40900000 = 1083179008 => 0 10000001001 00000000000000000000 => biased exponent: 1033 = 10+1023 => 2^10 = 1024
var HIGH_BIASED_EXP_10 = 0x40900000;

// 0x3ff00000 = 1072693248 => 0 01111111111 00000000000000000000 => biased exponent: 1023 = 0+1023 => 2^0 = 1
var HIGH_BIASED_EXP_0 = 0x3ff00000;

// 0x3fe00000 = 1071644672 => 0 01111111110 00000000000000000000 => biased exponent: 1022 = -1+1023 => 2^-1
var HIGH_BIASED_EXP_NEG_1 = 0x3fe00000;

// 0x20000000 = 536870912 => 0 01000000000 00000000000000000000 => biased exponent: 512 = -511+1023
var HIGH_BIASED_EXP_NEG_512 = 0x20000000;

// 0x00080000 = 524288 => 0 00000000000 10000000000000000000
var HIGH_SIGNIFICAND_HALF = 0x00080000;

// 0x4090cc00 = 1083231232 => 0 10000001001 00001100110000000000
var HIGH_1075 = 0x4090cc00;

// 0xc090cc00 = 3230714880 => 1 10000001001 00001100110000000000
var HIGH_NEG_1075 = 0xc090cc00;

// FIXME: constant
var BIAS = 1023; // 0x3ff
var HIGH_NUM_NONSIGN_BITS = 31;
var HIGH_NUM_SIGNIFICAND_BITS = 20;

var HUGE = 1.0e300;
var TINY = 1.0e-300;
var TWO53 = 9007199254740992.0;	// 0x43400000, 0x00000000

// 1/LN2
var INV_LN2 = 1.44269504088896338700e+00; // 0x3FF71547, 0x652B82FE

// High (24 bits): 1/LN2
var INV_LN2_HI = 1.44269502162933349609e+00; // 0x3FF71547, 0x60000000

// Low: 1/LN2
var INV_LN2_LO = 1.92596299112661746887e-08; // 0x3E54AE0B, 0xF85DDF44

// 2/(3*LN2)
var CP = 9.61796693925975554329e-01; // 0x3FEEC709, 0xDC3A03FD

// (float)CP
var CP_HI = 9.61796700954437255859e-01; // 0x3FEEC709, 0xE0000000

// Low: CP_HI
var CP_LO = -7.02846165095275826516e-09; // 0xBE3E2FE0, 0x145B01F5

// High: LN2
var LN2_HI = 6.93147182464599609375e-01; // 0x3FE62E43, 0x00000000

// Low: LN2
var LN2_LO = -1.90465429995776804525e-09; // 0xBE205C61, 0x0CA86C39

var BP = [
	1.0,
	1.5
];
var DP_HI = [
	0.0,
	5.84962487220764160156e-01 // 0x3FE2B803, 0x40000000
];
var DP_LO = [
	0.0,
	1.35003920212974897128e-08 // 0x3E4CFDEB, 0x43CFD006
];

// -(1024-log2(ovfl+.5ulp))
var OVT = 8.0085662595372944372e-17;

// Polynomial coefficients for `x - x^2/2 + x^3/3 - x^4/4`...
var W = [
	0.5,
	-0.3333333333333333333333,
	0.25
];

// Polynomial coefficients for `(3/2)*(log(x)-2s-2/3*s^3)`...
var L = [
	5.99999999999994648725e-01, // 0x3FE33333, 0x33333303
	4.28571428578550184252e-01, // 0x3FDB6DB6, 0xDB6FABFF
	3.33333329818377432918e-01, // 0x3FD55555, 0x518F264D
	2.72728123808534006489e-01, // 0x3FD17460, 0xA91D4101
	2.30660745775561754067e-01, // 0x3FCD864A, 0x93C9DB65
	2.06975017800338417784e-01  // 0x3FCA7E28, 0x4A454EEF
];

var P = [
	1.66666666666666019037e-01,  // 0x3FC55555, 0x5555553E
	-2.77777777770155933842e-03, // 0xBF66C16C, 0x16BEBD93
	6.61375632143793436117e-05,  // 0x3F11566A, 0xAF25DE2C
	-1.65339022054652515390e-06, // 0xBEBBBD41, 0xC5D26BF1
	4.13813679705723846039e-08   // 0x3E663769, 0x72BEA4D0
];


// FUNCTIONS //

// Compile functions for evaluating polynomials based on the above coefficients...
var polyval_W = evalpoly( W );
var polyval_L = evalpoly( L );
var polyval_P = evalpoly( P );


// POW //

/**
* Evaluates the exponential function.
*
* #### Method
*
* 1. Let \\(x = 2^n (1+f)\\).
*
* 2. Compute \\(\operatorname{log2}(x)\\) as
*
*   ``` tex
*   \operatorname{log2}(x) = w_1 + w_2
*   ```
*
*   where \\(w_1\\) has \\(53 - 24 = 29\\) bit trailing zeros.
*
* 3. Compute
*
*   ``` tex
*   y \cdot \operatorname{log2}(x) = n + y^\prime
*   ```
*
*   by simulating multi-precision arithmetic, where \\(|y^\prime| \leq 0.5\\).
*
* 4. Return
*
*   ``` tex
*   x^y = 2^n e^{y^\prime \cdot \mathrm{log2}}
*   ```
*
* #### Special Cases
*
* ``` tex
* \begin{align*}
* x^{\mathrm{NaN}} &= \mathrm{NaN} & \\
* (\mathrm{NaN})^y &= \mathrm{NaN} & \\
* 1^y &= 1 & \\
* x^0 &= 1 & \\
* x^1 &= x & \\
* (\pm 0)^\infty &= +0 & \\
* (\pm 0)^{-\infty} &= +\infty & \\
* (+0)^y &= +0 & \mathrm{if}\ y > 0 \\
* (+0)^y &= +\infty & \mathrm{if}\ y < 0 \\
* (-0)^y &= -\infty & \mathrm{if}\ y\ \mathrm{is\ an\ odd\ integer\ and}\ y < 0 \\
* (-0)^y &= +\infty & \mathrm{if}\ y\ \mathrm{is\ not\ an\ odd\ integer\ and}\ y < 0 \\
* (-0)^y &= -0 & \mathrm{if}\ y\ \mathrm{is\ an\ odd\ integer\ and}\ y > 0 \\
* (-0)^y &= +0 & \mathrm{if}\ y\ \mathrm{is\ not\ an\ odd\ integer\ and}\ y > 0 \\
* (-1)^{\pm\infty} &= \mathrm{NaN} & \\
* x^{\infty} &= +\infty & |x| > 1 \\
* x^{\infty} &= +0 & |x| < 1 \\
* x^{-\infty} &= +0 & |x| > 1 \\
* x^{-\infty} &= +\infty & |x| < 1 \\
* (-\infty)^y &= (-0)^y & \\
* \infty^y &= +0 & y < 0 \\
* \infty^y &= +\infty & y > 0 \\
* x^y &= \mathrm{NaN} & \mathrm{if}\ y\ \mathrm{is\ not\ a\ finite\ integer\ and}\ x < 0
* \end{align*}
* ```
*
*
* #### Notes
*
* - \\(\operatorname{pow}(x,y)\\) returns \\(x^y\\) nearly rounded. In particular, \\(\operatorname{pow}(<\mathrm{integer}>,<\mathrm{integer}>)\\) __always__ returns the correct integer, provided the value is representable.
* - The hexadecimal values shown in the source code are the intended values for used constants. Decimal values may be used, provided the compiler will accurately convert decimal to binary in order to produce the hexadecimal values.
*
*
* @param {number} x - input value
* @returns {number} function value
*
* @example
* var v = pow( 2.0, 3.0 );
* // returns 8.0
* @example
* var v = pow( 4.0, 0.5 );
* // returns 2.0
* @example
* var v = pow( 100.0, 0.0 );
* // returns 1.0
* @example
* var v = pow( Math.PI, 5.0 );
* // returns ~306.0197
* @example
* var v = pow( Math.PI, -0.2 );
* // returns ~0.7954
* @example
* var v = pow( NaN, 3.0 );
* // returns NaN
* @example
* var v = pow( 5.0, NaN );
* // returns NaN
* @example
* var v = pow( NaN, NaN );
* // returns NaN
*/
function pow( x, y ) {
	var tmp;
	var ahx; // absolute value high word `x`
	var ahy; // absolute value high word `y`
	var ax;  // absolute value `x`
	var hx;  // high word `x`
	var hy;  // high word `y`
	var sx;  // sign `x`
	var sy;  // sign `y`
	var y1;
	var t1;
	var t2;
	var ss;  // `hs + ls`
	var s2;  // `ss` squared
	var hs;
	var ls;
	var ht;
	var lt;
	var bp;  // `BP` constant
	var dp;  // `DP` constant
	var hp;
	var lp;
	var hz;
	var lz;
	var r;
	var t;
	var w;
	var u;
	var v;
	var z;   // y prime
	var n;
	var j;
	var k;
	var i;
	if ( isnan( x ) || isnan( y ) ) {
		return NaN;
	}
	if ( x === 1.0 || y === 0.0 ) {
		return 1.0;
	}
	if ( y === 1.0 ) {
		return x;
	}
	// TODO: clean-up special `y` cases, including 2, 3, 4
	if ( y === -1.0 ) {
		return 1.0 / x;
	}
	if ( y === 0.5 ) {
		return sqrt( x );
	}
	if ( y === -0.5 ) {
		return 1.0 / sqrt( x );
	}
	if ( x === 0.0 ) {
		if ( y === NINF ) {
			return PINF;
		}
		if ( y === PINF ) {
			return 0.0;
		}
		if ( y > 0.0 ) {
			if ( isOdd( y ) ) {
				return x; // handles +-0
			}
			return 0.0;
		}
		// y < 0.0
		if ( isOdd( y ) ) {
			return copysign( PINF, x ); // handles +-0
		}
		return PINF;
	}
	if ( isInfinite( y ) ) {
		if ( x === -1.0 ) {
			// Julia (0.4.2) and Python (2.7.9) return `1.0` (WTF???). JavaScript (`Math.pow`), R, and libm return `NaN`. We choose `NaN`, as the value is indeterminate; i.e., we cannot determine whether `y` is odd, even, or somewhere in between.
			return NaN;
		}
		// (|x| > 1 && y === NINF) || (|x| < 1 && y === PINF)
		if ( (abs(x) < 1.0) === (y === PINF) ) {
			return 0.0;
		}
		// (|x| > 1 && y === PINF) || (|x| < 1 && y === NINF)
		return PINF;
	}
	if ( isInfinite( x ) ) {
		if ( x === NINF ) {
			// pow( 1/x, -y )
			return pow( -0.0, -y );
		}
		if ( y < 0.0 ) {
			return 0.0;
		}
		return PINF;
	}
	if (
		x < 0.0 &&
		isInteger( y ) === false
	) {
		return NaN;
	}
	if ( y === 2.0 ) {
		return x * x;
	}
	if ( y === 3.0 ) {
		return x * x * x;
	}
	if ( y === 4.0 ) {
		x *= x;
		return x * x;
	}
	ax = abs( x );

	// Extract the high words from `x` and `y`:
	hx = getHighWord( x );
	hy = getHighWord( y );

	// Remove the sign bits (i.e., get absolute values):
	ahx = (hx & ABS_MASK);
	ahy = (hy & ABS_MASK);

	// Extract the sign bits:
	sx = (hx >>> HIGH_NUM_NONSIGN_BITS);
	sy = (hy >>> HIGH_NUM_NONSIGN_BITS);

	// Determine the sign of the result...
	if ( sx && isOdd( y ) ) {
		sx = -1.0;
	} else {
		sx = 1.0;
	}
	// Case 1: `|y|` is huge...

	// |y| > 2^31
	if ( ahy > HIGH_BIASED_EXP_31 ) {
		// `|y| > 2^64`, then must over- or underflow...
		if ( ahy > HIGH_BIASED_EXP_64 ) {
			if ( ahx <= HIGH_MAX_NEAR_UNITY ) {
				// y < 0
				if ( sy === 1 ) {
					// signal overflow...
					return HUGE * HUGE;
				}
				// signal underflow...
				return TINY * TINY;
			}
			// ahx >= HIGH_BIASED_EXP_0

			// y > 0
			if ( sy === 0 ) {
				// signal overflow...
				return HUGE * HUGE;
			}
			// signal underflow...
			return TINY * TINY;
		}
		// Over- or underflow if `x` is not close to unity...

		if ( ahx < HIGH_MAX_NEAR_UNITY ) {
			// y < 0
			if ( sy === 1 ) {
				// signal overflow...
				return sx * HUGE * HUGE;
			}
			// signal underflow...
			return sx * TINY * TINY;
		}
		if ( ahx > HIGH_BIASED_EXP_0 ) {
			// y > 0
			if ( sy === 0 ) {
				// signal overflow...
				return sx * HUGE * HUGE;
			}
			// signal underflow...
			return sx * TINY * TINY;
		}
		// At this point, `|1-x|` is tiny (`<= 2^-20`). Suffice to compute `log(x)` by `x - x^2/2 + x^3/3 - x^4/4`.

		t = ax - 1.0; // `t` has `20` trailing zeros
		w = t * t * polyval_W( t );
		u = INV_LN2_HI * t; // `INV_LN2_HI` has `21` significant bits
		v = t*INV_LN2_LO - w*INV_LN2;
		t1 = u + v;
		t1 = setLowWord( t1, 0 );
		t2 = v - (t1 - u);
	}
	// Case 2: `|y|` is not huge...
	else {
		n = 0;

		// Check if `x` is subnormal...
		if ( ahx < HIGH_MIN_NORMAL_EXP ) {
			ax *= TWO53;
			n -= 53;
			ahx = getHighWord( ax );
		}
		// Extract the unbiased exponent of `x`:
		n += (ahx >> HIGH_NUM_SIGNIFICAND_BITS) - BIAS;

		// Isolate the significand bits of `x`:
		j = (ahx & HIGH_SIGNIFICAND_MASK);

		// Normalize `ahx` by setting the (biased) exponent to `1023`:
		ahx = (j | HIGH_BIASED_EXP_0);

		// Determine the interval of `|x|` by comparing significand bits...

		// |x| < sqrt(3/2)
		if ( j <= 0x3988E ) { // 0 00000000000 00111001100010001110
			k = 0;
		}
		// |x| < sqrt(3)
		else if ( j < 0xBB67A ) { // 0 00000000000 10111011011001111010
			k = 1;
		}
		// |x| >= sqrt(3)
		else {
			k = 0;
			n += 1;
			ahx -= HIGH_MIN_NORMAL_EXP;
		}
		// Load the normalized high word into `|x|`:
		ax = setHighWord( ax, ahx );

		// Compute `ss = hs + ls = (x-1)/(x+1)` or `(x-1.5)/(x+1.5)`:
		bp = BP[ k ]; // BP[0] = 1.0, BP[1] = 1.5
		u = ax - bp; // (x-1) || (x-1.5)
		v = 1.0 / (ax + bp); // 1/(x+1) || 1/(x+1.5)
		ss = u * v;
		hs = setLowWord( ss, 0 ); // set all low word (less significant significand) bits to 0s

		// Compute `ht = ax + bp` (via manipulation, i.e., bit flipping, of the high word):
		tmp = ((ahx>>1) | HIGH_BIASED_EXP_NEG_512) + HIGH_SIGNIFICAND_HALF + (k << 18); // `(k<<18)` can be considered the word equivalent of `1.0` or `1.5`
		ht = setHighWord( 0.0, tmp );
		lt = ax - (ht - bp);
		ls = v * ((u-hs*ht) - hs*lt);

		// Compute `log(ax)`...

		s2 = ss * ss;
		r = s2 * s2 * polyval_L( s2 );
		r += ls * (hs + ss);
		s2 = hs * hs;
		ht = 3.0 + s2 + r;
		ht = setLowWord( ht, 0 );
		lt = r - ((ht-3.0) - s2);

		// u+v = ss*(1+...):
		u = hs * ht;
		v = ls*ht + lt*ss;

		// 2/(3LN2) * (ss+...):
		hp = u + v;
		hp = setLowWord( hp, 0 );
		lp = v - (hp - u);
		hz = CP_HI * hp; // CP_HI+CP_LO = 2/(3*LN2)
		lz = CP_LO*hp + lp*CP + DP_LO[ k ];

		// log2(ax) = (ss+...)*2/(3*LN2) = n + dp + hz + lz
		dp = DP_HI[ k ];
		t = n;
		t1 = ((hz+lz) + dp) + t; // log2(ax)
		t1 = setLowWord( t1, 0 );
		t2 = lz - (((t1-t) - dp) - hz);
	}
	// Split `y` into `y1 + y2` and compute `(y1+y2) * (t1+t2)`...
	y1 = setLowWord( y, 0 );
	lp = (y-y1)*t1 + y*t2;
	hp = y1 * t1;
	z = lp + hp;
	j = getHighWord( z );
	i = getLowWord( z );
	// console.log( vars() ); // TODO: remove

	// z >= 1024
	if ( j >= HIGH_BIASED_EXP_10 ) {
		// z > 1024
		if ( ((j-HIGH_BIASED_EXP_10)|i) !== 0 ) {
			// signal overflow...
			return sx * HUGE * HUGE;
		}
		else if ( (lp+OVT) > (z-hp) ) {
			// signal overflow...
			return sx * HUGE * HUGE;
		}
	}
	// z <= -1075
	else if ( (j&ABS_MASK) >= HIGH_1075 ) {
		// z < -1075
		if ( ((j-HIGH_NEG_1075)|i) !== 0 ) {
			// signal underflow...
			return sx * TINY * TINY;
		}
		else if ( lp <= (z-hp) ) {
			// signal underflow...
			return sx * TINY * TINY;
		}
	}
	// Compute `2^(hp+lp)`...

	i = (j & ABS_MASK);
	k = (i>>HIGH_NUM_SIGNIFICAND_BITS) - BIAS;
	n = 0;

	// `|z| > 0.5`, set `n = z+0.5`
	if ( i > HIGH_BIASED_EXP_NEG_1 ) {
		n = j + (HIGH_MIN_NORMAL_EXP>>(k+1));
		k = ((n & ABS_MASK)>>HIGH_NUM_SIGNIFICAND_BITS) - BIAS; // new k for n
		tmp = ((n & ~(HIGH_SIGNIFICAND_MASK >> k)));
		t = setHighWord( 0.0, tmp );
		n = ((n & HIGH_SIGNIFICAND_MASK)|HIGH_MIN_NORMAL_EXP) >> (HIGH_NUM_SIGNIFICAND_BITS-k);
		if ( j < 0 ) {
			n = -n;
		}
		hp -= t;
	}
	t = lp + hp;
	t = setLowWord( t, 0 );
	u = t * LN2_HI;
	v = (lp - (t-hp))*LN2 + t*LN2_LO;
	z = u + v;
	w = v - (z - u);
	t = z * z;
	t1 = z - t*polyval_P( t );
	r = (z*t1)/(t1-2.0) - (w + z*w);
	z = 1.0 - (r - z);
	j = getHighWord( z );
	j += ( n << HIGH_NUM_SIGNIFICAND_BITS );

	// Check for subnormal output...
	if ( (j>>HIGH_NUM_SIGNIFICAND_BITS) <= 0 ) {
		// z = ldexp( z, n ); // TODO: use `scalbn` implementation
	} else {
		z = setHighWord( z, j );
	}
	return sx * z;

	// TODO: remove
	function vars() {
		return {
			'tmp': tmp,
			'ahx': ahx,
			'ahy': ahy,
			'ax': ax,
			'hx': hx,
			'hy': hy,
			'sx': sx,
			'sy': sy,
			'y1': y1,
			't1': t1,
			't2': t2,
			'ss': ss,
			's2': s2,
			'hs': hs,
			'ls': ls,
			'ht': ht,
			'lt': lt,
			'bp': bp,
			'dp': dp,
			'hp': hp,
			'lp': lp,
			'hz': hz,
			'lz': lz,
			'r': r,
			't': t,
			'w': w,
			'u': u,
			'v': v,
			'z': z,
			'n': n,
			'j': j,
			'k': k,
			'i': i,
			'x': x,
			'y': y
		};
	}
} // end FUNCTION pow()


// EXPORTS //

module.exports = pow;
