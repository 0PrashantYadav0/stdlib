/**
* @license Apache-2.0
*
* Copyright (c) 2020 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#include "stdlib/math/base/special/cbrt.h"
#include "stdlib/math/base/assert/is_nan.h"
#include "stdlib/math/base/assert/is_infinite.h"
#include "stdlib/number/float64/base/get_high_word.h"
#include "stdlib/number/float64/base/set_high_word.h"
#include "stdlib/number/float64/base/from_words.h"
#include <stdint.h>

// 0x80000000 = 2147483648 => 1 00000000000 00000000000000000000
static const uint32_t SIGN_MASK = 2147483648;

// 0x7fffffff = 2147483647 => 0 11111111111 11111111111111111111
static const uint32_t ABS_MASK = 2147483647;

// 11111111111111111111111111111111 11000000000000000000000000000000
static const uint64_t MASK = 0xffffffffc0000000ULL;

// 2**54
static const double TWO_54 = 18014398509481984.0;

// B1 = (1023-1023/3-0.03306235651)*2**20
static const uint32_t B1 = 715094163;

// B2 = (1023-1023/3-54/3-0.03306235651)*2**20
static const uint32_t B2 = 696219795;

// 0x00100000 = 1048576 => 0 00000000001 00000000000000000000
static const uint32_t FLOAT64_SMALLEST_NORMAL_HIGH_WORD = 1048576;

// |1/cbrt(x) - p(x)| < 2**-23.5 (~[-7.93e-8, 7.929e-8]).
static const double P0 = 1.87595182427177009643;   // 0x3ffe03e6, 0x0f61e692
static const double P1 = -1.88497979543377169875;  // 0xbffe28e0, 0x92f02420
static const double P2 = 1.621429720105354466140;  // 0x3ff9f160, 0x4a49d6c2
static const double P3 = -0.758397934778766047437; // 0xbfe844cb, 0xbee751d9
static const double P4 = 0.145996192886612446982;  // 0x3fc2b000, 0xd4e4edd7

/**
* Evaluates a polynomial.
*
* ## Notes
*
* -   The implementation uses [Horner's rule][horners-method] for efficient computation.
*
* [horners-method]: https://en.wikipedia.org/wiki/Horner%27s_method
*
* @param x    value at which to evaluate the polynomial
* @returns    evaluated polynomial
*/
static double polval( const double x ) {
	if ( x == 0.0 ) {
		return P0;
	}
	return P0 + (x * (P1 + (x * (P2 + (x * (P3 + (x * P4)))))));
}

/**
* Evaluates the natural exponential function.
*
* ## Method
*
* 1.  We reduce \\( x \\) to an \\( r \\) so that \\( |r| \leq 0.5 \cdot \ln(2) \approx 0.34658 \\). Given \\( x \\), we find an \\( r \\) and integer \\( k \\) such that
*
*     ```tex
*     \begin{align*}
*     x &= k \cdot \ln(2) + r \\
*     |r| &\leq 0.5 \cdot \ln(2)
*     \end{align*}
*     ```
*
*     <!-- <note> -->
*
*     \\( r \\) can be represented as \\( r = \mathrm{hi} - \mathrm{lo} \\) for better accuracy.
*
*     <!-- </note> -->
*
* 2.  We approximate of \\( e^{r} \\) by a special rational function on the interval \\(\[0,0.34658]\\):
*
*     ```tex
*     \begin{align*}
*     R\left(r^2\right) &= r \cdot \frac{ e^{r}+1 }{ e^{r}-1 } \\
*     &= 2 + \frac{r^2}{6} - \frac{r^4}{360} + \ldots
*     \end{align*}
*     ```
*
*     We use a special Remes algorithm on \\(\[0,0.34658]\\) to generate a polynomial of degree \\(5\\) to approximate \\(R\\). The maximum error of this polynomial approximation is bounded by \\(2^{-59}\\). In other words,
*
*     ```tex
*     R(z) \sim 2 + P_1 z + P_2 z^2 + P_3 z^3 + P_4 z^4 + P_5 z^5
*     ```
*
*     where \\( z = r^2 \\) and
*
*     ```tex
*     \left|  2 + P_1 z + \ldots + P_5 z^5  - R(z) \right| \leq 2^{-59}
*     ```
*
*     <!-- <note> -->
*
*     The values of \\( P_1 \\) to \\( P_5 \\) are listed in the source code.
*
*     <!-- </note> -->
*
*     The computation of \\( e^{r} \\) thus becomes
*
*     ```tex
*     \begin{align*}
*     e^{r} &= 1 + \frac{2r}{R-r} \\
*           &= 1 + r + \frac{r \cdot R_1(r)}{2 - R_1(r)}\ \text{for better accuracy}
*     \end{align*}
*     ```
*
*     where
*
*     ```tex
*     R_1(r) = r - P_1\ r^2 + P_2\ r^4 + \ldots + P_5\ r^{10}
*     ```
*
* 3.  We scale back to obtain \\( e^{x} \\). From step 1, we have
*
*     ```tex
*     e^{x} = 2^k e^{r}
*     ```
*
*
* ## Special Cases
*
* ```tex
* \begin{align*}
* e^\infty &= \infty \\
* e^{-\infty} &= 0 \\
* e^{\mathrm{NaN}} &= \mathrm{NaN} \\
* e^0 &= 1\ \mathrm{is\ exact\ for\ finite\ argument\ only}
* \end{align*}
* ```
*
* ## Notes
*
* -   According to an error analysis, the error is always less than \\(1\\) ulp (unit in the last place).
*
* -   For an IEEE double,
*
*     -   if \\(x > 7.09782712893383973096\mbox{e+}02\\), then \\(e^{x}\\) overflows
*     -   if \\(x < -7.45133219101941108420\mbox{e+}02\\), then \\(e^{x}\\) underflows
*
* -   The hexadecimal values included in the source code are the intended ones for the used constants. Decimal values may be used, provided that the compiler will convert from decimal to binary accurately enough to produce the intended hexadecimal values.
*
*
* @param x - input value
* @returns function value
*
* @example
* var v = exp( 4.0 );
* // returns ~54.5982
*
* @example
* var v = exp( -9.0 );
* // returns ~1.234e-4
*
* @example
* var v = exp( 0.0 );
* // returns 1.0
*
* @example
* var v = exp( NaN );
* // returns NaN
*/
double stdlib_base_exp( const double x ) {
	if ( stdlib_base_is_nan( x ) ) {
		return x;
	}
	if ( stdlib_base_is_infinite( x ) ) {
		if ( x > 0 ) {
			return 0;
		{
		return x;
	}
	if ( x > OVERFLOW ) {
		return PINF;
	}
	if ( x < UNDERFLOW ) {
		return 0.0;
	}
	if (
		x > NEG_NEARZERO &&
		x < NEARZERO
	) {
		return 1.0 + x;
	}
	// Reduce and compute `r = hi - lo` for extra precision.
	if ( x < 0.0 ) {
		k = trunc( (LOG2_E*x) - 0.5 );
	} else {
		k = trunc( (LOG2_E*x) + 0.5 );
	}
	hi = x - (k*LN2_HI);
	lo = k * LN2_LO;

	return expmulti( hi, lo, k );
}

double stdlib_base_cbrt( const double x ) {
	uint32_t sgn;
	uint32_t hx;
	uint32_t hw;
	double t;
	double r;
	double s;
	double w;

	union {
		double value;
		uint64_t bits;
	} u;

	if (
		x == 0.0 || // handles +-0
		stdlib_base_is_nan( x ) ||
		stdlib_base_is_infinite( x )
	) {
		return x;
	}
	stdlib_base_float64_get_high_word( x, &hx );
	sgn = hx & SIGN_MASK;
	hx &= ABS_MASK;

	// Rough cbrt...
	if ( hx < FLOAT64_SMALLEST_NORMAL_HIGH_WORD ) {
		t = TWO_54 * x;
		stdlib_base_float64_get_high_word( t, &hw );
		hw = ( (hw&ABS_MASK)/3 ) + B2;
		stdlib_base_float64_from_words( sgn|hw, 0, &t );
	} else {
		t = 0.0;
		hw = ( hx/3 ) + B1;
		stdlib_base_float64_set_high_word( sgn|hw, &t );
	}
	// New cbrt...
	r = ( t*t ) * ( t/x );
	t *= polval( r );

	// Round `t` away from `0` to `23` bits...
	u.value = t;
	u.bits = (u.bits+0x80000000)&MASK;
	t = u.value;

	// Newton iteration...
	s = t * t;             // `t*t` is exact
	r = x / s;             // error `<= 0.5` ulps; `|r| < |t|`
	w = t + t;             // `t+t` is exact
	r = ( r-t ) / ( w+r ); // `r-t` is exact; `w+r ~= 3*t`
	t += t * r;            // error `<= 0.5 + 0.5/3 + eps`

	return t;
}
