'use strict';

// MODULES //

var evalpoly = require( '@stdlib/math/base/tools/evalpoly' ).factory;
var isInfinite = require( '@stdlib/math/base/utils/is-infinite' );
var isnan = require( '@stdlib/math/base/utils/is-nan' );
var ldexp = require( '@stdlib/math/base/special/ldexp' );
var trunc = require( '@stdlib/math/base/special/truncate' );
var NINF = require( '@stdlib/math/constants/float64-ninf' );
var PINF = require( '@stdlib/math/constants/float64-pinf' );


// CONSTANTS //

var LN2HI = 6.93147180369123816490e-01;
var LN2LO = 1.90821492927058770002e-10;
var LOG2E = 1.44269504088896338700e+00;
var OVERFLOW  = 7.09782712893383973096e+02;
var UNDERFLOW = -7.45133219101941108420e+02;
var NEARZERO  = 1.0 / (1 << 28); // 2**-28;


// Polynomial coefficients

var P = [
	1.66666666666666019037e-01,  /* 0x3FC55555; 0x5555553E */
	-2.77777777770155933842e-03, /* 0xBF66C16C; 0x16BEBD93 */
	6.61375632143793436117e-05, /* 0x3F11566A; 0xAF25DE2C */
	-1.65339022054652515390e-06,/* 0xBEBBBD41; 0xC5D26BF1 */
	4.13813679705723846039e-08 /* 0x3E663769; 0x72BEA4D0 */
];


// FUNCTIONS //

// Compile functions for evaluating polynomials based on the above coefficients...

var polyval_P = evalpoly( P );


// EXP //

/*
* Copyright 2009 The Go Authors. All rights reserved.
* Use of this source code is governed by a BSD-style
* license that can be found in the LICENSE file.
*/

/*
* The original C code, the long comment, and the constants
* below are from FreeBSD's /usr/src/lib/msun/src/e_exp.c
* and came with this notice.  The go code is a simplified
* version of the original C.
*
* ====================================================
* Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.
*
* Permission to use, copy, modify, and distribute this
* software is freely granted, provided that this notice
* is preserved.
* ====================================================
*
*/

/**
* Evaluates the natural exponential function.
*
* #### Method
* 1. Argument reduction: Reduce \\( x \\) to an \\( r \\) so that \\( |r| <= 0.5 \; \ln2 \approx 0.34658 \\).
* Given \\( x \\), find \\( r \\) and integer \\( k \\) such that
*
*   ``` tex
*   x = k*\ln2 + r,  |r| \le 0.5 \times \ln2.
*   ```
*
* Here \\( r \\) will be represented as \\( r = hi - lo \\) for better
* accuracy.
* 2. Approximation of \\( \exp(r) \\) by a special rational function on
* the interval [0,0.34658]:
* Write
*
*   ``` tex
*   R\left(r^2\right) = r \times \tfrac{ \exp(r)+1 }{ \exp(r)-1 } = 2 + \tfrac{r^2}{6} - \tfrac{r^4}{360} + \ldots
*   ```
*
* We use a special Remes algorithm on [0,0.34658] to generate
* a polynomial of degree 5 to approximate R. The maximum error
* of this polynomial approximation is bounded by 2**-59. In
* other words,
*
*   ``` tex
*   R(z) \sim 2.0 + P_1 \times z + P_2 \times z^2 + P_3 \times z^3 + P_4 \times z^4 + P_5 \times z^5
*   ```
* (where \\( z=r*r \\), and the values of \\( P_1 \\) to \\( P_5 \\) are listed below)
* and
*
*   ``` tex
*   \left|  2.0 + P_1 \times z + \ldots + P_5 \times z^5  - R(z) \right| \le 2^{-59}
*   ```
*
* The computation of \\( \exp(r) \\) thus becomes
*
*   ``` tex
*   \begin{align*}
*   \exp(r) &= 1 + \frac{2r}{R-r} \\
*           &= 1 + r + \frac{r \times R_1(r)}{2-R_1(r)}\ \text{for better accuracy},
*   \end{align*}
*   ```
*
* where
*
*   ``` tex
*   R_1(r) = r - ( P_1\ r^2 + P_2\ r^4 + \ldots + P_5\ r^{10}
*   ```
*
* 3. Scale back to obtain \\( exp(x) \\):
* From step 1, we have \\( \exp(x) = 2^k \times \exp(r) \\).
*
* #### Special Cases
*
* ``` tex
* \begin{align*}
* e^\infty &= \infty \\
* e^{-\infty} &= 0 \\
* e^{\mathrm{NaN}} &= \mathrm{NaN} \\
* \mathrm{for\ finite\ argument,\ only\}\ e^0 &= 1\ \mathrm{is\ exact\}
* \end{align*}
* ```
*
* #### Notes
* - Accuracy: according to an error analysis, the error is always less than 1 ulp (unit in the last place).
* - Misc. info.
* 	For IEEE double
* 		if x >  7.09782712893383973096e+02 then exp(x) overflow
* 		if x < -7.45133219101941108420e+02 then exp(x) underflow
* - Constants:
* 	The hexadecimal values are the intended ones for the following
* 	constants. The decimal values may be used, provided that the
* 	compiler will convert from decimal to binary accurately enough
* 	to produce the hexadecimal values shown.
*
* @param {number} x - input value
* @returns {number} function value
*
* @example
* var v = exp( 4.0 );
* // returns ~54.5982
* @example
* var v = exp( -9.0 );
* // returns ~1.234e-4
* @example
* var v = exp( 0.0 );
* // returns 1.0
* @example
* var v = exp( NaN );
* // returns NaN
*/
function exp( x ) {
	if ( isnan( x ) || isInfinite( x ) ) {
		return x;
	}
	if ( x === NINF ) {
		return 0;
	}
	if ( x > OVERFLOW ) {
		return PINF;
	}
	if ( x < UNDERFLOW ) {
		return 0;
	}
	if ( -NEARZERO < x && x < NEARZERO ) {
		return 1 + x;
	}
	// Reduce; computed as r = hi - lo for extra precision.
	var hi;
	var lo;
	var k;

	if ( x < 0 ) {
		k = trunc( LOG2E * x - 0.5 );
	} else {
		// Case: x > 0
		k = trunc( LOG2E * x + 0.5 );
	}
	hi = x - k * LN2HI;
	lo = k * LN2LO;

	return expmulti( hi, lo, k );
} // end FUNCTION exp()


// EXPMULTI //

/**
* Computes e**r × 2**k where r = hi - lo and |r| ≤ ln(2)/2.
*
* @private
* @param {number} hi - upper bound
* @param {number} lo - lower bound
* @param {number} k - power of 2
* @returns {number} function value
*/
function expmulti( hi, lo, k ) {
	var r;
	var t;
	var c;
	var y;

	r = hi - lo;
	t = r * r;
	c = r - t * polyval_P( t );
	y = 1 - ( ( lo - (r*c)/(2-c) ) - hi );

	return ldexp( y, k );
} // end FUNCTION expmulti()


// EXPORTS //

module.exports = exp;
