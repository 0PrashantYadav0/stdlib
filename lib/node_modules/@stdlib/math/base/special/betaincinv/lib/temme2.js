/* eslint-disable max-statements */
'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/special_functions/detail/ibeta_inverse.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright John Maddock 2006.
* Copyright Paul A. Bristow 2007.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var evalpoly = require( '@stdlib/math/base/tools/evalpoly' );
var erfcinv = require( '@stdlib/math/base/special/erfcinv' );
var abs = require( '@stdlib/math/base/special/abs' );
var exp = require( '@stdlib/math/base/special/exp' );
var ln = require( '@stdlib/math/base/special/ln' );
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var sin = require( '@stdlib/math/base/special/sin' );
var cos = require( '@stdlib/math/base/special/cos' );
var temmeRootFinder = require( './root_finder.js');
var newtonRaphsonIterate = require( './newton_raphson.js' );


// VARIABLES //

var co1 = [ -1, -5, 5 ];
var co2 = [ 1, 21, -69, 46 ];
var co3 = [ 7, -2, 33, -62, 31 ];
var co4 = [ 25, -52, -17, 88, -115, 46 ];
var co5 = [ 7, 12, -78, 52 ];
var co6 = [ -7, 2, 183, -370, 185 ];
var co7 = [ -533, 776, -1835, 10240, -13525, 5410 ];
var co8 = [ -1579, 3747, -3372, -15821, 45588, -45213, 15071 ];
var co9 = [ 449, -1259, -769, 6686, -9260, 3704 ];
var co10 = [ 63149, -151557, 140052, -727469, 2239932, -2251437, 750479 ];
var co11 = [
	29233, -78755, 105222, 146879, -1602610, 3195183, -2554139, 729754
];
var co12 = [ 1, -13, 13 ];
var co13 = [ 1, 21, -69, 46 ];
var terms = [ 0.0, 0.0, 0.0, 0.0 ];


// MAIN //

/**
* Carries out the second method by Temme.
*
* #### References
*
* - "Asymptotic Inversion of the Incomplete Beta Function", N.M. Temme, Journal of Computation and Applied Mathematics 41 (1992) 145-157, Section 3.
*
* @private
* @param {number} z - function parameter
* @param {number} r - function parameter
* @param {number} theta - function parameter
* @returns {number} function value
*/
function temme2( z, r, theta ) {
	var workspace;
	var upper;
	var lower;
	var alpha;
	var eta0;
	var eta;
	var sc7;
	var sc6;
	var sc5;
	var sc4;
	var sc3;
	var sc2;
	var sc;
	var lu;
	var s2;
	var c2;
	var c;
	var s;
	var u;
	var x;

	// Get first estimate for eta, see Eq 3.9 and 3.10, but note there is a typo in Eq 3.10:
	eta0 = erfcinv( 2.0 * z );
	eta0 /= -sqrt( r / 2.0 );

	s = sin( theta );
	c = cos( theta );
	// Now we need to perturb eta0 to get eta, which we do by evaluating the polynomial in 1/r at the bottom of page 151, to do this we first need the error terms e1, e2 e3 which we'll fill into the array "terms".  Since these terms are themselves polynomials, we'll need another array "workspace" to calculate those...
	terms[0] = eta0;
	workspace = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ];

	// Some powers of sin(theta) cos(theta) that we'll need later:
	sc = s * c;
	sc2 = sc * sc;
	sc3 = sc2 * sc;
	sc4 = sc2 * sc2;
	sc5 = sc2 * sc3;
	sc6 = sc3 * sc3;
	sc7 = sc4 * sc3;

	// Calculate e1 and put it in terms[1], see the middle of page 151:
	workspace[0] = ( (2.0*s*s) - 1.0 ) / ( 3.0 * s * c );
	workspace[1] = -evalpoly( co1, s*s ) / (36 * sc2);
	workspace[2] = evalpoly( co2, s*s ) / (1620 * sc3);
	workspace[3] = evalpoly( co3, s*s ) / (6480 * sc4);
	workspace[4] = evalpoly( co4, s*s ) / (90720 * sc5);
	terms[1] = evalpoly( workspace, eta0 );

	// Now evaluate e2 and put it in terms[2]:
	workspace[0] = -evalpoly( co5, s*s, 4 ) / (405 * sc3);
	workspace[1] = evalpoly( co6, s*s, 5 ) / (2592 * sc4);
	workspace[2] = -evalpoly( co7, s*s, 6 ) / (204120 * sc5);
	workspace[3] = -evalpoly( co8, s*s, 7 ) / (2099520 * sc6);
	terms[2] = evalpoly( workspace, eta0, 4 );

	// And e3, and put it in terms[3]:
	workspace[0] = evalpoly( co9, s*s ) / (102060 * sc5);
	workspace[1] = -evalpoly( co10, s*s ) / (20995200 * sc6);
	workspace[2] = evalpoly( co11, s*s ) / (36741600 * sc7);
	terms[3] = evalpoly( workspace, eta0 );

	// Bring the correction terms together to evaluate eta; this is the last equation on page 151:
	eta = evalpoly( terms, 1.0/r );
	// Now that we have eta we need to back solve for x, we seek the value of x that gives eta in Eq 3.2. The two methods used are described in section 5. Begin by defining a few variables we'll need later:
	s2 = s * s;
	c2 = c * c;
	alpha = c / s;
	alpha *= alpha;
	lu = ( -( eta*eta ) / ( 2.0*s2 ) ) + ln(s2) + ( c2 * ln(c2) / s2 );
	// Temme doesn't specify what value to switch on here, but this seems to work pretty well:
	if ( abs(eta) < 0.7 ) {
		// Small eta use the expansion Temme gives in the second equation of section 5, it's a polynomial in eta:
		workspace[0] = s * s;
		workspace[1] = s * c;
		workspace[2] = ( 1.0 - ( 2.0 * workspace[0] ) ) / 3.0;
		workspace[3] = evalpoly( co12, workspace[0] ) / ( 36.0 * s * c );
		workspace[4] = evalpoly( co13, workspace[0] ) /
			( 270.0 * workspace[0] * c * c );
		x = evalpoly( workspace, eta );
	} else {
		// If eta is large we need to solve Eq 3.2 more directly, begin by getting an initial approximation for x from the last equation on page 155, this is a polynomial in u:
		u = exp( lu );
		workspace[0] = u;
		workspace[1] = alpha;
		workspace[2] = 0;
		workspace[3] = 3 * alpha * ((3*alpha) + 1) / 6;
		workspace[4] = 4 * alpha * ((4*alpha) + 1) * ((4*alpha) + 2) / 24;
		workspace[5] = 5 * alpha * ((5*alpha) + 1) * ((5*alpha) + 2) *
			( (5*alpha) + 3) / 120;
		x = evalpoly( workspace, u );
		// At this point we may or may not have the right answer, Eq-3.2 has two solutions for x for any given eta, however the mapping in 3.2 is 1:1 with the sign of eta and x-sin^2(theta) being the same. So we can check if we have the right root of 3.2, and if not switch x for 1-x.  This transformation is motivated by the fact that the distribution is *almost* symmetric so 1-x will be in the right ball park for the solution:
		if ( ( x - s2 ) * eta < 0.0 ) {
			x = 1.0 - x;
		}
	}
	// The final step is a few Newton-Raphson iterations to clean up our approximation for x, this is pretty cheap in general, and very cheap compared to an incomplete beta evaluation. The limits set on x come from the observation that the sign of eta and x-sin^2(theta) are the same.
	if ( eta < 0.0 ) {
		lower = 0.0;
		upper = s2;
	} else {
		lower = s2;
		upper = 1.0;
	}
	// If our initial approximation is out of bounds then bisect:
	if ( x < lower || x > upper ) {
		x = ( lower + upper ) / 2;
	}
	// And iterate:
	x = newtonRaphsonIterate(
		temmeRootFinder( -lu, alpha ), x, lower, upper, 32, 100
	);
	return x;
} // end FUNCTION temme2()


// EXPORTS //

module.exports = temme2;
