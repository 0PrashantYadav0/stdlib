'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/special_functions/detail/ibeta_inverse.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright John Maddock 2006.
* Copyright Paul A. Bristow 2007.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var betainc = require( '@stdlib/math/base/special/betainc/lib/ibeta_imp.js' );
var abs = require( '@stdlib/math/base/special/abs');


// IBETA ROOTS //

function ibeta_roots( a, b, target, invert ) {
	invert = invert || false;

	return function roots( x ) {
		var f1p;
		var f1;
		var f2;
		var f;
		var y;

		y = 1.0 - x;
		f1p = {};
		f = betainc( a, b, x, invert, true, f1p ) - target;
		f1 = f1p.value;
		if ( invert ) {
			f1 = -f1;
		}
		if ( y === 0.0 ) {
			y = Number.MIN_VALUE * 64.0;
		}
		if ( x === 0.0 ) {
			x = Number.MIN_VALUE * 64.0;
		}

		f2 = f1 * ( -y * a + (b - 2.0) * x + 1.0 );
		if ( abs( f2 ) < y * x * Number.MAX_VALUE ) {
			f2 /= (y * x);
		}
		if ( invert ) {
			f2 = -f2;
		}
		// Make sure we don't have a zero derivative:
		if ( f1 === 0.0 ) {
			f1 = (invert ? -1.0 : 1.0) * Number.MIN_VALUE * 64.0;
		}
		return [ f, f1, f2 ];
	};
} // end FUNCTION ibeta_roots()


// EXPORTS //

module.exports = ibeta_roots;
