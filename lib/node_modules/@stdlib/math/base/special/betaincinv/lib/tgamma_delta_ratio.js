'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/special_functions/gamma.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright John Maddock 2006-7, 2013-14.
* Copyright Paul A. Bristow 2007, 2013-14.
* Copyright Nikhar Agrawal 2013-14
* Copyright Christopher Kormanyos 2013-14
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var evalrational = require( '@stdlib/math/base/tools/evalrational' ).factory;
var factorial = require( '@stdlib/math/base/special/factorial' );
var floor = require( '@stdlib/math/base/special/floor' );
var gamma = require( '@stdlib/math/base/special/gamma' );
var log1p = require( '@stdlib/math/base/special/log1p' );
var abs = require( '@stdlib/math/base/special/abs' );
var exp = require( '@stdlib/math/base/special/exp' );
var pow = require( '@stdlib/math/base/special/pow' );
var EPSILON = require( '@stdlib/math/constants/float64-eps' );
var E = require( '@stdlib/math/constants/float64-e' );


// VARIABLES //

var MAX_FACTORIAL = 170;
var G = 10.90051099999999983936049829935654997826;
var NUM = [
	38474670393.31776828316099004518914832218,
	36857665043.51950660081971227404959150474,
	15889202453.72942008945006665994637853242,
	4059208354.298834770194507810788393801607,
	680547661.1834733286087695557084801366446,
	78239755.00312005289816041245285376206263,
	6246580.776401795264013335510453568106366,
	341986.3488721347032223777872763188768288,
	12287.19451182455120096222044424100527629,
	261.6140441641668190791708576058805625502,
	2.506628274631000502415573855452633787834
];
var DENOM = [
	0,
	362880,
	1026576,
	1172700,
	723680,
	269325,
	63273,
	9450,
	870,
	45,
	1
];


// FUNCTIONS //

/**
* Calculate the Lanczos sum approximation.
*
* @private
* @param {number} z - input value
* @returns {number} Lanczos approximation
*/
var lanczosSum = evalrational( NUM, DENOM );

/**
* Calculates the ratio of two gamma functions via Lanczos approximation.
*
* #### Notes
*
* When \\( z < \epsilon \\), we get spurious numeric overflow unless we're very careful, this can occur either inside lanczosSum(z) or in the final combination of terms, to avoid this, split the product up into 2 (or 3) parts:
*
*   ``` tex
*    G(z) / G(L) = 1 / (z \cdot G(L)) ; z < \eps, L = z + \delta = \delta \\
*    z * G(L) = z * G(lim) \cdot (G(L)/G(lim)) ; lim = \text{largest factorial}
*   ````
*
* @private
* @param {number} z - input value
* @param {number} delta - difference
* @returns {number} gamma ratio
*/
function tgammaDeltaRatioImpLanczos( z, delta ) {
	var result;
	var ratio;
	var zgh;
	if ( z < EPSILON ) {
		if ( MAX_FACTORIAL < delta ) {
			ratio = tgammaDeltaRatioImpLanczos( delta, MAX_FACTORIAL - delta );
			ratio *= z;
			ratio *= factorial( MAX_FACTORIAL - 1 );
			return 1.0 / ratio;
		}
		return 1.0 / ( z * gamma( z + delta ) );
	}
	zgh = z + G - 0.5;
	if ( abs(delta) < 10 ) {
		result = exp( ( 0.5 - z ) * log1p( delta / zgh ));
	} else {
		result = pow( zgh / (zgh + delta), z - 0.5 );
	}
	// Split the calculation up to avoid spurious overflow:
	result *= lanczosSum( z ) / lanczosSum( z + delta );
	result *= pow( E / ( zgh + delta ), delta );
	return result;
} // end FUNCTION tgammaDeltaRatioImpLanczos()

/**
* Calculates the ratio of two gamma functions.
*
* @private
* @param {number} z - input value
* @param {number} delta - difference
* @returns {number} gamma ratio
*/
function tgammaDeltaRatioImp( z, delta ) {
	var result;

	if ( z <= 0.0 || z + delta <= 0.0 ) {
		// This isn't very sophisticated, or accurate, but it does work:
		return gamma( z ) / gamma( z + delta );
	}
	if ( floor(delta) === delta ) {
		if ( floor(z) === z ) {
			// Both z and delta are integers, see if we can just use table lookup of the factorials to get the result:
			if ( (z <= MAX_FACTORIAL ) && (z + delta <= MAX_FACTORIAL ) ) {
				return factorial( floor(z)-1 ) / factorial( floor(z+delta)-1 );
			}
		}
		if ( abs(delta) < 20 ) {
			// Delta is a small integer, we can use a finite product:
			if ( delta === 0 ) {
				return 1.0;
			}
			if ( delta < 0 ) {
				z -= 1.0;
			}
			result = z;
			// eslint-disable-next-line no-cond-assign
			while ( ( delta -= 1 ) !== 0 ) {
				z -= 1.0;
				result *= z;
			}
			return result;
		}
		// Case: abs(delta) >= 20
		result = 1.0 / z;
		// eslint-disable-next-line no-cond-assign
		while ( ( delta -= 1 ) !== 0 ) {
			z += 1;
			result /= z;
		}
		return result;
	}
	return tgammaDeltaRatioImpLanczos( z, delta );
} // end FUNCTION tgammaDeltaRatioImp()


// EXPORTS //

module.exports = tgammaDeltaRatioImp;
