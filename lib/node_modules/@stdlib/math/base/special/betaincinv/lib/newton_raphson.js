'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/tools/roots.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright John Maddock 2006.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var sign = require( '@stdlib/math/base/special/signum' );
var abs = require( '@stdlib/math/base/special/abs' );
var pow = require( '@stdlib/math/base/special/pow' );


// NEWTON RAPHSON ITERATE //

function newton_raphson_iterate( fun, guess, min, max, digits, max_iter ) {
	var last_f0;
	var delta1;
	var delta2;
	var factor;
	var result;
	var count;
	var delta;
	var res;
	var f0;
	var f1;

	f0 = 0.0;
	last_f0 = 0.0;
	result = guess;

	factor = pow( 2, 1 - digits );
	delta = 1.0;
	delta1 = Number.MAX_VALUE;
	delta2 = Number.MAX_VALUE;

	count = max_iter;

	do {
		last_f0 = f0;
		delta2 = delta1;
		delta1 = delta;
		res = fun(result);
		f0 = res[ 0 ];
		f1 = res[ 1 ];
		if ( f0 === 0.0 ) {
			break;
		}
		if ( f1 === 0.0 ) {
			// Oops zero derivative!!!
			if ( last_f0 === 0.0 ) {
				// this must be the first iteration, pretend that we had a
				// previous one at either min or max:
				if ( result === min ) {
					guess = max;
				} else {
					guess = min;
				}
				last_f0 = fun( guess );
				delta = guess - result;
			}
			if ( sign(last_f0) * sign(f0) < 0 ) {
				// We've crossed over so move in opposite direction to last step:
				if ( delta < 0 ) {
				  delta = (result - min) / 2.0;
				} else {
					delta = (result - max) / 2.0;
				}
			} else {
				// Move in same direction as last step:
				if ( delta < 0 ) {
					delta = (result - max) / 2.0;
				} else {
					delta = (result - min) / 2.0;
				}
			}
	 	} else {
			delta = f0 / f1;
		}
		if ( abs(delta * 2.0) > abs(delta2) ) {
			// Last two steps haven't converged, try bisection:
			delta = delta > 0.0 ? (result - min) / 2.0 : (result - max) / 2.0;
		}
		guess = result;
		result -= delta;
		if ( result <= min ) {
			delta = 0.5 * (guess - min);
			result = guess - delta;
			if ( result === min || result === max ) {
				break;
			}
		} else if ( result >= max ) {
			delta = 0.5 * (guess - max);
			result = guess - delta;
			if ( result === min || result === max ) {
				break;
			}
		}
		// Update brackets:
		if ( delta > 0.0 ) {
			max = guess;
		} else {
			min = guess;
		}
	}
	while ( --count && ( abs(result * factor) < abs(delta) ) );

	return result;
} // end FUNCTION newton_raphson_iterate()


// EXPORTS //

module.exports = newton_raphson_iterate;
