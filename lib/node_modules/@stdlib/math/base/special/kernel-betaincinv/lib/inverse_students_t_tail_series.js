/* eslint-disable max-len, no-mixed-operators */
'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_61_0/boost/math/special_functions/detail/t_distribution_inv.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright John Maddock 2006.
* Copyright Paul A. Bristow 2007.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var gammaDeltaRatio = require( '@stdlib/math/base/special/gamma-delta-ratio' );
var evalpoly = require( '@stdlib/math/base/tools/evalpoly' );
var sqrt = require( '@stdlib/math/base/special/sqrt');
var pow = require( '@stdlib/math/base/special/pow');
var PI = require( '@stdlib/constants/math/float64-pi' );


// VARIABLES //

// Array for the coefficients d(k), these depend only on the number of degrees of freedom df, so at least in theory we could tabulate these for fixed df, see p15 of Shaw:
var d = new Array( 7 );


// MAIN //

/**
* Evaluates Student's t quantiles via a tail series expansion. Tail and body series are due to Shaw.
*
* #### References
*
* - Shaw, William T. 2006. "Sampling Student's T distribution – use of the inverse cumulative distribution function." *Journal of Computational Finance* 9 (4): 37–73. [www.mth.kcl.ac.uk/~shaww/web\_page/papers/Tdistribution06.pdf](www.mth.kcl.ac.uk/~shaww/web_page/papers/Tdistribution06.pdf).
*
* @private
* @param {number} df - degrees of freedom
* @param {number} v - function value
* @returns {number} tail value
*/
function inverseStudentsTTailSeries( df, v ) {
	var result;
	var power;
	var div;
	var np2;
	var np4;
	var np6;
	var rn;
	var w;

	// Tail series expansion, see section 6 of Shaw's paper. `w` is calculated using Eq 60:
	w = gammaDeltaRatio( df / 2.0, 0.5 ) * sqrt( df * PI ) * v;

	// Define some variables:
	np2 = df + 2;
	np4 = df + 4;
	np6 = df + 6;

	d[ 0 ] = 1;
	d[ 1 ] = -(df + 1) / (2 * np2);
	np2 *= (df + 2);
	d[ 2 ] = -df * (df + 1) * (df + 3) / (8 * np2 * np4);
	np2 *= df + 2;
	d[ 3 ] = -df * (df + 1) * (df + 5) * (((3 * df) + 7) * df -2) / (48 * np2 * np4 * np6);
	np2 *= (df + 2);
	np4 *= (df + 4);
	d[ 4 ] = -df * (df + 1) * (df + 7) *
		( (((((15 * df) + 154) * df + 465) * df + 286) * df - 336) * df + 64 ) /
		(384 * np2 * np4 * np6 * (df + 8));
	np2 *= (df + 2);
	d[ 5 ] = -df * (df + 1) * (df + 3) * (df + 9) *
		(((((((35 * df + 452) * df + 1573) * df + 600) * df - 2020) * df) + 928) * df -128) /
		(1280 * np2 * np4 * np6 * (df + 8) * (df + 10));
	np2 *= (df + 2);
	np4 *= (df + 4);
	np6 *= (df + 6);
	d[ 6 ] = -df * (df + 1) * (df + 11) *
		((((((((((((945 * df) + 31506) * df + 425858) * df + 2980236) * df + 11266745) * df + 20675018) * df + 7747124) * df - 22574632) * df - 8565600) * df + 18108416) * df - 7099392) * df + 884736) /
		(46080 * np2 * np4 * np6 * (df + 8) * (df + 10) * (df +12));

	// Now bring everything together to provide the result this is Eq 62 of Shaw:
	rn = sqrt( df );
	div = pow( rn * w, 1 / df );
	power = div * div;
	result = evalpoly( d, power );
	result *= rn;
	result /= div;
	return -result;
} // end FUNCTION inverseStudentsTTailSeries()


// EXPORTS //

module.exports = inverseStudentsTTailSeries;
