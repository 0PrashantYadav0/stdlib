/* eslint-disable no-mixed-operators */
'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_64_0/boost/math/special_functions/detail/ibeta_inverse.hpp}.
*
* The implementation has been modified for JavaScript.
*/

/*
* Copyright John Maddock 2006.
* Copyright Paul A. Bristow 2007.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var evalpoly = require( '@stdlib/math/base/tools/evalpoly' );
var erfcinv = require( '@stdlib/math/base/special/erfcinv' );
var sqrt = require( '@stdlib/math/base/special/sqrt');
var exp = require( '@stdlib/math/base/special/exp');
var r2 = require( '@stdlib/math/constants/float64-sqrt-two' );


// VARIABLES //

// Workspaces for the polynomial coefficients:
var workspace = new Array( 7 );
var terms = new Array( 4 );


// MAIN //

/**
* Carries out the first method by Temme.
*
* #### References
*
* - "Asymptotic Inversion of the Incomplete Beta Function", N.M. Temme, Journal of Computation and Applied Mathematics 41 (1992) 145-157, Section 2.
*
* @private
* @param {PositiveNumber} a - function parameter
* @param {PositiveNumber} b - function parameter
* @param {Probability} z - function parameter
* @returns {number} function value
*/
function temme1( a, b, z ) {
	var eta0;
	var eta2;
	var eta;
	var B2;
	var B3;
	var B;
	var c;
	var x;

	// Get the first approximation for eta from the inverse error function (Eq: 2.9 and 2.10):
	eta0 = erfcinv( 2.0 * z );
	eta0 /= -sqrt( a / 2.0 );

	terms[ 0 ] = eta0;

	// Calculate powers:
	B = b - a;
	B2 = B * B;
	B3 = B2 * B;

	// Calculate correction terms:

	// See eq following 2.15:
	workspace[ 0 ] = -B * r2 / 2;
	workspace[ 1 ] = ( 1 - (2.0*B) ) / 8.0;
	workspace[ 2 ] = -(B * r2 / 48.0);
	workspace[ 3 ] = -1.0 / 192.0;
	workspace[ 4 ] = -B * r2 / 3840.0;
	workspace[ 5 ] = 0.0;
	workspace[ 6 ] = 0.0;
	terms[ 1 ] = evalpoly( workspace, eta0 );

	// Eq Following 2.17:
	workspace[ 0 ] = B * r2 * ( (3.0*B) - 2.0) / 12.0;
	workspace[ 1 ] = ( (20.0*B2) - (12.0*B) + 1.0 ) / 128.0;
	workspace[ 2 ] = B * r2 * (20 * B - 1) / 960;
	workspace[ 3 ] = (16 * B2 + 30 * B - 15) / 4608;
	workspace[ 4 ] = B * r2 * (21 * B + 32) / 53760;
	workspace[ 5 ] = (-32 * B2 + 63) / 368640;
	workspace[ 6 ] = -B * r2 * (120 * B + 17) / 25804480;
	terms[ 2 ] = evalpoly( workspace, eta0 );

	// Eq Following 2.17:
	workspace[ 0 ] = B * r2 * (-75 * B2 + 80 * B - 16) / 480;
	workspace[ 1 ] = (-1080 * B3 + 868 * B2 - 90 * B - 45) / 9216;
	workspace[ 2 ] = B * r2 * (-1190 * B2 + 84 * B + 373) / 53760;
	workspace[ 3 ] = (-2240 * B3 - 2508 * B2 + 2100 * B - 165) / 368640;
	workspace[ 4 ] = 0.0;
	workspace[ 5 ] = 0.0;
	workspace[ 6 ] = 0.0;
	terms[ 3 ] = evalpoly( workspace, eta0 );

	// Bring them together to get a final estimate for eta:
	eta = evalpoly( terms, 1.0/a );

	// Now we need to convert eta to x, by solving the appropriate quadratic equation:
	eta2 = eta * eta;
	c = -exp( -eta2 / 2.0 );
	if ( eta2 === 0.0 ) {
		x = 0.5;
	} else {
		x = ( 1.0 + ( eta * sqrt( ( 1.0+c ) / eta2 ) ) ) / 2.0;
	}
	return x;
} // end FUNCTION temme1()


// EXPORTS //

module.exports = temme1;
