'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_65_0/boost/math/special_functions/detail/polygamma.hpp}.
*
* The implementation follows the original but has been reformatted and modified for JavaScript.
*/

/*
* (C) Copyright Nikhar Agrawal 2013.
* (C) Copyright Christopher Kormanyos 2013.
* (C) Copyright John Maddock 2014.
* (C) Copyright Paul Bristow 2013.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var logger = require( 'debug' );
var evalpoly = require( '@stdlib/math/base/tools/evalpoly' );
var gammaln = require( '@stdlib/math/base/special/gammaln' );
var signum = require( '@stdlib/math/base/special/signum' );
var cospi = require( '@stdlib/math/base/special/cospi' );
var sinpi = require( '@stdlib/math/base/special/sinpi' );
var abs = require( '@stdlib/math/base/special/abs' );
var exp = require( '@stdlib/math/base/special/exp' );
var pow = require( '@stdlib/math/base/special/pow' );
var ln = require( '@stdlib/math/base/special/ln' );
var MAX_LN = require( '@stdlib/constants/math/float64-max-ln' );
var PINF = require( '@stdlib/constants/math/float64-pinf' );
var NINF = require( '@stdlib/constants/math/float64-ninf' );
var LN_PI = require( '@stdlib/constants/math/float64-ln-pi' );
var PI = require( '@stdlib/constants/math/float64-pi' );


// VARIABLES //

var debug = logger( 'polygamma' );
var MAX_SERIES_ITERATIONS = 1000000;

// Pi raised to powers two to twelve (obtained from Wolfram Alpha):
var PI2 = 9.869604401089358;
var PI3 = 31.00627668029982;
var PI4 = 97.40909103400244;
var PI5 = 306.01968478528147;
var PI6 = 961.3891935753045;
var PI7 = 3020.2932277767923;
var PI8 = 9488.531016070574;
var PI9 = 29809.09933344621;
var PI10 = 93648.04747608303;
var PI11 = 294204.0179738906;
var PI12 = 924269.1815233742;

var P3 = [ -2, -4 ];
var P4 = [ 16, 8 ];
var P5 = [ -16, -88, -16 ];
var P6 = [ 272, 416, 32 ];
var P7 = [ -272, -2880, -1824, -64 ];
var P8 = [ 7936, 24576, 7680, 128 ];
var P9 = [ -7936, -137216, -185856, -31616, -256 ];
var P10 = [ 353792, 1841152, 1304832, 128512, 512 ];
var P11 = [ -353792, -9061376, -21253376, -8728576, -518656, -1024 ];
var P12 = [ 22368256, 175627264, 222398464, 56520704, 2084864, 2048 ];

var table = [
	[ -1 ]
];


// FUNCTIONS //

var polyval3 = evalpoly.factory( P3 );
var polyval4 = evalpoly.factory( P4 );
var polyval5 = evalpoly.factory( P5 );
var polyval6 = evalpoly.factory( P6 );
var polyval7 = evalpoly.factory( P7 );
var polyval8 = evalpoly.factory( P8 );
var polyval9 = evalpoly.factory( P9 );
var polyval10 = evalpoly.factory( P10 );
var polyval11 = evalpoly.factory( P11 );
var polyval12 = evalpoly.factory( P12 );

/**
* Returns an array of zeros of the specified length.
*
* @private
* @param {NonNegativeInteger} len - array length
* @returns {Array} array of zeros
*/
function zeros( len ) {
	var out;
	var i;

	out = new Array( len );
	for ( i = 0; i < len; i++ ) {
		out[ i ] = 0.0;
	}
	return out;
} // end FUNCTION zeros()


// MAIN //

/**
* Returns n'th derivative of \\(\operatorname{cot|(\pi x)\\) at \\(x\\).
*
* ## Notes
*
* -   The derivatives are simply tabulated for up to \\(n = 9\\), beyond that it is possible to calculate coefficients as follows. The general form of each derivative is:
*
*     ```tex
*     \pi^n * \sum_{k=0}^n C[k,n] \cdot \cos^k(\pi \cdot x) \cdot \operatorname{csc}^{(n+1)}(\pi \cdot x)
*     ```
*
*     with constant \\( C\[0,1\] = -1 \\) and all other \\( C\[k,n\] = 0 \)). Then for each \\( k < n+1 \\):
*
*     ```tex
*     \begin{align}
*     C[k-1, n+1]  &-= k * C[k, n]; \\
*     C[k+1, n+1]  &+= (k-n-1) * C[k, n];
*     \end{align}
*     ```
*
* -   Note that there are many different ways of representing this derivative thanks to the many trigonometric identities available. In particular, the sum of powers of cosines could be replaced by a sum of cosine multiple angles, and, indeed, if you plug the derivative into Mathematica, this is the form it will give. The two forms are related via the Chebeshev polynomials of the first kind and \\( T_n(\cos(x)) = \cos(n x) \\). The polynomial form has the great advantage that all the cosine terms are zero at half integer arguments - right where this function has it's minimum - thus avoiding cancellation error in this region.
*
* -   And finally, since every other term in the polynomials is zero, we can save space by only storing the non-zero terms. This greatly complexifies subscripting the tables in the calculation, but halves the storage space (and complexity for that matter).
*
*
* @private
* @param {PositiveInteger} n - derivative to evaluate
* @param {number} x - input
* @param {number} xc - one minus `x`
* @returns {number} n'th derivative
*/
function polycotpi( n, x, xc ) {
	var nextMaxColumns;
	var maxCosOrder;
	var maxColumns;
	var nextOffset;
	var powTerms;
	var cosOrder;
	var sinOrder;
	var column;
	var offset;
	var index;
	var idx;
	var out;
	var sum;
	var c;
	var i;
	var s;

	s = ( abs( x ) < abs( xc ) ) ? sinpi( x ) : sinpi( xc );
	c = cospi( x );
	switch ( n ) { // eslint-disable-line default-case
	case 1:
		return -PI / ( s * s );
	case 2:
		return 2.0 * PI2 * c / pow( s, 3.0 );
	case 3:
		return PI3 * polyval3( c*c ) / pow( s, 4.0 );
	case 4:
		return PI4 * c * polyval4( c*c ) / pow( s, 5.0 );
	case 5:
		return PI5 * polyval5( c*c ) / pow( s, 6.0 );
	case 6:
		return PI6 * c * polyval6( c*c ) / pow( s, 7.0 );
	case 7:
		return PI7 * polyval7( c*c ) / pow( s, 8.0 );
	case 8:
		return PI8 * c * polyval8( c*c ) / pow( s, 9.0 );
	case 9:
		return PI9 * polyval9( c*c ) / pow( s, 10.0 );
	case 10:
		return PI10 * c * polyval10( c*c ) / pow( s, 11.0 );
	case 11:
		return PI11 * polyval11( c*c ) / pow( s, 12.0 );
	case 12:
		return PI12 * c * polyval12( c*c ) / pow( s, 13.0 );
	}
	// We'll have to compute the coefficients up to n, complexity is O(n^2) which we don't worry about as the values are computed once and then cached. However, if the final evaluation would have too many terms just bail out right away:
	if ( n / 2 > MAX_SERIES_ITERATIONS ) {
		debug( 'The value of n is so large that we\'re unable to compute the result in reasonable time.' );
		return NaN;
	}
	index = n - 1;
	if ( index >= table.length ) {
		for ( i = table.length - 1; i < index; ++i ) {
			offset = ( i & 1 ) | 0; // 1 if the first cos power is 0, otherwise 0.
			sinOrder = ( i + 2 ) | 0;  // Order of the sin term
			maxCosOrder = ( sinOrder - 1 ) | 0;  // Largest order of the polynomial of cos terms
			maxColumns = ( ( maxCosOrder - offset ) / 2 ) | 0;  // How many entries there are in the current row.
			nextOffset = offset ? 0 : 1;
			nextMaxColumns = ( ( maxCosOrder + 1 - nextOffset ) / 2 ) | 0;  // How many entries there will be in the next row
			table.push( zeros( nextMaxColumns + 1 ) );
			for ( column = 0; column <= maxColumns; ++column ) {
				cosOrder = ( ( 2*column ) + offset ) | 0;  // Order of the cosine term in entry "column"
				idx = ( ( cosOrder+1 ) / 2 ) | 0;
				table[i + 1][ idx ] += ((cosOrder - sinOrder) * table[i][column]) / (sinOrder - 1); // eslint-disable-line max-len
				if ( cosOrder ) {
					idx = ( ( cosOrder-1 ) / 2 ) | 0; //
					table[i + 1][ idx ] += (-cosOrder * table[i][column]) / (sinOrder - 1); // eslint-disable-line max-len
				}
			}
		}
	}
	sum = evalpoly( table[ index ], c*c );
	if ( index & 1 ) {
		sum *= c; // First coefficient is order 1, and really an odd polynomial.
	}
	if ( sum === 0.0 ) {
		return sum;
	}
	// The remaining terms are computed using logs since the powers and factorials get real large real quick:
	powTerms = n * LN_PI;
	if ( s === 0.0 ) {
		return ( sum >= 0 ) ? PINF : NINF;
	}
	powTerms -= ln( abs( s ) ) * ( n + 1 );
	powTerms += gammaln( n );
	powTerms += ln( abs(sum) );

	if (powTerms > MAX_LN ) {
		return ( sum >= 0 ) ? PINF : NINF;
	}
	out = exp( powTerms ) * signum( sum );
	if ( s < 0 && ( (n + 1) & 1 ) ) {
		out *= -1;
	}
	return out;
} // end FUNCTION polycotpi()


// EXPORTS //

module.exports = polycotpi;
