'use strict';

/*
* The original C++ code and copyright notice is from the [Boost library]{@link http://www.boost.org/doc/libs/1_65_0/boost/math/special_functions/detail/polygamma.hpp}.
*
* The implementation follows the original but has been reformatted and modified for JavaScript.
*/

/*
* (C) Copyright Nikhar Agrawal 2013.
* (C) Copyright Christopher Kormanyos 2013.
* (C) Copyright John Maddock 2014.
* (C) Copyright Paul Bristow 2013.
* Use, modification and distribution are subject to the
* Boost Software License, Version 1.0. (See accompanying file
* LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt)
*/

// MODULES //

var logger = require( 'debug' );
var factorial = require( '@stdlib/math/base/special/factorial' );
var zeta = require( '@stdlib/math/base/special/riemann-zeta' );
var abs = require( '@stdlib/math/base/special/abs' );
var pow = require( '@stdlib/math/base/special/pow' );
var NINF = require( '@stdlib/constants/math/float64-ninf' );
var PINF = require( '@stdlib/constants/math/float64-pinf' );
var EPS = require( '@stdlib/constants/math/float64-eps' );
var MAX = require( '@stdlib/constants/math/float64-max' );


// VARIABLES //

var debug = logger( 'polygamma' );
var MAX_SERIES_ITERATIONS = 1000000;


// MAIN //

/**
* Evaluates the polygamma function near zero.
*
* ## Notes
*
* -   If we take this [expansion][1] for `polygamma` and substitute in this [expression][2] for `polygamma(n, 1)`, we get an alternating series for polygamma when `x` is small in terms of zeta functions of integer arguments (which are easy to evaluate, at least when the integer is even).
*
* [1]: http://functions.wolfram.com/06.15.06.0003.02
* [2]: http://functions.wolfram.com/06.15.03.0009.01
*
*
* @private
* @param {PositiveInteger} n - derivative to evaluate
* @param {number} x - input value
* @returns {number} (n+1)'th derivative
*/
function nearzero( n, x ) {
	var fatorialPart;
	var prefix;
	var scale;
	var term;
	var sum;
	var AX;
	var k;

	// In order to avoid spurious overflow, save the `n!` term for later, and rescale at the end:
	scale = factorial( n );

	// "fatorialPart" contains everything except the zeta function evaluations in each term:
	fatorialPart = 1;

	// "prefix" is what we'll be adding the accumulated sum to, it will be `n! / z^(n+1)`, but since we're scaling by `n!` it is just `1 / z^(n+1)` for now:
	prefix = pow( x, n+1 );
	if ( prefix === 0.0 ) {
		return PINF;
	}
	prefix = 1.0 / prefix;

	// First term in the series is necessarily `< zeta(2) < 2`, so ignore the sum if it will have no effect on the result:
	if ( prefix > 2.0/EPS ) {
		if ( n & 1 ) {
			return ( AX/prefix < scale ) ? PINF : prefix * scale;
		}
		return ( AX/prefix < scale ) ? NINF : -prefix * scale;
	}
	sum = prefix;
	for ( k = 0; ; ) {
		// Get the k'th term:
		term = fatorialPart * zeta( k+n+1 );
		sum += term;

		// Termination condition:
		if ( abs( term ) < abs(sum * EPS ) ) {
			break;
		}
		// Move on k and fatorialPart:
		k += 1;
		fatorialPart *= (-x * (n+k)) / k;

		// Last chance exit:
		if ( k > MAX_SERIES_ITERATIONS ) {
			debug( 'Series did not converge, best value is %d.', sum );
			return NaN;
		}
	}
	// We need to multiply by the scale, at each stage checking for overflow:
	if ( MAX/scale < sum ) {
		return PINF;
	}
	sum *= scale;
	return ( n & 1 ) ? sum : -sum;
} // end FUNCTION nearzero()


// EXPORTS //

module.exports = nearzero;
