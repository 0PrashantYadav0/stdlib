/**
* @license Apache-2.0
*
* Copyright (c) 2020 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#include "stdlib/math/base/special/cbrt.h"
#include "stdlib/math/base/assert/is_nan.h"
#include "stdlib/math/base/assert/is_infinite.h"
#include <stdint.h>

// B1 = (1023-1023/3-0.03306235651)*2**20
static const uint64_t B1 = 715094163;

// B2 = (1023-1023/3-54/3-0.03306235651)*2**20
static const uint64_t B2 = 696219795;

// 19/35  = 0x3FE15F15F15F15F1
static const double C = 5.42857142857142815906e-01;

// -864/1225 = 0xBFE691DE2532C834
static const double D = -7.05306122448979611050e-01;

// 99/70 = 0x3FF6A0EA0EA0EA0F
static const double E = 1.41428571428571436819e+00;

// 45/28 = 0x3FF9B6DB6DB6DB6E
static const double F = 1.60714285714285720630e+00;

// 5/14 = 0x3FD6DB6DB6DB6DB7
static const double G = 3.57142857142857150787e-01;

// 2**-1022 = 0x0010000000000000
static const double SMALLEST_NORMAL = 2.22507385850720138309e-308;

// 2**54
static const double TWO_54 = 18014398509481984;

/**
* Returns the IEEE 754 binary representation of a double-precision floating-point number.
*
* @param x    double
* @returns    binary representation
*/
uint64_t float64bits( const double x ) {
	return *(uint64_t *)&x;
}

/**
* Returns the double-precision floating-point number corresponding to a provided IEEE 754 binary representation.
*
* @param b    binary representation
* @returns    double
*/
double float64frombits( const uint64_t b ) {
	return *(double *)&b;
}

/**
* Computes the cube root of a double-precision floating-point number.
*
* ## Method
*
* 1.  Rough cube root to \\( 5 \\) bits:
*
*     ```tex
*     \sqrt\[3\]{2^e (1+m)} \approx 2^(e/3) \biggl(1 + \frac{(e \mathrm{mod}\ 3) + m}{3}\biggr)
*     ```
*
*     where \\( e \\) is a nonnegative integer, \\( m \\) is real and in \\( \[0, 1) \\), and \\( / \\) and \\( \mathrm{mod} \\) are integer division and modulus with rounding toward \\( -\infty \\).
*
*     The RHS is always greater than or equal to the LHS and has a maximum relative error of about \\( 1 \\) in \\( 16 \\).
*
*     Adding a bias of \\( -0.03306235651 \\) to the \\( (e \mathrm{mod} 3+ m )/ 3 \\) term reduces the error to about \\( 1 \\) in \\( 32 \\).
*
*     With the IEEE floating point representation, for finite positive normal values, ordinary integer division of the value in bits magically gives almost exactly the RHS of the above provided we first subtract the exponent bias (\\( 1023 \\) for doubles) and later add it back.
*
*     We do the subtraction virtually to keep \\( e \geq 0 \\) so that ordinary integer division rounds toward \\( -\infty \\); this is also efficient.
*
* 2.  New cube root to \\( 23 \\) bits:
*
*     ```tex
*     \sqrt[3]{x} = t \cdot \sqrt\[3\]{x/t^3} \approx t \mathrm{P}(t^3/x)
*     ```
*
*     where \\( \mathrm{P}(r) \\) is a polynomial of degree \\( 4 \\) that approximates \\( 1 / \sqrt\[3\]{r} \\) to within \\( 2^{-23.5} \\) when \\( |r - 1| < 1/10 \\).
*
*     The rough approximation has produced \\( t \\) such than \\( |t/sqrt\[3\]{x} - 1| \lesssim 1/32 \\), and cubing this gives us bounds for \\( r = t^3/x \\).
*
* 3.  Round \\( t \\) away from \\( 0 \\) to \\( 23 \\) bits (sloppily except for ensuring that the result is larger in magnitude than \\( \sqrt\[3\]{x} \\) but not much more than \\( 2 \\) 23-bit ulps larger).
*
*     With rounding toward zero, the error bound would be \\( \approx 5/6 \\) instead of \\( \approx 4/6 \\).
*
*     With a maximum error of \\( 2 \\) 23-bit ulps in the rounded \\( t \\), the infinite-precision error in the Newton approximation barely affects the third digit in the final error \\( 0.667 \\); the error in the rounded \\( t \\) can be up to about \\( 3 \\) 23-bit ulps before the final error is larger than \\( 0.667 \\) ulps.
*
* 4.  Perform one step of a Newton iteration to get \\( 53 \\) bits with an error of \\( < 0.667 \\) ulps.
*
* @param x       number
* @return        cube root
*
* @example
* double y = stdlib_base_cbrt( 27.0 );
* // returns 3.0
*/
double stdlib_base_cbrt( const double x ) {
	int8_t sgn;
	double ax;
	double t;
	double r;
	double s;
	double w;

	if (
		x == 0.0 || // handles +-0
		stdlib_base_is_nan( x ) ||
		stdlib_base_is_infinite( x )
	) {
		return x;
	}
	if ( x < 0.0 ) {
		sgn = 1;
		ax = -x;
	} else {
		sgn = 0;
		ax = x;
	}
	// Rough cbrt...
	if ( ax < SMALLEST_NORMAL ) {
		t = TWO_54;
		t *= ax;
		t = float64frombits( (float64bits(t)/3) + (B2<<32) );
	} else {
		t = float64frombits( (float64bits(ax)/3) + (B1<<32) );
	}
	// New cbrt...
	r = (t*t) / ax;
	s = C + (r*t);
	t *= G + (F/(s+E+(D/s)));

	// Round `t` away from `0` to `23` bits...
	t = float64frombits( (float64bits(t)&(0xFFFFFFFFC<<28)) + (1<<30) );

	// Newton iteration...
	s = t * t; // `t*t` is exact
	r = ax / s; // error `<= 0.5` ulps; `|r| < |t|`
	w = t + t; // `t+t` is exact
	r = (r - t) / (w + r); // `r-t` is exact; `w+r ~= 3*t`
	t += t * r; // error `<= 0.5 + 0.5/3 + eps`

	// Restore the sign bit...
	if ( sgn == 1 ) {
		t = -t;
	}
	return t;
}
