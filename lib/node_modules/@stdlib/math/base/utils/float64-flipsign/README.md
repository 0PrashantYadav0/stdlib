Flipsign
===
> Return a [double-precision floating-point number][ieee754] with the magnitude of `x` and the sign of `x*y`.


<!-- <usage> -->
## Usage

``` javascript
var flipsign = require( '@stdlib/math/base/utils/float64-flipsign' );
```

#### flipsign( x, y )

Returns a [double-precision floating-point number][ieee754] with the magnitude of `x` and the sign of `x*y`; i.e., only return `-x` when `y` is a negative number.

``` javascript
var z = flipsign( -3.14, 10 );
// returns -3.14

z = flipsign( -3.14, -1 );
// returns 3.14

z = flipsign( 1, -0 );
// returns -1

z = flipsign( -3.14, -0 );
// returns 3.14

z = flipsign( -0, 1 );
// returns -0

z = flipsign( 0, -1 );
// returns -0
```
<!-- </usage> -->

<!-- <notes> -->
## Notes

*	According to the [IEEE754][ieee754] standard, a `NaN` has a biased exponent equal to `2047`, a significand greater than `0`, and a sign bit equal to __either__ `1` __or__ `0`. In which case, `NaN` may not correspond to just one but many binary representations. Accordingly, care should be taken to ensure that `y` is __not__ `NaN`, else behavior may be indeterminate.
<!-- </notes> -->

<!-- <examples> -->
## Examples

``` javascript
var flipsign = require( '@stdlib/math/base/utils/float64-flipsign' );

var x;
var y;
var z;
var i;

// Generate random double-precision floating-point numbers `x` and `y` and flip the sign of `x` only if `y` is negative...
for ( i = 0; i < 100; i++ ) {
	x = Math.random()*100 - 50;
	y = Math.random()*10 - 5;
	z = flipsign( x, y );
	console.log( 'x: %d, y: %d => %d', x, y, z );
}
```
<!-- </examples> -->

<!-- <links> -->
[ieee754]: https://en.wikipedia.org/wiki/IEEE_754-1985
<!-- </links> -->
