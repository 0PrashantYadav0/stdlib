'use strict';

// MODULES //

var abs = require( '@stdlib/math/base/special/abs' );
var log1p = require( '@stdlib/math/base/special/log1p' );
var proxyquire = require( 'proxyquire' );
var tape = require( 'tape' );
var sumSeries = require( './../lib' );
var sumSeriesBasic = proxyquire( './../lib', {
	'detect-generator-support': function getFalse(){ return false; }
});
var EPS = require( '@stdlib/math/constants/float64-eps' );


// VARIABLES //

var hasGeneratorsSupport = require( '@stdlib/utils/detect-generator-support' )();


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.equal( typeof sumSeries, 'function', 'main export is a function' );
	t.end();
});

// Run generator function tests if environment supports `function*()`...

if ( hasGeneratorsSupport ) {
	require( './es2015-generator' );
}

tape( 'the function calculates the sum of an infinite series provided by a closure', function test( t ) {
	var actual = sumSeries( closure( 0.5 ) );
	var expected = log1p( 0.5 );

	t.ok( abs( actual - expected ) < EPS, 'returned result is within tolerance. actual: ' + actual + '; expected: ' + expected + '.' );
	t.end();

	function closure( x ) {
		var k = 0;
		var m_mult = -x;
		var m_prod = -1;
		return function next() {
			m_prod *= m_mult;
			return ( m_prod / ++k );
		};
	}
});

tape( 'the function calculates the sum of an infinite series provided by a closure (when generators are not supported)', function test( t ) {
	var actual = sumSeriesBasic( closure( 0.5 ) );
	var expected = log1p( 0.5 );

	t.ok( abs( actual - expected ) < EPS, 'returned result is within tolerance. actual: ' + actual + '; expected: ' + expected + '.' );
	t.end();

	function closure( x ) {
		var k = 0;
		var m_mult = -x;
		var m_prod = -1;
		return function next() {
			m_prod *= m_mult;
			return ( m_prod / ++k );
		};
	}
});

tape( 'the function calculates the sum of an infinite series with a specified initial value', function test( t ) {
	var actual = sumSeries( closure( 0.5 ), { 'initialValue' : 2 } );
	var expected = log1p( 0.5 ) + 2;

	t.ok( abs( actual - expected ) < EPS, 'returned result is within tolerance. actual: ' + actual + '; expected: ' + expected + '.' );
	t.end();

	function closure( x ) {
		var k = 0;
		var m_mult = -x;
		var m_prod = -1;
		return function next() {
			m_prod *= m_mult;
			return ( m_prod / ++k );
		};
	}
});

tape( 'the function calculates the sum of an infinite series with a specified initial value (when generators are not supported)', function test( t ) {
	var actual = sumSeriesBasic( closure( 0.5 ), { 'initialValue' : 2 } );
	var expected = log1p( 0.5 ) + 2;

	t.ok( abs( actual - expected ) < EPS, 'returned result is within tolerance. actual: ' + actual + '; expected: ' + expected + '.' );
	t.end();

	function closure( x ) {
		var k = 0;
		var m_mult = -x;
		var m_prod = -1;
		return function next() {
			m_prod *= m_mult;
			return ( m_prod / ++k );
		};
	}
});

tape( 'the function calculates the sum of a user-defined number of terms of the series', function test( t ) {
	var actual = sumSeries( closure( 0.5 ), { 'maxTerms' : 3 } );
	var expected = 6;

	t.equal( actual, expected, 'returned result is equal to expected value. actual: ' + actual + '; expected: ' + expected + '.' );
	t.end();

	function closure() {
		var k = 1;
		return function next() {
			return k++;
		};
	}
});

tape( 'the function calculates the sum of a user-defined number of terms of the series (when generators are not supported)', function test( t ) {
	var actual = sumSeriesBasic( closure( 0.5 ), { 'maxTerms' : 3 } );
	var expected = 6;

	t.equal( actual, expected, 'returned result is equal to expected value. actual: ' + actual + '; expected: ' + expected + '.' );
	t.end();

	function closure() {
		var k = 1;
		return function next() {
			return k++;
		};
	}
});
