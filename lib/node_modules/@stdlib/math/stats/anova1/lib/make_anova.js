'use strict';


// MODULES //

var isNumberArray = require( '@stdlib/assert/is-number-array' ).primitives;
var isTypedArrayLike = require( '@stdlib/assert/is-typed-array-like' );
var isArray = require( '@stdlib/assert/is-array' );
var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var cdf = require( '@stdlib/math/base/dists/f/cdf' );
var copy = require( '@stdlib/utils/copy' );
var defaults = require( './defaults.json' );
var validate = require( './validate.js' );
var uniqueElems = require('./unique_elems.js');
var meanTable = require('./mean_table.js');
var prettyPrint = require( './print.js' );


/**
* Make the ANOVA Object.
*
* @param {NumericArray} x - Measured values
* @param {Array} factor - Array of treatments
* @param {Options} [options] - function options
* @param {number} [options.alpha=0.05] - significance level
* @param {boolean} [options.decision=false] - Indicate whether we reject the null hypothesis
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {TypeError} `x` must be a numeric array
* @throws {TypeError} `factor` must be an array
* @throws {RangeError} `factor` must have at least two unique elements
* @throws {RangeError} length of `x` must be greater than or equal to 2
* @throws {RangeError} `x` and `factor` must have the same length
* @returns {Object} Returns the ANOVA Structure
*/
function anova1(x, factor) {
	var meanSumSqTreat; // Mean sum of squares
	var meanSumSqError;
	var ssTreatment;
	var sumSqTotal;
	var sumSqError;
	var treatment; // Index variable
	var grandMean;
	var fScore;
	var treats;
	var means;
	var numDf;
	var denDf;
	var pVal;
	var opts;
	var err;
	var out;
	var sq;
	var i;

	// Initialize all vars
	grandMean = 0;
	sumSqTotal = 0;
	ssTreatment = 0;

	opts = copy( defaults );

	// First check pre-conditions
	if ( !isTypedArrayLike( x ) && !isNumberArray( x )) {
		throw new TypeError( 'invalid first argument. x must be numeric array. Value: `' + x + '`.');
	}

	// Validate the options
	if (arguments.length > 2) {
		err = validate(opts, arguments[2]);
		if ( err ) {
			throw err;
		}
	}

	if (x.length <= 1) {
		throw new RangeError( 'length of x must be greater than or equal to 2.');
	}

	// Check if factor is an array
	if ( !isArray( factor )) {
		throw new TypeError(' factor argument must be an array' );
	}

	if (factor.length <= 1) {
		throw new RangeError('Second argument must have at least 2 elements');
	}

	treats = uniqueElems(factor);
	if (treats.length <= 1) {
		throw new RangeError('Second argument must have at least 2 unique elements');
	}

	// Check if the arrays are the same length
	if ( x.length !== factor.length ) {
		throw new RangeError( 'Arguments must be the same length' );
	}

	means = meanTable(x, factor);

	// Get the total mean
	for (i = 0; i < x.length; i++) {
		grandMean += x[i];
	}

	grandMean /= x.length;

	// Now get total ss
	for (i = 0; i < x.length; i++) {
		sq = (x[i] - grandMean) * (x[i] - grandMean);
		sumSqTotal += sq;
	}

	/* Now get the treatment SS
	// Groupmean - grandMean squared times number of obs
	make an array of means so that I may loop through the indices
	*/
	sq = 0;
	for (treatment in means) {
		if (treatment in means) {
			// Already have sq defined
			sq = (means[treatment].mean - grandMean) *
				(means[treatment].mean - grandMean);
			ssTreatment += means[treatment].sampleSize * sq;
		}
	}

	// Now for sse
	// Sse = sst - ssTreatment
	sumSqError = sumSqTotal - ssTreatment;

	// Now get the mean sum squares and mean errer
	meanSumSqTreat = ssTreatment / (treats.length - 1);

	meanSumSqError = sumSqError / (x.length - treats.length);

	// Now get the f score
	fScore = meanSumSqTreat / meanSumSqError;

	// Now get the p-value
	numDf = treats.length - 1;
	denDf = x.length - treats.length;
	pVal = 1 - cdf(fScore, numDf, denDf);

	// Now to make the out object
	out = {};
	setReadOnly(out, 'treatmentDf', treats.length - 1);
	setReadOnly(out, 'treatmentSS', ssTreatment);
	setReadOnly(out, 'treatmentMSS', meanSumSqTreat);
	setReadOnly(out, 'errorDf', x.length - treats.length);
	setReadOnly(out, 'errorSS', sumSqError);
	setReadOnly(out, 'errorMSS', meanSumSqError);
	setReadOnly(out, 'statistic', fScore);
	setReadOnly(out, 'pValue', pVal);
	setReadOnly(out, 'means', means);
	setReadOnly(out, 'method', 'One-Way ANOVA');
	setReadOnly(out, 'alpha', opts.alpha);
	setReadOnly(out, 'rejected', pVal <= opts.alpha);
	setReadOnly(out, 'print', prettyPrint( out ));


	return out;
}


// EXPORTS //

module.exports = anova1;
