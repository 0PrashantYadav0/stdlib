'use strict';

// MODULES //

var isPositiveInteger = require( '@stdlib/assert/is-positive-integer' );
var isObject = require( '@stdlib/assert/is-plain-object' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var roundn = require( '@stdlib/math/base/special/roundn' );


// MAIN //

/**
* Pretty-print output of test.
*
* @param {Object} [opts] - options object
* @param {PositiveInteger} [opts.numdigits=4] - number of digits after the decimal point
* @returns {string} formatted output
*/
function print( opts ) { // eslint-disable-line stdlib/no-redeclare
	/* eslint-disable no-invalid-this */
	var dgts;
	var str;

	dgts = 4;
	if ( arguments.length > 0 ) {
		if ( !isObject( opts ) ) {
			throw new TypeError( 'invalid input argument. First argument must be an options object. Value: `' + opts + '`.' );
		}
		if ( hasOwnProp( opts, 'numdigits' ) ) {
			if ( !isPositiveInteger( opts.numdigits ) ) {
				throw new TypeError( 'invalid option. numdigits option must be a positive integer. Option: `' + opts.numdigits + '`.' );
			}
			dgts = opts.numdigits;
		}
	}

	str = '';
	str += this.method;
	str += '\n\n';
	str += 'Null hypothesis: the CDF of `x` is ';
	switch ( this.alternative ) {
	case 'two-sided':
	default:
		str += 'equal to ';
		break;
	case 'less':
		str += 'greater than or equal to ';
		break;
	case 'greater':
		str += 'less than or equal to ';
		break;
	}
	str += 'the reference CDF';
	str += '\n\n';
	str += '\tpValue: ' + roundn( this.pValue, -dgts ) + '\n';
	str += '\tstatistic: ' + roundn( this.statistic, -dgts );
	str += '\n\n';
	str += 'Test Decision: ';
	if ( this.rejected ) {
		str += 'Reject null in favor of alternative at ' + (this.alpha*100) + '% significance level';
	} else {
		str += 'Fail to reject null in favor of alternative at ' + (this.alpha*100) + '% significance level';
	}
	str += '\n';
	return str;
}


// EXPORTS //

module.exports = print;
