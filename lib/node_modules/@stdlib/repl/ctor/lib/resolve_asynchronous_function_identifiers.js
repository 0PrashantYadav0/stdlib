/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MAIN //

var walk = require( 'acorn-walk' ).ancestor;
var resolveLocalScopes = require( './resolve_local_scopes.js' );
var contains = require( './contains.js' );
var appendUnique = require( './append_unique.js' );


// FUNCTIONS //

/**
* Tests whether an AST node declares an `arguments` variable.
*
* @private
* @param {Node} node - AST node
* @returns {boolean} boolean indicating whether an AST node declares an `arguments` variable
*/
function declaresArguments( node ) {
	return (
		node.type === 'FunctionExpression' ||
		node.type === 'FunctionDeclaration'
	);
}


// MAIN //

/**
* Resolves asynchronous function identifiers within an abstract syntax tree (AST).
*
* ## Notes
*
* -   Resolution depends on the presence of the REPL-specific global `__done__`. If a top-level function definition contains a reference to `__done__` or to another function which references `__done__`, a function is flagged as "asynchronous".
*
* @private
* @param {Array} names - output array containing a list of top-level asynchronous function identifiers
* @param {AST} ast - abstract syntax tree (AST)
* @throws {TypeError} must provide a program AST node
* @returns {Array} list of identifiers detected as "asynchronous" functions
*/
function resolveAsyncFunctions( names, ast ) {
	var visitors;
	var tmp;
	var i;
	if ( ast.type !== 'Program' ) {
		throw new TypeError( 'invalid argument. Must provide a program AST node.' );
	}
	tmp = [];

	// Resolve local scopes:
	ast = resolveLocalScopes( ast );

	// Define callbacks for relevant AST nodes:
	visitors = {
		'VariablePattern': Identifier,
		'Identifier': Identifier
	};

	// Walk the AST to resolve "asynchronous" function identifiers:
	walk( ast, visitors );

	// Filter the list of "asynchronous" function identifier candidates to only include those detected function identifiers which are declared at the program level...
	for ( i = 0; i < tmp.length; i++ ) {
		if ( contains( ast.locals.length, ast.locals, 1, 0, tmp[ i ] ) ) {
			names.push( tmp[ i ] );
		}
	}
	return names;

	/**
	* Callback invoked upon encountering an identifier AST node.
	*
	* @private
	* @param {Node} node - AST node
	* @param {Array} parents - array of parent AST nodes
	*/
	function Identifier( node, parents ) {
		var locals;
		var name;
		var len;
		var p;
		var t;
		var i;

		name = node.name;
		if ( name === 'undefined' ) {
			return;
		}
		// Note: an identifier AST node should always have parents so the length should never be zero...
		len = parents.length;

		// Avoid locally defined identifiers...
		for ( i = 0; i < len; i++ ) {
			if ( name === 'arguments' && declaresArguments( parents[ i ] ) ) {
				return;
			}
			locals = parents[ i ].locals;
			if ( locals && contains( locals.length, locals, 1, 0, name ) ) {
				return;
			}
		}
		// At this point, we have a "global" identifier, meaning an identifier which was not declared within the AST, and we need to see if that identifier resolves to an "asynchronous" function...

		// We are only concerned with identifiers used within call expressions (e.g., `__done__()`, `foo()`, etc), meaning that a function is *only* considered "asynchronous", if the function's body contains a function *invocation* of a function already known/labeled as "asynchronous" (note: various ways exist to "fool" this analysis, such as indirect evaluation, etc, and we do not bother trying to determine that here; essentially, we only attempt to cover simple and straightforward use cases)...
		if ( parents[ len-1 ].type !== 'CallExpression' ) {
			return;
		}
		// Only resolve an identifier's context for identifiers known to indicate "asynchrony":
		if ( name !== '__done__' && !contains( names.length, names, 1, 0, name ) ) {
			return;
		}
		// Case: nested `__done__()` or `foo()`, where `foo` is considered "asynchronous"

		// Search for the highest function identifier, if one exists, containing the call expression...
		for ( i = 0; i < len; i++ ) {
			t = node.type;

			// Case: `function bar() { __done__(); }`
			if ( t === 'FunctionDeclaration' ) {
				appendUnique( tmp, node.id.name );
				break;
			}
			if ( t === 'FunctionExpression' || t === 'ArrowFunctionExpression' ) {
				p = parents[ i-1 ];
				if ( p ) {
					// Case: `var bar = function() { __done__(); }`
					if ( p.type === 'VariableDeclarator' ) {
						appendUnique( tmp, p.id.name );
						break;
					}
					// Case: `bar = function() { __done__(); }`
					if ( p.type === 'AssignmentExpression' ) {
						appendUnique( tmp, p.left.name );
						break;
					}
				}
			}
		}
		// Case: top-level `__done__()` or `foo()`, where `foo` is considered "asynchronous"
		if ( i === len ) {
			appendUnique( tmp, name );
		}
	}
}


// EXPORTS //

module.exports = resolveAsyncFunctions;
