/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-underscore-dangle */

'use strict';

// MODULES //

var inspect = require( 'util' ).inspect;
var logger = require( 'debug' );
var displayPrompt = require( './display_prompt.js' );
var updateRegExpCache = require( './update_regexp_cache.js' );
var restoreRegExpMatches = require( './restore_regexp_matches.js' );


// VARIABLES //

var debug = logger( 'repl:drain' );


// MAIN //

/**
* Drains a REPL's command queue.
*
* @private
* @param {REPL} repl - REPL instance
* @returns {void}
*/
function drain( repl ) {
	var opts;
	var code;
	var res;

	if ( repl._queue.length === 0 ) {
		debug( 'Command queue is empty.' );
		repl._busy = false;
		if ( !repl._closed ) {
			displayPrompt( repl, false );
		}
		return;
	}
	if ( repl._busy ) {
		debug( 'Waiting on an asynchronous command to finish...' );
		return;
	}
	debug( 'Evaluating next command...' );

	// Remove a command from the queue:
	code = repl._queue.pop();
	debug( 'Command: %s', code.raw );

	// Set the (non-standard) properties on the `RegExp` expression object to the cached matches:
	restoreRegExpMatches( repl._regexp );

	// TODO: handle async processing (if `code.async`, set `busy` to true; otherwise, assume sync processing)

	// TODO: evaluate and determine whether to print result
	opts = {
		'timeout': repl._timeout,
		'displayErrors': false,
		'breakOnSigint': true // Note: only applies for Node.js versions >=6.3.0
	};
	try {
		if ( repl._sandbox ) {
			res = code.compiled.runInContext( repl._context, opts );
		} else {
			res = code.compiled.runInThisContext( opts );
		}
		updateRegExpCache( repl._regexp );
	} catch ( error ) {
		updateRegExpCache( repl._regexp );

		// TODO: handle SIGINT (see https://github.com/nodejs/node/blob/b21e7c7bcf23a2715951e4cd96180e4dbf1dcd4d/lib/repl.js#L336)

		debug( 'Error: %s', error.message );
		repl._ostream.write( 'Error: '+error.message+'\n' );
		repl._history.push( code.raw, false ); // command failed
		displayPrompt( repl, false );
		return;
	}
	if ( code.silent === false && res !== void 0 ) {
		repl._ostream.write( inspect( res )+'\n' ); // TODO: pretty printing (can defer to `util.inspect` for now, but will invariably want more control over this later, possibly including default configuration, etc, either at startup, during runtime, or according to an external configuration file)
	}
	// Cache the result:
	repl._ans = res;

	// Save the command in the history buffer:
	repl._history.push( code.raw, true ); // command succeeded

	// TODO: if successful and if necessary, (asynchronously?) write the command to a history file

	// TODO: if successful and if necessary, (asynchronously?) write the command and result to a log file

	// TODO: replace with polyfill
	process.nextTick( onTick );

	/**
	* Callback invoked upon the next tick of the event loop.
	*
	* @private
	*/
	function onTick() {
		drain( repl );
	}
}


// EXPORTS //

module.exports = drain;
