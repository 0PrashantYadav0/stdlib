/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-underscore-dangle */

'use strict';

// MODULES //

var vm = require( 'vm' );
var logger = require( 'debug' );
var trim = require( '@stdlib/string/trim' );
var displayPrompt = require( './display_prompt.js' );
var drain = require( './drain.js' );


// VARIABLES //

var debug = logger( 'repl:line' );
var SEMICOLON = 59; // character code
var RE_OPENING_BRACE = /^\s*\{/;
var RE_CLOSING_BRACE = /\}\s*$/;
var RE_WHITESPACE = /^\s*$/;


// MAIN //

/**
* Processes input line data.
*
* @private
* @param {REPL} repl - REPL instance
* @param {string} line - line data
* @returns {void}
*/
function processLine( repl, line ) {
	var isWrapped;
	var script;
	var opts;
	var code;

	debug( 'Line: %s', line );

	// Removing leading and trailing whitespace:
	line = trim( line );

	// TODO: check if the line is valid JavaScript syntax; if yes, then proceed; otherwise, buffer the command in `cmd` buffer until ready to execute (e.g., when providing multi-line input)

	opts = {
		'filename': '<repl>',
		'lineOffset': 0
	};
	code = {
		'raw': line
	};

	// Check for commands like object literals (e.g., `{'a':1}`), which we want to be evaluated as expressions, rather than blocks...
	if ( RE_OPENING_BRACE.test( line ) && RE_CLOSING_BRACE.test( line ) ) {
		// FIXME: we need to actually parse into an AST here and check if the last "expression" begins and ends with braces (e.g., `1+1; {'a':1}`); if so, we need to wrap the last expression in parentheses
		// FIXME: the above also fails to account for `{'a':1};`, which ends in a semicolon and not a brace
		// FIXME: the above also fails to account for expressions such as variable assignments (e.g., `var v = [1,2,3]`), where we may want to see the assigned value
		line = '(' + line + ')\n';
		isWrapped = true;
	}
	// Attempt to compile the command...
	while ( true ) {
		try {
			if ( RE_WHITESPACE.test( line ) ) {
				script = new vm.Script( line, opts );
				code.silent = true;
			} else {
				// Note: `void 0` ensures that the compiled script does not return the string `'use strict'` when provided commands (statements/declarations) which do not return a value (e.g., `{}`):
				script = new vm.Script( '\'use strict\'; void 0;\n'+line, opts );
				code.silent = line.charCodeAt( line.length-1 ) === SEMICOLON; // eslint-disable-line max-len
			}
			code.compiled = script;
		} catch ( error ) {
			// If we previously wrapped the command, unwrap and try again...
			if ( isWrapped ) {
				isWrapped = false;
				line = code.raw;
				continue;
			}
			// TODO: check if error is recoverable? And if so, update the command buffer; otherwise, write error message to console and display prompt.
			debug( 'Error: %s', error.message );
			repl._ostream.write( 'Error: '+error.message+'\n' );
			displayPrompt( repl, false );
			return;
		}
		break;
	}
	// Add the command to the command queue:
	repl._queue.push( code );

	// Request to run the command:
	drain( repl );
}


// EXPORTS //

module.exports = processLine;
