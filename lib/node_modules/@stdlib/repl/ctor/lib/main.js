/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-restricted-syntax, no-invalid-this, no-underscore-dangle */

'use strict';

// MODULES //

var EventEmitter = require( 'events' ).EventEmitter;
var readline = require( 'readline' ).createInterface;
var resolve = require( 'path' ).resolve;
var logger = require( 'debug' );
var inherit = require( '@stdlib/utils/inherit' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var setNonEnumerable = require( '@stdlib/utils/define-nonenumerable-property' );
var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var properties = require( '@stdlib/utils/properties' );
var append = require( '@stdlib/utils/append' );
var cwd = require( '@stdlib/process/cwd' );
var readFileSync = require( '@stdlib/fs/read-file' ).sync;
var RE_EOL = require( '@stdlib/regexp/eol' );
var fifo = require( '@stdlib/utils/fifo' );
var validate = require( './validate.js' );
var defaults = require( './defaults.js' );
var setAliases = require( './set_aliases.js' );
var setAliasesGlobal = require( './set_aliases_global.js' );
var setCommands = require( './set_commands.js' );
var setCommandsGlobal = require( './set_commands_global.js' );
var propertyComparator = require( './property_comparator.js' );
var createEvalContext = require( './create_evaluation_context.js' );
var commands = require( './commands.js' );
var displayPrompt = require( './display_prompt.js' );
var processLine = require( './process_line.js' );
var completer = require( './completer.js' );
var ALIAS_OVERRIDES = require( './alias_overrides.js' );


// VARIABLES //

var debug = logger( 'repl' );


// MAIN //

/**
* REPL constructor.
*
* @constructor
* @param {Options} options - constructor options
* @param {string} [options.prompt='> '] - input prompt
* @param {ReadableStream} [options.input=process.stdin] - input stream
* @param {WritableStream} [options.output=process.stdout] - output stream
* @param {boolean} [options.sandbox=true] - boolean indicating whether to run a REPL in a sandboxed context
* @param {PositiveInteger} [options.timeout=4294967295] - number of milliseconds to execute a command before terminating execution
* @param {boolean} [options.isTTY] - boolean indicating whether the input and output streams should be treated like a TTY (terminal) and whether the REPL should use ANSI/VT100 escape codes when writing to the output stream
* @param {string} [options.welcome] - welcome message
* @param {string} [options.load] - file path specifying a JavaScript file to load and evaluate line-by-line (e.g., a previous REPL history file)
* @param {string} [options.save] - file path specifying where to save REPL command history
* @param {string} [options.log] - file path specifying where to save REPL commands and printed output
* @throws {Error} must provide valid options
* @returns {REPL} REPL instance
*
* @example
* var debug = require( '@stdlib/streams/node/debug-sink' );
*
* function onExit() {
*     console.log( 'REPL closed.' );
* }
*
* // Create a new REPL:
* var repl = new REPL({
*     'output': debug()
* });
* repl.on( 'exit', onExit );
*
* // ...
*
* // Close the REPL:
* repl.close();
*/
function REPL( options ) {
	var opts;
	var self;
	var err;

	if ( !( this instanceof REPL ) ) {
		if ( arguments.length ) {
			return new REPL( options );
		}
		return new REPL();
	}
	self = this;

	opts = defaults();
	if ( arguments.length ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.isTTY = ( opts.isTTY === void 0 ) ? opts.output.isTTY : opts.isTTY;

	debug( 'Options: %s', JSON.stringify({
		'input': '<readable_stream>',
		'output': '<writable_stream>',
		'sandbox': opts.sandbox,
		'timeout': opts.timeout,
		'isTTY': opts.isTTY,
		'prompt': opts.prompt,
		'welcome': opts.welcome,
		'load': opts.load,
		'save': opts.save,
		'log': opts.log
	}));

	// Call the parent constructor:
	EventEmitter.call( this );

	// Cache references to the input and output streams:
	setNonEnumerableReadOnly( this, '_istream', opts.input );
	setNonEnumerableReadOnly( this, '_ostream', opts.output );

	// Cache options:
	setNonEnumerableReadOnly( this, '_prompt', opts.prompt );
	setNonEnumerableReadOnly( this, '_timeout', opts.timeout );
	setNonEnumerableReadOnly( this, '_isTTY', opts.isTTY );
	setNonEnumerableReadOnly( this, '_sandbox', opts.sandbox );

	// Initialize an internal command queue:
	setNonEnumerableReadOnly( this, '_queue', fifo() );

	// Initialize an internal buffer for storing the command history:
	setNonEnumerableReadOnly( this, '_history', [] );

	// Initialize an internal buffer for storing the current command:
	setNonEnumerableReadOnly( this, '_cmd', [] );

	// Initialize an internal buffer for saving regular expression matches between command evaluations:
	setNonEnumerableReadOnly( this, '_regexp', [ '', '', '', '', '', '', '', '', '', '' ] );

	// For non-sandboxed REPLs, initialize an internal buffer for storing a (unique) sorted list of "built-in" REPL global variables/properties which need to be deleted upon closing a REPL in order to allow garbage collection and prevent memory leaks:
	setNonEnumerableReadOnly( this, '_globalVars', ( this._sandbox ) ? null : [] );

	// Initialize a strided internal cache of resolved global variables/properties in order to allow, e.g., help text look-up based on object reference, not just alias name (note: members alternate between `'<string_alias>'` and `<resolved_value>`):
	setNonEnumerableReadOnly( this, '_aliases', [] );

	// Initialize an internal buffer for storing a (unique) sorted list of workspace global variables/properties which were *initially* introduced during a REPL session (note: this overlaps with `_globalVars`, but more accurately represents a snapshot of the `global` state *before* a user begins entering commands, which is useful when wanting determine what variables/identifiers a user has introduced during a REPL session):
	setNonEnumerableReadOnly( this, '_workspace', [] );

	// Initialize a strided internal buffer for caching "base" workspace variables:
	setNonEnumerableReadOnly( this, '_workspaces', {} );
	setReadOnly( this._workspaces, 'base', [] );

	// Define the current workspace:
	setNonEnumerable( this, '_currentWorkspace', 'base' );

	// Initialize an internal flag indicating whether the REPL has been closed:
	setNonEnumerable( this, '_closed', false );

	// Initialize an internal flag indicating whether the REPL is currently busy with asynchronous processing:
	setNonEnumerable( this, '_busy', false );

	// Initialize an internal variable for caching the result of the last successfully evaluated command:
	setNonEnumerable( this, '_ans', void 0 );

	// Create a REPL execution context:
	setNonEnumerable( this, '_context', this.createContext() );

	// Create an internal readline interface:
	debug( 'Creating readline interface...' );
	setNonEnumerableReadOnly( this, '_rli', readline({
		'input': this._istream,
		'output': this._ostream,
		'terminal': opts.isTTY,
		'prompt': opts.prompt,
		'completer': completer( this )
	}));
	this._rli.on( 'close', onClose );
	this._rli.on( 'line', onLine );

	// Write a welcome message:
	this._ostream.write( opts.welcome );

	// TODO: check whether to synchronously initialize a REPL history file

	// TODO: check whether to synchronously initialize a REPL log file

	// TODO: add `SIGINT` handler (see https://github.com/nodejs/node/blob/b21e7c7bcf23a2715951e4cd96180e4dbf1dcd4d/lib/repl.js#L581)

	// Check whether to load and execute a JavaScript file (e.g., prior REPL history) upon startup...
	if ( opts.load ) {
		this.load( opts.load );
	} else {
		displayPrompt( this, false );
	}
	return this;

	/**
	* Callback invoked upon a readline interface "line" event.
	*
	* @private
	* @param {string} line - line data
	*/
	function onLine( line ) {
		if ( self._closed === false ) {
			processLine( self, line );
		}
	}

	/**
	* Callback invoked upon a readline interface "close" event.
	*
	* @private
	*/
	function onClose() {
		debug( 'Readline interface closed.' );
		debug( 'Exiting REPL...' );
		self.emit( 'exit' );
	}
}

/*
* Inherit from the `EventEmitter` prototype.
*/
inherit( REPL, EventEmitter );

/**
* Creates a REPL context.
*
* @name createContext
* @memberof REPL.prototype
* @type {Function}
* @returns {Object} REPL context
*/
setNonEnumerableReadOnly( REPL.prototype, 'createContext', function createContext() {
	var context;
	var cmds;

	debug( 'Creating REPL execution context...' );

	// Create an evaluation context:
	context = createEvalContext( this._ostream, this._sandbox );

	// Add project APIs...
	if ( this._sandbox ) {
		setAliases( this._aliases, context, ALIAS_OVERRIDES );
	} else {
		setAliasesGlobal( this._globalVars, this._aliases, context, ALIAS_OVERRIDES ); // eslint-disable-line max-len
	}

	// Get the list of REPL-specific commands:
	cmds = commands( this );

	// Add commands requiring privileged access to internal instance variables...
	if ( this._sandbox ) {
		setCommands( context, cmds );
	} else {
		setCommandsGlobal( this._globalVars, context, cmds );
	}

	// NOTE: the context should not be augmented **after** this point, except as done by the user when declaring variables and functions!

	// Sort the list of global variables:
	if ( this._sandbox === false ) {
		this._globalVars.sort( propertyComparator );
	}
	// Capture a snapshot of the current global workspace:
	append( this._workspace, properties( context ) );

	return context;
});

/**
* Resets a REPL's context.
*
* @name resetContext
* @memberof REPL.prototype
* @type {Function}
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'resetContext', function resetContext() {
	var tmp;
	var i;

	debug( 'Resetting REPL execution context...' );

	// Reset internal buffers for storing context data:
	if ( this._sandbox === false ) {
		this._globalVars.length = 0;
	}
	this._aliases.length = 0;
	this._workspace.length = 0;

	// Before creating a new execution context in a non-sandboxed environment, remove current workspace variables in order to allow garbage collection and avoid memory leaks (e.g., variables/functions declared during a REPL session which might remain bound to the environment `global` after clearing a REPL):
	if ( this._sandbox === false ) {
		// WARNING: in a non-sandboxed environment, if a global variable is externally introduced during a REPL session (i.e., introduced via a mechanism outside of the REPL environment), we will delete that global variable, which means the following logic may introduce unintended side-effects for this particular edge case (e.g., application code may expect the presence of the subsequently deleted global variable). While not ideal, (a) user applications should not be introducing globals to begin with and (b) the probability of a user running a REPL session, a user clearing that REPL session, AND a global variable being introduced between starting a REPL and clearing the REPL should be negligible.
		tmp = this._context.vars();
		for ( i = 0; i < tmp.length; i++ ) {
			delete this._context[ tmp[i] ];
		}
	}
	// Create a new execution context...
	this._context = this.createContext();
	this.emit( 'reset', this._context ); // note: emitting the context allows REPL wrappers to extend the newly created context

	return this;
});

/**
* Loads and evaluates a JavaScript file line-by-line.
*
* ## Notes
*
* -   The method **synchronously** reads provided files in order to preserve command order.
*
* @name load
* @memberof REPL.prototype
* @type {Function}
* @param {string} fpath - file path
* @throws {Error} cannot load a file into a closed REPL
* @throws {TypeError} must provide a string
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'load', function load( fpath ) {
	var file;
	var i;
	if ( this._closed ) {
		throw new Error( 'invalid operation. Cannot load a file into a REPL which has already closed.' );
	}
	if ( !isString( fpath ) ) {
		throw new TypeError( 'invalid argument. Must provide a string. Value: `' + fpath + '`.' );
	}
	// Resolve the provided path to an absolute file path:
	fpath = resolve( cwd(), fpath );
	debug( 'Loading filepath: %s', fpath );

	// Attempt to synchronously read the file:
	file = readFileSync( fpath, 'utf8' );
	if ( file instanceof Error ) {
		debug( 'Error: %s', file.message );
		this._ostream.write( 'Error: '+file.message+'\n' );
		return this;
	}
	// Split the file content into individual lines:
	file = file.split( RE_EOL );

	// Forward each line to the REPL readline interface in order to mimic user input...
	for ( i = 0; i < file.length; i++ ) {
		if ( file[ i ] ) {
			this._rli.write( file[ i ]+'\n' );
			displayPrompt( this, false );
		}
	}
	return this;
});

/**
* Resets a REPL.
*
* @name reset
* @memberof REPL.prototype
* @type {Function}
* @throws {Error} cannot reset a closed REPL
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'reset', function onReset() {
	if ( this._closed ) {
		throw new Error( 'invalid operation. Cannot reset a REPL which has already closed.' );
	}
	debug( 'Resetting REPL...' );

	// Reset the command queue:
	this._queue.clear();

	// Clear any command which has been buffered but not yet executed:
	this._cmd.length = 0;

	// Reset the command history:
	this._history.length = 0;

	// Reset the execution context:
	this.resetContext();

	// Clear an output TTY stream of any previous commands and output:
	this.clear();

	// Display the command prompt:
	displayPrompt( this, false );

	return this;
});

/**
* Clears the entire REPL screen and scrollback history.
*
* ## Notes
*
* -   This method is only applicable for TTY REPLs. In non-TTY REPLs, this method is a non-operation.
*
* @name clear
* @memberof REPL.prototype
* @type {Function}
* @throws {Error} cannot clear a closed REPL
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'clear', function onClear() {
	if ( this._closed ) {
		throw new Error( 'invalid operation. Cannot clear a REPL which has already closed.' );
	}
	if ( this._isTTY ) {
		/*
		* [ANSI escape sequences][1]:
		*
		* -   `\u001b`: ESC, the escape character
		* -   `[H`: move cursor to upper left corner
		* -   `[2J`: clear the entire screen
		* -   `[3J`: clear the entire screen and delete all lines in the scrollback buffer (note: possible portability issues)
		*
		* [1]: https://en.wikipedia.org/wiki/ANSI_escape_code
		*/
		this._ostream.write( '\u001b[2J\u001b[H\u001b[2J\u001b[3J' );
	}
	return this;
});

/**
* Closes a REPL.
*
* @name close
* @memberof REPL.prototype
* @type {Function}
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'close', function close() {
	var self;
	if ( this._closed ) {
		debug( 'Attempted to close an already closed REPL.' );
		return this;
	}
	self = this;
	this._closed = true;

	// Clear the command queue:
	this._queue.clear();

	// TODO: ensure REPL history is saved (flushed) to file before closing the REPL (see https://github.com/nodejs/node/blob/b21e7c7bcf23a2715951e4cd96180e4dbf1dcd4d/lib/repl.js#L805)

	// TODO: ensure REPL log is saved (flushed) to file before closing the REPL

	// TODO: replace with polyfill
	process.nextTick( onTick );

	return this;

	/**
	* Callback invoked upon the next tick of the event loop.
	*
	* @private
	*/
	function onTick() {
		var tmp;
		var key;
		var o;
		var i;
		var j;

		debug( 'Closing readline interface...' );
		self._rli.close();

		// If this is a non-sandboxed REPL, remove global variables/properties which were introduced during context creation and by a user during a REPL session...
		if ( self._sandbox === false ) {
			// WARNING: in a non-sandboxed environment, if a global variable is externally introduced during a REPL session (i.e., introduced via a mechanism outside of the REPL environment), we will delete that global variable, which means the following logic may introduce unintended side-effects for this particular edge case (e.g., application code may expect the presence of the subsequently deleted global variable). While not ideal, (a) user applications should not be introducing globals to begin with and (b) the probability of a user running a REPL session, a user closing that REPL session, AND a global variable being introduced between starting a REPL and closing the REPL should be negligible.
			tmp = self._context.vars(); // current workspace variables
			for ( i = 0; i < tmp.length; i++ ) {
				delete self._context[ tmp[i] ];
			}

			// Remove REPL globals:
			for ( i = 0; i < self._globalVars.length; i++ ) {
				o = self._context;
				key = self._globalVars[ i ].split( '.' ); // Note: this addresses nested key paths (e.g., `a.b.c`)
				for ( j = 0; j < key.length-1; j++ ) {
					o = o[ key[ j ] ];
				}
				delete o[ key[ j ] ];
			}
		}
	}
});


// EXPORTS //

module.exports = REPL;
