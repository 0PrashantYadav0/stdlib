/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-restricted-syntax, no-invalid-this, no-underscore-dangle */

'use strict';

// MODULES //

var EventEmitter = require( 'events' ).EventEmitter;
var readline = require( 'readline' );
var resolve = require( 'path' ).resolve;
var vm = require( 'vm' );
var inspect = require( 'util' ).inspect;
var logger = require( 'debug' );
var inherit = require( '@stdlib/utils/inherit' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var setNonEnumerable = require( '@stdlib/utils/define-nonenumerable-property' );
var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var setNonEnumerableReadOnlyAccessor = require( '@stdlib/utils/define-nonenumerable-read-only-accessor' ); // eslint-disable-line id-length
var trim = require( '@stdlib/string/trim' );
var cwd = require( '@stdlib/process/cwd' );
var readFileSync = require( '@stdlib/fs/read-file' ).sync;
var RE_EOL = require( '@stdlib/regexp/eol' );
var fifo = require( '@stdlib/utils/fifo' );
var validate = require( './validate.js' );
var defaults = require( './defaults.js' );
var createContext = require( './create_context.js' );


// VARIABLES //

var debug = logger( 'repl' );
var SEMICOLON = 59; // character code
var RE_OPENING_BRACE = /^\s*\{/;
var RE_CLOSING_BRACE = /\}\s*$/;
var RE_WHITESPACE = /^\s*$/;

/*
* In certain JavaScript engines (e.g., V8, SpiderMonkey), the global `RegExp` object has ([non-standard][1]) static, read-only properties (`$1`, `$2`, ..., `$9`) with cached substring matches. In order to preserve these matches between command evaluations, we need to capture and subsequently restore them prior to evaluation.
*
* [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n
*/
var SEP_REGEXP_MATCHES = '\u0000\u0000\u0000';
var RE_REGEXP_MATCHES = new RegExp( [ '^', '(.*)', '(.*)', '(.*)', '(.*)', '(.*)', '(.*)', '(.*)', '(.*)', '(.*)$' ].join( SEP_REGEXP_MATCHES ) );


// FUNCTIONS //

/**
* Displays a command prompt.
*
* @private
* @param {REPL} repl - REPL instance
* @param {boolean} [preserveCursor=false] - boolean indicating whether to preserve the cursor position
*/
function displayPrompt( repl, preserveCursor ) {
	var prompt;
	if ( repl._cmd.length ) {
		// TODO: determine indentation level (use spaces)
		prompt = '';
	} else {
		prompt = repl._prompt;
	}
	repl._rli.setPrompt( prompt );
	repl._rli.prompt( preserveCursor );
}

/**
* Processes input line data.
*
* @private
* @param {REPL} repl - REPL instance
* @param {string} line - line data
* @returns {void}
*/
function processLine( repl, line ) {
	var isWrapped;
	var script;
	var opts;
	var code;

	debug( 'Line: %s', line );

	// Removing leading and trailing whitespace:
	line = trim( line );

	// TODO: check if the line is valid JavaScript syntax; if yes, then proceed; otherwise, buffer the command in `cmd` buffer until ready to execute (e.g., when providing multi-line input)

	opts = {
		'filename': '<repl>',
		'lineOffset': 0
	};
	code = {
		'raw': line
	};

	// Check for commands like object literals (e.g., `{'a':1}`), which we want to be evaluated as expressions, rather than blocks...
	if ( RE_OPENING_BRACE.test( line ) && RE_CLOSING_BRACE.test( line ) ) {
		// FIXME: we need to actually parse into an AST here and check if the last "expression" begins and ends with braces (e.g., `1+1; {'a':1}`); if so, we need to wrap the last expression in parentheses
		// FIXME: the above also fails to account for `{'a':1};`, which ends in a semicolon and not a brace
		// FIXME: the above also fails to account for expressions such as variable assignments (e.g., `var v = [1,2,3]`), where we may want to see the assigned value
		line = '(' + line + ')\n';
		isWrapped = true;
	}
	// Attempt to compile the command...
	while ( true ) {
		try {
			if ( RE_WHITESPACE.test( line ) ) {
				script = new vm.Script( line, opts );
				code.silent = true;
			} else {
				// Note: `void 0` ensures that the compiled script does not return the string `'use strict'` when provided commands (statements/declarations) which do not return a value (e.g., `{}`):
				script = new vm.Script( '\'use strict\'; void 0;\n'+line, opts );
				code.silent = line.charCodeAt( line.length-1 ) === SEMICOLON; // eslint-disable-line max-len
			}
			code.compiled = script;
		} catch ( error ) {
			// If we previously wrapped the command, unwrap and try again...
			if ( isWrapped ) {
				isWrapped = false;
				line = code.raw;
				continue;
			}
			// TODO: check if error is recoverable? And if so, update the command buffer; otherwise, write error message to console and display prompt.
			debug( 'Error: %s', error.message );
			repl._ostream.write( 'Error: '+error.message+'\n' );
			displayPrompt( repl, false );
			return;
		}
		break;
	}
	// Add the command to the command queue:
	repl._queue.push( code );

	// Request to run the command:
	drain( repl );
}

/**
* Drains a REPL's command queue.
*
* @private
* @param {REPL} repl - REPL instance
* @returns {void}
*/
function drain( repl ) {
	var opts;
	var code;
	var res;

	if ( repl._queue.length === 0 ) {
		debug( 'Command queue is empty.' );
		repl._busy = false;
		if ( !repl._closed ) {
			displayPrompt( repl, false );
		}
		return;
	}
	if ( repl._busy ) {
		debug( 'Waiting on an asynchronous command to finish...' );
		return;
	}
	debug( 'Evaluating next command...' );

	// Remove a command from the queue:
	code = repl._queue.pop();
	debug( 'Command: %s', code.raw );

	// TODO: check whether command begins with `await` or `for await` (the latter would allow for updating the last line of output; e.g., an ASCII chart!); if so, then async processing and set `busy` to true; otherwise, assume sync processing

	// Set the (non-standard) properties on the `RegExp` expression object to the cached matches:
	restoreRegExpMatches( repl._regexp );

	// TODO: evaluate and determine whether to print result
	opts = {
		'displayErrors': false,
		'breakOnSigint': true // Note: applies only for Node.js versions >=6.3.0
	};
	try {
		if ( repl._sandbox ) {
			res = code.compiled.runInContext( repl._context, opts );
		} else {
			res = code.compiled.runInThisContext( opts );
		}
		updateRegExpCache( repl._regexp );
	} catch ( error ) {
		updateRegExpCache( repl._regexp );

		// TODO: handle SIGINT (see https://github.com/nodejs/node/blob/b21e7c7bcf23a2715951e4cd96180e4dbf1dcd4d/lib/repl.js#L581)

		// TODO: check if error is recoverable
		debug( 'Error: %s', error.message );
		repl._ostream.write( 'Error: '+error.message+'\n' );
		displayPrompt( repl, false );
		return;
	}
	if ( code.silent === false && res !== void 0 ) {
		repl._ostream.write( inspect( res )+'\n' ); // TODO: pretty printing (can defer to `util.inspect` for now, but will invariably want more control over this later, possibly including default configuration, etc, either at startup, during runtime, or according to an external configuration file)
	}
	// Cache the result:
	repl._ans = res;

	// TODO: if successful, save the command in the history buffer and, if necessary, write to a history file

	// TODO: replace with polyfill
	process.nextTick( onTick );

	/**
	* Callback invoked upon the next tick of the event loop.
	*
	* @private
	*/
	function onTick() {
		drain( repl );
	}
}

/**
* Clears a REPL's local context.
*
* @private
* @param {REPL} repl - REPL instance
*/
function clear( repl ) {
	debug( 'Clearing the local REPL context...' );

	// Clear the command queue:
	repl._queue.clear();

	// Clear any command which has been buffered but not yet executed:
	repl._cmd.length = 0;

	// Clear the command history:
	repl._history.length = 0;

	// When sandboxed, create a new execution context...
	if ( repl._sandbox ) {
		repl._context = createNewContext( repl );
		repl.emit( 'reset', repl._context );
	}
	// Clear an output TTY stream of any previous commands and output:
	if ( repl._isTTY ) {
		/*
		* Clear the entire screen and scrollback history using [ANSI escape sequences][1].
		*
		* -   `\u001b`: ESC, the escape character
		* -   `[H`: move cursor to upper left corner
		* -   `[2J`: clear the entire screen
		* -   `[3J`: clear the entire screen and delete all lines in the scrollback buffer (note: possible portability issues)
		*
		* [1]: https://en.wikipedia.org/wiki/ANSI_escape_code
		*/
		repl._ostream.write( '\u001b[2J\u001b[H\u001b[2J\u001b[3J' );
	}
	// Display the command prompt:
	displayPrompt( repl, false );
}

/**
* Creates a REPL execution context.
*
* @private
* @param {REPL} repl - REPL instance
* @returns {Object} REPL context
*/
function createNewContext( repl ) {
	var context;

	debug( 'Creating REPL execution context...' );
	context = createContext({
		'sandbox': repl._sandbox,
		'output': repl._ostream
	});

	// Add commands requiring privileged access to internal instance variables:
	setNonEnumerableReadOnly( context, 'clear', onClear );
	setNonEnumerableReadOnly( context, 'load', onLoad );
	setNonEnumerableReadOnly( context, 'quit', onQuit );

	// TODO: add `help` command
	// TODO: add `example` command
	// TODO: add `namespace` command
	// TODO: add `save` command
	// TODO: add `recordStart` command
	// TODO: add `recordStop` command
	// TODO: add `citation` command
	// TODO: add `license` command
	// TODO: add `copyright` command
	// TODO: add `contributors` command
	// TODO: add `credits` command
	// TODO: add `donate` command

	// Add an accessor for retrieving the result of the last successfully executed command:
	setNonEnumerableReadOnlyAccessor( context, 'ans', onAns );

	return context;

	/**
	* Returns the result of the last successfully executed command.
	*
	* @private
	* @returns {*} result
	*/
	function onAns() {
		return repl._ans;
	}

	/**
	* Clears a REPL's local context.
	*
	* @private
	*/
	function onClear() {
		clear( repl );
	}

	/**
	* Loads and evaluates a JavaScript file line-by-line.
	*
	* @private
	* @param {string} fpath - file path
	* @returns {void}
	*/
	function onLoad( fpath ) {
		var err;
		if ( !isString( fpath ) ) {
			err = new TypeError( 'invalid argument. Must provide a string. Value: `'+fpath+'`.' );
			debug( 'Error: %s', err.message );
			repl._ostream.write( 'Error: '+err.message+'\n' );
			return;
		}
		debug( 'Loading a file...' );
		repl.load( fpath );
	}

	/**
	* Quits a REPL.
	*
	* @private
	*/
	function onQuit() {
		debug( 'Quitting the REPL...' );
		repl.close();
	}
}

/**
* Updates the cache of saved regular expression substring matches.
*
* @private
* @param {StringArray} cache - list of previously saved substring matches
* @returns {StringArray} cache
*/
function updateRegExpCache( cache ) {
	var i;
	for ( i = 1; i < cache.length; i++ ) {
		cache[ i ] = RegExp[ '$'+i ];
	}
	return cache;
}

/**
* Restores the (non-standard) properties on the `RegExp` expression object to the cached matches.
*
* @private
* @param {StringArray} cache - list of previously saved substring matches
*/
function restoreRegExpMatches( cache ) {
	RE_REGEXP_MATCHES.test( cache.join( SEP_REGEXP_MATCHES ) );
}


// MAIN //

/**
* REPL constructor.
*
* @param {Options} options - constructor options
* @param {string} [options.prompt='> '] - input prompt
* @param {ReadableStream} [options.input=process.stdin] - input stream
* @param {WritableStream} [options.output=process.stdout] - output stream
* @param {boolean} [options.sandbox=true] - boolean indicating whether to run a REPL in a sandboxed context
* @param {boolean} [options.isTTY] - boolean indicating whether the input and output streams should be treated like a TTY (terminal) and whether the REPL should use ANSI/VT100 escape codes when writing to the output stream
* @param {string} [options.welcome] - welcome message
* @param {string} [options.load] - file path specifying a JavaScript file to load and evaluate line-by-line (e.g., a previous REPL history file)
* @param {string} [options.save] - file path specifying where to save REPL history
* @throws {Error} must provide valid options
* @returns {REPL} REPL instance
*
* @example
* // TODO
*/
function REPL( options ) {
	var opts;
	var self;
	var err;

	if ( !( this instanceof REPL ) ) {
		if ( arguments.length ) {
			return new REPL( options );
		}
		return new REPL();
	}
	self = this;

	opts = defaults();
	if ( arguments.length ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.isTTY = ( opts.isTTY === void 0 ) ? opts.output.isTTY : opts.isTTY;

	debug( 'Options: %s', JSON.stringify({
		'input': '<readable_stream>',
		'output': '<writable_stream>',
		'sandbox': opts.sandbox,
		'isTTY': opts.isTTY,
		'prompt': opts.prompt,
		'welcome': opts.welcome,
		'load': opts.load,
		'save': opts.save
	}));

	// Call the parent constructor:
	EventEmitter.call( this );

	// Cache references to the input and output streams:
	setNonEnumerableReadOnly( this, '_istream', opts.input );
	setNonEnumerableReadOnly( this, '_ostream', opts.output );

	// Cache options:
	setNonEnumerableReadOnly( this, '_prompt', opts.prompt );
	setNonEnumerableReadOnly( this, '_isTTY', opts.isTTY );
	setNonEnumerableReadOnly( this, '_sandbox', opts.sandbox );

	// Initialize an internal command queue:
	setNonEnumerableReadOnly( this, '_queue', fifo() );

	// Initialize an internal buffer for storing the command history:
	setNonEnumerableReadOnly( this, '_history', [] );

	// Initialize an internal buffer for storing the current command:
	setNonEnumerableReadOnly( this, '_cmd', [] );

	// Initialize an internal buffer for saving regular expression matches between command evaluations:
	setNonEnumerableReadOnly( this, '_regexp', [ '', '', '', '', '', '', '', '', '', '' ] );

	// Initialize an internal flag indicating whether the REPL has been closed:
	setNonEnumerable( this, '_closed', false );

	// Initialize an internal flag indicating whether the REPL is currently busy with asynchronous processing:
	setNonEnumerable( this, '_busy', false );

	// Initialize an internal variable for caching the result of the last successfully evaluated command:
	setNonEnumerable( this, '_ans', void 0 );

	// Create an internal readline interface:
	debug( 'Creating readline interface...' );
	setNonEnumerableReadOnly( this, '_rli', readline.createInterface({
		'input': this._istream,
		'output': this._ostream,
		'terminal': opts.isTTY,
		'prompt': opts.prompt
	}));
	this._rli.on( 'close', onClose );
	this._rli.on( 'line', onLine );

	// Create a REPL execution context:
	setNonEnumerable( this, '_context', createNewContext( this ) );

	// Write a welcome message:
	this._ostream.write( opts.welcome );

	// TODO: check whether to synchronously initialize a REPL history file

	// Check whether to load and execute a JavaScript file (e.g., prior REPL history) upon startup...
	if ( opts.load ) {
		this.load( opts.load );
	} else {
		displayPrompt( this, false );
	}
	return this;

	/**
	* Callback invoked upon a readline interface "line" event.
	*
	* @private
	* @param {string} line - line data
	*/
	function onLine( line ) {
		processLine( self, line );
	}

	/**
	* Callback invoked upon a readline interface "close" event.
	*
	* @private
	*/
	function onClose() {
		debug( 'Readline interface closed.' );
		debug( 'Exiting the REPL...' );
		self.emit( 'exit' );
	}
}

/*
* Inherit from the `EventEmitter` prototype.
*/
inherit( REPL, EventEmitter );

/**
* Loads and evaluates a JavaScript file line-by-line.
*
* ## Notes
*
* -   The method **synchronously** reads provided files in order to preserve command order.
*
* @name load
* @memberof REPL.prototype
* @type {Function}
* @param {string} fpath - file path
* @throws {TypeError} must provide a string
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'load', function load( fpath ) {
	var file;
	var i;
	if ( !isString( fpath ) ) {
		throw new TypeError( 'invalid argument. Must provide a string. Value: `' + fpath + '`.' );
	}
	// Resolve the provided path to an absolute file path:
	fpath = resolve( cwd(), fpath );
	debug( 'Loading filepath: %s', fpath );

	// Attempt to synchronously read the file:
	file = readFileSync( fpath, 'utf8' );
	if ( file instanceof Error ) {
		debug( 'Error: %s', file.message );
		this._ostream.write( 'Error: '+file.message+'\n' );
		return this;
	}
	// Split the file content into individual lines:
	file = file.split( RE_EOL );

	// Forward each line to the REPL readline interface in order to mimic user input...
	for ( i = 0; i < file.length; i++ ) {
		this._rli.write( file[ i ] );
	}
	return this;
});

/**
* Clears a REPL's local context.
*
* @name clear
* @memberof REPL.prototype
* @type {Function}
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'clear', function onClear() {
	clear( this );
	return this;
});

/**
* Closes a REPL.
*
* @name close
* @memberof REPL.prototype
* @type {Function}
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'close', function close() {
	var self;
	if ( this._closed ) {
		debug( 'Attempted to close an already closed REPL.' );
		return this;
	}
	self = this;
	this._closed = true;

	// Clear the command queue:
	this._queue.clear();

	// TODO: ensure REPL history is saved (flushed) to file before closing the REPL (see https://github.com/nodejs/node/blob/b21e7c7bcf23a2715951e4cd96180e4dbf1dcd4d/lib/repl.js#L805)

	process.nextTick( onTick ); // TODO: replace with polyfill

	return this;

	/**
	* Callback invoked upon the next tick of the event loop.
	*
	* @private
	*/
	function onTick() {
		debug( 'Closing the readline interface...' );
		self._rli.close();
	}
});


// EXPORTS //

module.exports = REPL;
