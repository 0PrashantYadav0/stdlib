/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-restricted-syntax, no-invalid-this */

'use strict';

// MODULES //

var EventEmitter = require( 'events' ).EventEmitter;
var readline = require( 'readline' );
var resolve = require( 'path' ).resolve;
var vm = require( 'vm' );
var inspect = require( 'util' ).inspect;
var logger = require( 'debug' );
var inherit = require( '@stdlib/utils/inherit' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var setNonEnumerable = require( '@stdlib/utils/define-nonenumerable-property' );
var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var setNonEnumerableReadOnlyAccessor = require( '@stdlib/utils/define-nonenumerable-read-only-accessor' ); // eslint-disable-line id-length
var trim = require( '@stdlib/string/trim' );
var cwd = require( '@stdlib/process/cwd' );
var readFileSync = require( '@stdlib/fs/read-file' ).sync;
var RE_EOL = require( '@stdlib/regexp/eol' );
var fifo = require( '@stdlib/utils/fifo' );
var validate = require( './validate.js' );
var defaults = require( './defaults.js' );
var createContext = require( './create_context.js' );


// VARIABLES //

var debug = logger( 'repl' );
var SEMICOLON = 59; // character code
var RE_OPENING_BRACE = /^\s*\{/;
var RE_CLOSING_BRACE = /\}\s*$/;
var RE_WHITESPACE = /^\s*$/;

/*
* In certain JavaScript engines (e.g., V8, SpiderMonkey), the global `RegExp` object has ([non-standard][1]) static, read-only properties (`$1`, `$2`, ..., `$9`) with cached substring matches. In order to preserve these matches between command evaluations, we need to capture and subsequently restore them prior to evaluation.
*
* [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n
*/
var SEP_REGEXP_MATCHES = '\u0000\u0000\u0000';
var RE_REGEXP_MATCHES = new RegExp( [ '^', '(.*)', '(.*)', '(.*)', '(.*)', '(.*)', '(.*)', '(.*)', '(.*)', '(.*)$' ].join( SEP_REGEXP_MATCHES ) );


// FUNCTIONS //

/**
* Displays a command prompt.
*
* @private
* @param {ReadlineInterface} rli - readline interface
* @param {Array} cmd - command buffer
* @param {string} prompt - default prompt
* @param {boolean} [preserveCursor=false] - boolean indicating whether to preserve the cursor position
*/
function displayPrompt( rli, cmd, prompt, preserveCursor ) {
	var out;
	if ( cmd.length ) {
		// TODO: determine indentation level (use spaces)
		out = '';
	} else {
		out = prompt;
	}
	rli.setPrompt( out );
	rli.prompt( preserveCursor );
}

/**
* Updates the cache of saved regular expression substring matches.
*
* @private
* @param {StringArray} cache - list of previously saved substring matches
* @returns {StringArray} cache
*/
function updateRegExpCache( cache ) {
	var i;
	for ( i = 1; i < cache.length; i++ ) {
		cache[ i ] = RegExp[ '$'+i ];
	}
	return cache;
}

/**
* Restores the (non-standard) properties on the `RegExp` expression object to the cached matches.
*
* @private
* @param {StringArray} cache - list of previously saved substring matches
*/
function restoreRegExpMatches( cache ) {
	RE_REGEXP_MATCHES.test( cache.join( SEP_REGEXP_MATCHES ) );
}


// MAIN //

/**
* REPL constructor.
*
* @param {Options} options - constructor options
* @param {string} [options.prompt='> '] - input prompt
* @param {ReadableStream} [options.input=process.stdin] - input stream
* @param {WritableStream} [options.output=process.stdout] - output stream
* @param {boolean} [options.sandbox=true] - boolean indicating whether to run a REPL in a sandboxed context
* @param {boolean} [options.isTTY] - boolean indicating whether the input and output streams should be treated like a TTY (terminal) and whether the REPL should use ANSI/VT100 escape codes when writing to the output stream
* @param {string} [options.welcome] - welcome message
* @param {string} [options.load] - file path specifying a JavaScript file to load and evaluate line-by-line (e.g., a previous REPL history file)
* @param {string} [options.save] - file path specifying where to save REPL history
* @throws {Error} must provide valid options
* @returns {REPL} REPL instance
*
* @example
* // TODO
*/
function REPL( options ) {
	var SAVED_REGEXP_MATCHES;
	var istream;
	var ostream;
	var context;
	var history;
	var queue;
	var busy;
	var opts;
	var self;
	var cmd;
	var ans;
	var rli;
	var err;

	if ( !( this instanceof REPL ) ) {
		if ( arguments.length ) {
			return new REPL( options );
		}
		return new REPL();
	}
	self = this;

	opts = defaults();
	if ( arguments.length ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.isTTY = ( opts.isTTY === void 0 ) ? opts.output.isTTY : opts.isTTY;

	debug( 'Options: %s', JSON.stringify({
		'input': '<readable_stream>',
		'output': '<writable_stream>',
		'sandbox': opts.sandbox,
		'isTTY': opts.isTTY,
		'prompt': opts.prompt,
		'welcome': opts.welcome,
		'load': opts.load,
		'save': opts.save
	}));

	// Call the parent constructor:
	EventEmitter.call( this );

	// Cache references to the input and output streams:
	istream = opts.input;
	ostream = opts.output;

	// Initialize an array for storing the command history:
	history = [];

	// Initialize a "buffer" for storing the current command:
	cmd = [];

	// Initialize a flag indicating whether the REPL is currently busy with asynchronous processing:
	busy = false;

	// Initialize an array for saving regular expression matches between command evaluations:
	SAVED_REGEXP_MATCHES = [ '', '', '', '', '', '', '', '', '', '' ];

	// Create an internal readline interface:
	debug( 'Creating readline interface...' );
	rli = readline.createInterface({
		'input': istream,
		'output': ostream,
		'terminal': opts.isTTY,
		'prompt': opts.prompt
	});
	rli.on( 'close', onClose );
	rli.on( 'line', onLine );

	// Cache a reference to the readline interface:
	setNonEnumerableReadOnly( this, '_rli', rli );

	// Create an internal flag indicating whether the REPL has been closed:
	setNonEnumerable( this, '_closed', false );

	// Initialize a command queue:
	queue = fifo();
	setNonEnumerableReadOnly( this, '_queue', queue );

	// Add a public method for clearing a REPL:
	setNonEnumerableReadOnly( this, 'clear', clear );

	// Create a REPL execution context:
	createNewContext();

	// Write a welcome message:
	ostream.write( opts.welcome );

	// TODO: check whether to synchronously initialize a REPL history file

	// Check whether to load and execute a JavaScript file (e.g., prior REPL history) upon startup...
	if ( opts.load ) {
		this.load( opts.load );
	} else {
		displayPrompt( rli, cmd, opts.prompt, false );
	}
	return this;

	/**
	* Callback invoked upon receiving a readline interface "line" event.
	*
	* @private
	* @param {string} line - line data
	* @returns {void}
	*/
	function onLine( line ) {
		var isWrapped;
		var script;
		var sopts;
		var code;

		debug( 'Line: %s', line );

		// Removing leading and trailing whitespace:
		line = trim( line );

		// TODO: check if the line is valid JavaScript syntax; if yes, then proceed; otherwise, buffer the command in `cmd` buffer until ready to execute (e.g., when providing multi-line input)

		sopts = {
			'filename': '<repl>',
			'lineOffset': 0
		};
		code = {
			'raw': line
		};

		// Check for commands like object literals (e.g., `{'a':1}`), which we want to be evaluated as expressions, rather than blocks...
		if ( RE_OPENING_BRACE.test( line ) && RE_CLOSING_BRACE.test( line ) ) {
			// FIXME: we need to actually parse into an AST here and check if the last "expression" begins and ends with braces (e.g., `1+1; {'a':1}`); if so, we need to wrap the last expression in parentheses
			// FIXME: the above also fails to account for `{'a':1};`, which ends in a semicolon and not a brace
			// FIXME: the above also fails to account for expressions such as variable assignments (e.g., `var v = [1,2,3]`), where we may want to see the assigned value
			line = '(' + line + ')\n';
			isWrapped = true;
		}
		// Attempt to compile the command...
		while ( true ) {
			try {
				if ( RE_WHITESPACE.test( line ) ) {
					script = new vm.Script( line, sopts );
					code.silent = true;
				} else {
					// Note: `void 0` ensures that the compiled script does not return the string `'use strict'` when provided commands (statements/declarations) which do not return a value (e.g., `{}`):
					script = new vm.Script( '\'use strict\'; void 0;\n'+line, sopts );
					code.silent = line.charCodeAt( line.length-1 ) === SEMICOLON; // eslint-disable-line max-len
				}
				code.compiled = script;
			} catch ( error ) {
				// If we previously wrapped the command, unwrap and try again...
				if ( isWrapped ) {
					isWrapped = false;
					line = code.raw;
					continue;
				}
				// TODO: check if error is recoverable? And if so, update the command buffer; otherwise, write error message to console and display prompt.
				debug( 'Error: %s', error.message );
				ostream.write( 'Error: '+error.message+'\n' );
				displayPrompt( rli, cmd, opts.prompt, false );
				return;
			}
			break;
		}
		// Add the command to the command queue:
		queue.push( code );

		// Request to run the command:
		drain();
	}

	/**
	* Callback invoked upon a readline interface "close" event.
	*
	* @private
	*/
	function onClose() {
		debug( 'Readline interface closed.' );
		debug( 'Exiting the REPL...' );
		self.emit( 'exit' );
	}

	/**
	* Creates a REPL execution context.
	*
	* @private
	* @returns {Object} REPL context
	*/
	function createNewContext() {
		debug( 'Creating REPL execution context...' );

		// Create a new context:
		context = createContext({
			'sandbox': opts.sandbox,
			'output': ostream
		});

		// Add commands requiring privileged access to internal instance variables:
		setNonEnumerableReadOnly( context, 'clear', clear );
		setNonEnumerableReadOnly( context, 'load', load );
		setNonEnumerableReadOnly( context, 'quit', quit );

		// TODO: add `help` command
		// TODO: add `example` command
		// TODO: add `namespace` command
		// TODO: add `save` command
		// TODO: add `recordStart` command
		// TODO: add `recordStop` command
		// TODO: add `citation` command
		// TODO: add `license` command
		// TODO: add `copyright` command
		// TODO: add `contributors` command
		// TODO: add `credits` command
		// TODO: add `donate` command

		// Add an accessor for retrieving the result of the last successfully executed command:
		setNonEnumerableReadOnlyAccessor( context, 'ans', getLastAnswer );

		return context;
	}

	/**
	* Returns the result of the last successfully executed command.
	*
	* @private
	* @returns {*} result
	*/
	function getLastAnswer() {
		return ans;
	}

	/**
	* Drains the command queue.
	*
	* @private
	* @returns {void}
	*/
	function drain() {
		var sopts;
		var code;
		var res;

		if ( queue.length === 0 ) {
			debug( 'Command queue is empty.' );
			busy = false;
			if ( !self._closed ) { // eslint-disable-line no-underscore-dangle
				displayPrompt( rli, cmd, opts.prompt, false );
			}
			return;
		}
		if ( busy ) {
			debug( 'Waiting on an asynchronous command to finish...' );
			return;
		}
		debug( 'Evaluating next command...' );

		// Remove a command from the queue:
		code = queue.pop();
		debug( 'Command: %s', code.raw );

		// TODO: check whether command begins with `await` or `for await` (the latter would allow for updating the last line of output; e.g., an ASCII chart!); if so, then async processing and set `busy` to true; otherwise, assume sync processing

		// Set the (non-standard) properties on the `RegExp` expression object to the cached matches:
		restoreRegExpMatches( SAVED_REGEXP_MATCHES );

		// TODO: evaluate and determine whether to print result
		sopts = {
			'displayErrors': false,
			'breakOnSigint': true // Note: applies only for Node.js versions >=6.3.0
		};
		try {
			if ( opts.sandbox ) {
				res = code.compiled.runInContext( context, sopts );
			} else {
				res = code.compiled.runInThisContext( sopts );
			}
			updateRegExpCache( SAVED_REGEXP_MATCHES );
		} catch ( error ) {
			updateRegExpCache( SAVED_REGEXP_MATCHES );

			// TODO: handle SIGINT (see https://github.com/nodejs/node/blob/b21e7c7bcf23a2715951e4cd96180e4dbf1dcd4d/lib/repl.js#L581)

			// TODO: check if error is recoverable
			debug( 'Error: %s', error.message );
			ostream.write( 'Error: '+error.message+'\n' );
			displayPrompt( rli, cmd, opts.prompt, false );
			return;
		}
		if ( code.silent === false && res !== void 0 ) {
			ostream.write( inspect( res )+'\n' ); // TODO: pretty printing (can defer to `util.inspect` for now, but will invariably want more control over this later, possibly including default configuration, etc, either at startup, during runtime, or according to an external configuration file)
		}
		// Cache the result:
		ans = res;

		// TODO: if successful, save the command in the history buffer and, if necessary, write to a history file

		// TODO: replace with polyfill
		process.nextTick( drain );
	}

	/**
	* Clears the local context.
	*
	* @private
	*/
	function clear() {
		debug( 'Clearing the local REPL context...' );

		// Clear the command queue:
		queue.clear();

		// Clear any command which has been buffered but not yet executed:
		cmd.length = 0;

		// Clear the command history:
		history.length = 0;

		// When sandboxed, create a new execution context...
		if ( opts.sandbox ) {
			context = createNewContext();
			self.emit( 'reset', context );
		}
		// Clear an output TTY stream of any previous commands and output:
		if ( opts.isTTY ) {
			/*
			* Clear the entire screen and scrollback history using [ANSI escape sequences][1].
			*
			* -   `\u001b`: ESC, the escape character
			* -   `[H`: move cursor to upper left corner
			* -   `[2J`: clear the entire screen
			* -   `[3J`: clear the entire screen and delete all lines in the scrollback buffer
			*
			* [1]: https://en.wikipedia.org/wiki/ANSI_escape_code
			*/
			ostream.write( '\u001b[2J\u001b[H\u001b[2J\u001b[3J' );
		}
		// Display the command prompt:
		displayPrompt( rli, cmd, opts.prompt, false );
	}

	/**
	* Loads and evaluates a JavaScript file line-by-line.
	*
	* @private
	* @param {string} fpath - file path
	* @returns {void}
	*/
	function load( fpath ) {
		var err;
		if ( !isString( fpath ) ) {
			err = new TypeError( 'invalid argument. Must provide a string. Value: `'+fpath+'`.' );
			debug( 'Error: %s', err.message );
			ostream.write( 'Error: '+err.message+'\n' );
			return;
		}
		debug( 'Loading a file...' );
		self.load( fpath );
	}

	/**
	* Quits a REPL.
	*
	* @private
	*/
	function quit() {
		debug( 'Quitting the REPL...' );
		self.close();
	}
}

/*
* Inherit from the `EventEmitter` prototype.
*/
inherit( REPL, EventEmitter );

/**
* Loads and evaluates a JavaScript file line-by-line.
*
* ## Notes
*
* -   The method **synchronously** reads provided files in order to preserve command order.
*
* @name load
* @memberof REPL.prototype
* @type {Function}
* @param {string} fpath - file path
* @throws {TypeError} must provide a string
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'load', function load( fpath ) {
	var file;
	var i;
	if ( !isString( fpath ) ) {
		throw new TypeError( 'invalid argument. Must provide a string. Value: `' + fpath + '`.' );
	}
	// Resolve the provided path to an absolute file path:
	fpath = resolve( cwd(), fpath );
	debug( 'Loading filepath: %s', fpath );

	// Attempt to synchronously read the file:
	file = readFileSync( fpath, 'utf8' );
	if ( file instanceof Error ) {
		debug( 'Error: %s', file.message );
		this._ostream.write( 'Error: '+file.message+'\n' );
		return this;
	}
	// Split the file content into individual lines:
	file = file.split( RE_EOL );

	// Forward each line to the REPL readline interface in order to mimic user input...
	for ( i = 0; i < file.length; i++ ) {
		this._rli.write( file[ i ] );
	}
	return this;
});

/**
* Closes a REPL.
*
* @name close
* @memberof REPL.prototype
* @type {Function}
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'close', function close() {
	var self;
	if ( this._closed ) {
		debug( 'Attempted to close an already closed REPL.' );
		return this;
	}
	self = this;
	this._closed = true;

	// Clear the command queue:
	this._queue.clear();

	// TODO: ensure REPL history is saved (flushed) to file before closing the REPL (see https://github.com/nodejs/node/blob/b21e7c7bcf23a2715951e4cd96180e4dbf1dcd4d/lib/repl.js#L805)

	process.nextTick( onTick ); // TODO: replace with polyfill

	return this;

	/**
	* Callback invoked upon the next tick of the event loop.
	*
	* @private
	*/
	function onTick() {
		debug( 'Closing the readline interface...' );
		self._rli.close(); // eslint-disable-line no-underscore-dangle
	}
});


// EXPORTS //

module.exports = REPL;
