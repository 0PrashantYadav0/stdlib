/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-restricted-syntax, no-invalid-this, no-underscore-dangle */

'use strict';

// MODULES //

var EventEmitter = require( 'events' ).EventEmitter;
var readline = require( 'readline' ).createInterface;
var resolve = require( 'path' ).resolve;
var logger = require( 'debug' );
var inherit = require( '@stdlib/utils/inherit' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var setNonEnumerable = require( '@stdlib/utils/define-nonenumerable-property' );
var setNonEnumerableReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var cwd = require( '@stdlib/process/cwd' );
var readFileSync = require( '@stdlib/fs/read-file' ).sync;
var RE_EOL = require( '@stdlib/regexp/eol' );
var fifo = require( '@stdlib/utils/fifo' );
var validate = require( './validate.js' );
var defaults = require( './defaults.js' );
var displayPrompt = require( './display_prompt.js' );
var createContext = require( './create_context.js' );
var processLine = require( './process_line.js' );
var clear = require( './clear.js' );


// VARIABLES //

var debug = logger( 'repl' );


// MAIN //

/**
* REPL constructor.
*
* @constructor
* @param {Options} options - constructor options
* @param {string} [options.prompt='> '] - input prompt
* @param {ReadableStream} [options.input=process.stdin] - input stream
* @param {WritableStream} [options.output=process.stdout] - output stream
* @param {boolean} [options.sandbox=true] - boolean indicating whether to run a REPL in a sandboxed context
* @param {boolean} [options.isTTY] - boolean indicating whether the input and output streams should be treated like a TTY (terminal) and whether the REPL should use ANSI/VT100 escape codes when writing to the output stream
* @param {string} [options.welcome] - welcome message
* @param {string} [options.load] - file path specifying a JavaScript file to load and evaluate line-by-line (e.g., a previous REPL history file)
* @param {string} [options.save] - file path specifying where to save REPL history
* @throws {Error} must provide valid options
* @returns {REPL} REPL instance
*
* @example
* // TODO
*/
function REPL( options ) {
	var opts;
	var self;
	var err;

	if ( !( this instanceof REPL ) ) {
		if ( arguments.length ) {
			return new REPL( options );
		}
		return new REPL();
	}
	self = this;

	opts = defaults();
	if ( arguments.length ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	opts.isTTY = ( opts.isTTY === void 0 ) ? opts.output.isTTY : opts.isTTY;

	debug( 'Options: %s', JSON.stringify({
		'input': '<readable_stream>',
		'output': '<writable_stream>',
		'sandbox': opts.sandbox,
		'isTTY': opts.isTTY,
		'prompt': opts.prompt,
		'welcome': opts.welcome,
		'load': opts.load,
		'save': opts.save
	}));

	// Call the parent constructor:
	EventEmitter.call( this );

	// Cache references to the input and output streams:
	setNonEnumerableReadOnly( this, '_istream', opts.input );
	setNonEnumerableReadOnly( this, '_ostream', opts.output );

	// Cache options:
	setNonEnumerableReadOnly( this, '_prompt', opts.prompt );
	setNonEnumerableReadOnly( this, '_isTTY', opts.isTTY );
	setNonEnumerableReadOnly( this, '_sandbox', opts.sandbox );

	// Initialize an internal command queue:
	setNonEnumerableReadOnly( this, '_queue', fifo() );

	// Initialize an internal buffer for storing the command history:
	setNonEnumerableReadOnly( this, '_history', [] );

	// Initialize an internal buffer for storing the current command:
	setNonEnumerableReadOnly( this, '_cmd', [] );

	// Initialize an internal buffer for saving regular expression matches between command evaluations:
	setNonEnumerableReadOnly( this, '_regexp', [ '', '', '', '', '', '', '', '', '', '' ] );

	// For non-sandboxed REPLs, initialize an internal buffer for storing a list of global variables/properties which need to be deleted upon closing a REPL in order to allow garbage collection and prevent memory leaks:
	setNonEnumerableReadOnly( this, '_globalVars', ( this._sandbox ) ? null : [] );

	// Initialize a strided internal cache of resolved global variables/properties in order to allow, e.g., help text look-up based on object reference, not just alias name (note: members alternate between `'<string_alias>'` and `<resolved_value>`):
	setNonEnumerableReadOnly( this, '_aliases', [] );

	// Initialize an internal flag indicating whether the REPL has been closed:
	setNonEnumerable( this, '_closed', false );

	// Initialize an internal flag indicating whether the REPL is currently busy with asynchronous processing:
	setNonEnumerable( this, '_busy', false );

	// Initialize an internal variable for caching the result of the last successfully evaluated command:
	setNonEnumerable( this, '_ans', void 0 );

	// Create an internal readline interface:
	debug( 'Creating readline interface...' );
	setNonEnumerableReadOnly( this, '_rli', readline({
		'input': this._istream,
		'output': this._ostream,
		'terminal': opts.isTTY,
		'prompt': opts.prompt
	}));
	this._rli.on( 'close', onClose );
	this._rli.on( 'line', onLine );

	// Create a REPL execution context:
	setNonEnumerable( this, '_context', createContext( this ) );

	// Write a welcome message:
	this._ostream.write( opts.welcome );

	// TODO: check whether to synchronously initialize a REPL history file

	// Check whether to load and execute a JavaScript file (e.g., prior REPL history) upon startup...
	if ( opts.load ) {
		this.load( opts.load );
	} else {
		displayPrompt( this, false );
	}
	return this;

	/**
	* Callback invoked upon a readline interface "line" event.
	*
	* @private
	* @param {string} line - line data
	*/
	function onLine( line ) {
		if ( self._closed === false ) {
			processLine( self, line );
		}
	}

	/**
	* Callback invoked upon a readline interface "close" event.
	*
	* @private
	*/
	function onClose() {
		debug( 'Readline interface closed.' );
		debug( 'Exiting REPL...' );
		self.emit( 'exit' );
	}
}

/*
* Inherit from the `EventEmitter` prototype.
*/
inherit( REPL, EventEmitter );

/**
* Loads and evaluates a JavaScript file line-by-line.
*
* ## Notes
*
* -   The method **synchronously** reads provided files in order to preserve command order.
*
* @name load
* @memberof REPL.prototype
* @type {Function}
* @param {string} fpath - file path
* @throws {Error} cannot load a file into a closed REPL
* @throws {TypeError} must provide a string
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'load', function load( fpath ) {
	var file;
	var i;
	if ( this._closed ) {
		throw new Error( 'invalid operation. Cannot load a file into a REPL which has already closed.' );
	}
	if ( !isString( fpath ) ) {
		throw new TypeError( 'invalid argument. Must provide a string. Value: `' + fpath + '`.' );
	}
	// Resolve the provided path to an absolute file path:
	fpath = resolve( cwd(), fpath );
	debug( 'Loading filepath: %s', fpath );

	// Attempt to synchronously read the file:
	file = readFileSync( fpath, 'utf8' );
	if ( file instanceof Error ) {
		debug( 'Error: %s', file.message );
		this._ostream.write( 'Error: '+file.message+'\n' );
		return this;
	}
	// Split the file content into individual lines:
	file = file.split( RE_EOL );

	// Forward each line to the REPL readline interface in order to mimic user input...
	for ( i = 0; i < file.length; i++ ) {
		if ( file[ i ] ) {
			this._rli.write( file[ i ]+'\n' );
			displayPrompt( this, false );
		}
	}
	return this;
});

/**
* Clears a REPL's local context.
*
* @name clear
* @memberof REPL.prototype
* @type {Function}
* @throws {Error} cannot clear a closed REPL
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'clear', function onClear() {
	if ( this._closed ) {
		throw new Error( 'invalid operation. Cannot clear a REPL which has already closed.' );
	}
	clear( this );
	return this;
});

/**
* Closes a REPL.
*
* @name close
* @memberof REPL.prototype
* @type {Function}
* @returns {REPL} REPL instance
*/
setNonEnumerableReadOnly( REPL.prototype, 'close', function close() {
	var self;
	if ( this._closed ) {
		debug( 'Attempted to close an already closed REPL.' );
		return this;
	}
	self = this;
	this._closed = true;

	// Clear the command queue:
	this._queue.clear();

	// TODO: ensure REPL history is saved (flushed) to file before closing the REPL (see https://github.com/nodejs/node/blob/b21e7c7bcf23a2715951e4cd96180e4dbf1dcd4d/lib/repl.js#L805)

	// TODO: replace with polyfill
	process.nextTick( onTick );

	return this;

	/**
	* Callback invoked upon the next tick of the event loop.
	*
	* @private
	*/
	function onTick() {
		var key;
		var o;
		var i;
		var j;

		debug( 'Closing readline interface...' );
		self._rli.close();

		// If this is a non-sandboxed REPL, remove global variables/properties which were introduced during context creation...
		if ( self._sandbox === false ) {
			for ( i = 0; i < self._globalVars.length; i++ ) {
				o = self._context;
				key = self._globalVars[ i ].split( '.' ); // Note: this addresses nested key paths (e.g., `a.b.c`)
				for ( j = 0; j < key.length-1; j++ ) {
					o = o[ key[ j ] ];
				}
				delete o[ key[ j ] ];
			}
			self._globalVars.length = 0;
		}
	}
});


// EXPORTS //

module.exports = REPL;
