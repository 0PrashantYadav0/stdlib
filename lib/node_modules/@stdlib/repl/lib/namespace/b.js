'use strict';

/*
* When adding names to the namespace, ensure that they are added in alphabetical order according to alias (namespace key).
*/

var ns = [];

ns.push({
	'alias': 'base.abs',
	'path': '@stdlib/math/base/special/abs',
	'value': require( '@stdlib/math/base/special/abs' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.absdiff',
	'path': '@stdlib/math/base/utils/absolute-difference',
	'value': require( '@stdlib/math/base/utils/absolute-difference' ),
	'type': 'Function',
	'related': [
		'base.reldiff',
		'base.epsdiff'
	]
});

ns.push({
	'alias': 'base.acos',
	'path': '@stdlib/math/base/special/acos',
	'value': require( '@stdlib/math/base/special/acos' ),
	'type': 'Function',
	'related': [
		'base.acosh',
		'base.asin',
		'base.atan'
	]
});

ns.push({
	'alias': 'base.acosh',
	'path': '@stdlib/math/base/special/acosh',
	'value': require( '@stdlib/math/base/special/acosh' ),
	'type': 'Function',
	'related': [
		'base.acos',
		'base.asinh',
		'base.atanh'
	]
});

ns.push({
	'alias': 'base.asin',
	'path': '@stdlib/math/base/special/asin',
	'value': require( '@stdlib/math/base/special/asin' ),
	'type': 'Function',
	'related': [
		'base.acos',
		'base.asinh',
		'base.atan'
	]
});

ns.push({
	'alias': 'base.asinh',
	'path': '@stdlib/math/base/special/asinh',
	'value': require( '@stdlib/math/base/special/asinh' ),
	'type': 'Function',
	'related': [
		'base.acosh',
		'base.asin',
		'base.atanh'
	]
});

ns.push({
	'alias': 'base.atan',
	'path': '@stdlib/math/base/special/atan',
	'value': require( '@stdlib/math/base/special/atan' ),
	'type': 'Function',
	'related': [
		'base.acos',
		'base.asin',
		'base.atanh'
	]
});

ns.push({
	'alias': 'base.atan2',
	'path': '@stdlib/math/base/special/atan2',
	'value': require( '@stdlib/math/base/special/atan2' ),
	'type': 'Function',
	'related': [
		'base.atan'
	]
});

ns.push({
	'alias': 'base.atanh',
	'path': '@stdlib/math/base/special/atanh',
	'value': require( '@stdlib/math/base/special/atanh' ),
	'type': 'Function',
	'related': [
		'base.acosh',
		'base.asinh',
		'base.atan'
	]
});

ns.push({
	'alias': 'base.beta',
	'path': '@stdlib/math/base/special/beta',
	'value': require( '@stdlib/math/base/special/beta' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.betainc',
	'path': '@stdlib/math/base/special/betainc',
	'value': require( '@stdlib/math/base/special/betainc' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.betaincinv',
	'path': '@stdlib/math/base/special/betaincinv',
	'value': require( '@stdlib/math/base/special/betaincinv' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.betaln',
	'path': '@stdlib/math/base/special/betaln',
	'value': require( '@stdlib/math/base/special/betaln' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.binomcoef',
	'path': '@stdlib/math/base/special/binomcoef',
	'value': require( '@stdlib/math/base/special/binomcoef' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.binomcoefln',
	'path': '@stdlib/math/base/special/binomcoefln',
	'value': require( '@stdlib/math/base/special/binomcoefln' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.cbrt',
	'path': '@stdlib/math/base/special/cbrt',
	'value': require( '@stdlib/math/base/special/cbrt' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.ceil',
	'path': '@stdlib/math/base/special/ceil',
	'value': require( '@stdlib/math/base/special/ceil' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.continuedFraction',
	'path': '@stdlib/math/base/tools/continued-fraction',
	'value': require( '@stdlib/math/base/tools/continued-fraction' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.copysign',
	'path': '@stdlib/math/base/special/copysign',
	'value': require( '@stdlib/math/base/special/copysign' ),
	'type': 'Function',
	'related': [
		'base.flipsign'
	]
});

ns.push({
	'alias': 'base.cos',
	'path': '@stdlib/math/base/special/cos',
	'value': require( '@stdlib/math/base/special/cos' ),
	'type': 'Function',
	'related': [
		'base.cospi',
		'base.cosm1',
		'base.sin',
		'base.tan'
	]
});

ns.push({
	'alias': 'base.cosh',
	'path': '@stdlib/math/base/special/cosh',
	'value': require( '@stdlib/math/base/special/cosh' ),
	'type': 'Function',
	'related': [
		'base.cos',
		'base.sinh',
		'base.tanh'
	]
});

ns.push({
	'alias': 'base.cosm1',
	'path': '@stdlib/math/base/special/cosm1',
	'value': require( '@stdlib/math/base/special/cosm1' ),
	'type': 'Function',
	'related': [
		'base.cos'
	]
});

ns.push({
	'alias': 'base.cospi',
	'path': '@stdlib/math/base/special/cospi',
	'value': require( '@stdlib/math/base/special/cospi' ),
	'type': 'Function',
	'related': [
		'base.cos'
	]
});

ns.push({
	'alias': 'base.dasum',
	'path': '@stdlib/math/base/blas/dasum',
	'value': require( '@stdlib/math/base/blas/dasum' ),
	'type': 'Function',
	'related': [
		'base.daxpy',
		'base.dcopy'
	]
});

ns.push({
	'alias': 'base.daxpy',
	'path': '@stdlib/math/base/blas/daxpy',
	'value': require( '@stdlib/math/base/blas/daxpy' ),
	'type': 'Function',
	'related': [
		'base.dasum',
		'base.dcopy'
	]
});

ns.push({
	'alias': 'base.dcopy',
	'path': '@stdlib/math/base/blas/dcopy',
	'value': require( '@stdlib/math/base/blas/dcopy' ),
	'type': 'Function',
	'related': [
		'base.dasum',
		'base.daxpy'
	]
});

ns.push({
	'alias': 'base.deg2rad',
	'path': '@stdlib/math/base/special/deg2rad',
	'value': require( '@stdlib/math/base/special/deg2rad' ),
	'type': 'Function',
	'related': [
		'base.rad2deg'
	]
});

ns.push({
	'alias': 'base.digamma',
	'path': '@stdlib/math/base/special/digamma',
	'value': require( '@stdlib/math/base/special/digamma' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.epsdiff',
	'path': '@stdlib/math/base/utils/float64-epsilon-difference',
	'value': require( '@stdlib/math/base/utils/float64-epsilon-difference' ),
	'type': 'Function',
	'related': [
		'base.absdiff',
		'base.reldiff'
	]
});

ns.push({
	'alias': 'base.eta',
	'path': '@stdlib/math/base/special/dirichlet-eta',
	'value': require( '@stdlib/math/base/special/dirichlet-eta' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.erf',
	'path': '@stdlib/math/base/special/erf',
	'value': require( '@stdlib/math/base/special/erf' ),
	'type': 'Function',
	'related': [
		'base.erfc',
		'base.erfinv',
		'base.erfcinv'
	]
});

ns.push({
	'alias': 'base.erfc',
	'path': '@stdlib/math/base/special/erfc',
	'value': require( '@stdlib/math/base/special/erfc' ),
	'type': 'Function',
	'related': [
		'base.erf',
		'base.erfinv',
		'base.erfcinv'
	]
});

ns.push({
	'alias': 'base.erfcinv',
	'path': '@stdlib/math/base/special/erfcinv',
	'value': require( '@stdlib/math/base/special/erfcinv' ),
	'type': 'Function',
	'related': [
		'base.erf',
		'base.erfc',
		'base.erfinv'
	]
});

ns.push({
	'alias': 'base.erfinv',
	'path': '@stdlib/math/base/special/erfinv',
	'value': require( '@stdlib/math/base/special/erfinv' ),
	'type': 'Function',
	'related': [
		'base.erf',
		'base.erfc',
		'base.erfcinv'
	]
});

ns.push({
	'alias': 'base.evalpoly',
	'path': '@stdlib/math/base/tools/evalpoly',
	'value': require( '@stdlib/math/base/tools/evalpoly' ),
	'type': 'Function',
	'related': [
		'base.evalrational'
	]
});

ns.push({
	'alias': 'base.evalrational',
	'path': '@stdlib/math/base/tools/evalrational',
	'value': require( '@stdlib/math/base/tools/evalrational' ),
	'type': 'Function',
	'related': [
		'base.evalpoly'
	]
});

ns.push({
	'alias': 'base.exp',
	'path': '@stdlib/math/base/special/exp',
	'value': require( '@stdlib/math/base/special/exp' ),
	'type': 'Function',
	'related': [
		'base.exp10',
		'base.exp2',
		'base.expm1',
		'base.ln'
	]
});

ns.push({
	'alias': 'base.exponent',
	'path': '@stdlib/math/base/utils/float64-exponent',
	'value': require( '@stdlib/math/base/utils/float64-exponent' ),
	'type': 'Function',
	'related': [
		'base.exponentf'
	]
});

ns.push({
	'alias': 'base.exponentf',
	'path': '@stdlib/math/base/utils/float32-exponent',
	'value': require( '@stdlib/math/base/utils/float32-exponent' ),
	'type': 'Function',
	'related': [
		'base.exponent'
	]
});

ns.push({
	'alias': 'base.exp10',
	'path': '@stdlib/math/base/special/exp10',
	'value': require( '@stdlib/math/base/special/exp10' ),
	'type': 'Function',
	'related': [
		'base.exp',
		'base.exp2'
	]
});

ns.push({
	'alias': 'base.exp2',
	'path': '@stdlib/math/base/special/exp2',
	'value': require( '@stdlib/math/base/special/exp2' ),
	'type': 'Function',
	'related': [
		'base.exp',
		'base.exp10'
	]
});

ns.push({
	'alias': 'base.expm1',
	'path': '@stdlib/math/base/special/expm1',
	'value': require( '@stdlib/math/base/special/expm1' ),
	'type': 'Function',
	'related': [
		'base.exp'
	]
});

ns.push({
	'alias': 'base.factorial',
	'path': '@stdlib/math/base/special/factorial',
	'value': require( '@stdlib/math/base/special/factorial' ),
	'type': 'Function',
	'related': [
		'base.factorialln'
	]
});

ns.push({
	'alias': 'base.flipsign',
	'path': '@stdlib/math/base/special/flipsign',
	'value': require( '@stdlib/math/base/special/flipsign' ),
	'type': 'Function',
	'related': [
		'base.copysign'
	]
});

ns.push({
	'alias': 'base.floor',
	'path': '@stdlib/math/base/special/floor',
	'value': require( '@stdlib/math/base/special/floor' ),
	'type': 'Function',
	'related': [
		'base.ceil',
		'base.round'
	]
});

ns.push({
	'alias': 'base.float64ToFloat32',
	'path': '@stdlib/math/base/utils/float64-to-float32',
	'value': require( '@stdlib/math/base/utils/float64-to-float32' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.float64ToInt32',
	'path': '@stdlib/math/base/utils/float64-to-Int32',
	'value': require( '@stdlib/math/base/utils/float64-to-Int32' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.float64ToUint32',
	'path': '@stdlib/math/base/utils/float64-to-Uint32',
	'value': require( '@stdlib/math/base/utils/float64-to-Uint32' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.frexp',
	'path': '@stdlib/math/base/special/frexp',
	'value': require( '@stdlib/math/base/special/frexp' ),
	'type': 'Function',
	'related': [
		'base.ldexp'
	]
});

ns.push({
	'alias': 'base.fromBinaryString',
	'path': '@stdlib/math/base/utils/float64-from-binary-string',
	'value': require( '@stdlib/math/base/utils/float64-from-binary-string' ),
	'type': 'Function',
	'related': [
		'base.fromBinaryStringf'
	]
});

ns.push({
	'alias': 'base.fromBinaryStringf',
	'path': '@stdlib/math/base/utils/float32-from-binary-string',
	'value': require( '@stdlib/math/base/utils/float32-from-binary-string' ),
	'type': 'Function',
	'related': [
		'base.fromBinaryString'
	]
});

ns.push({
	'alias': 'base.fromWordf',
	'path': '@stdlib/math/base/utils/float32-from-word',
	'value': require( '@stdlib/math/base/utils/float32-from-word' ),
	'type': 'Function',
	'related': [
		'base.fromWords'
	]
});

ns.push({
	'alias': 'base.fromWords',
	'path': '@stdlib/math/base/utils/float64-from-words',
	'value': require( '@stdlib/math/base/utils/float64-from-words' ),
	'type': 'Function',
	'related': [
		'base.fromWordf'
	]
});

ns.push({
	'alias': 'base.gamma',
	'path': '@stdlib/math/base/special/gamma',
	'value': require( '@stdlib/math/base/special/gamma' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.gammainc',
	'path': '@stdlib/math/base/special/gammainc',
	'value': require( '@stdlib/math/base/special/gammainc' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.gammaincinv',
	'path': '@stdlib/math/base/special/gammaincinv',
	'value': require( '@stdlib/math/base/special/gammaincinv' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.gammaln',
	'path': '@stdlib/math/base/special/gammaln',
	'value': require( '@stdlib/math/base/special/gammaln' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.gcd',
	'path': '@stdlib/math/base/special/gcd',
	'value': require( '@stdlib/math/base/special/gcd' ),
	'type': 'Function',
	'related': [
		'base.lcm'
	]
});

ns.push({
	'alias': 'base.getHighWord',
	'path': '@stdlib/math/base/utils/float64-get-high-word',
	'value': require( '@stdlib/math/base/utils/float64-get-high-word' ),
	'type': 'Function',
	'related': [
		'base.getLowWord',
		'base.setHighWord'
	]
});

ns.push({
	'alias': 'base.getLowWord',
	'path': '@stdlib/math/base/utils/float64-get-low-word',
	'value': require( '@stdlib/math/base/utils/float64-get-low-word' ),
	'type': 'Function',
	'related': [
		'base.getHighWord',
		'base.setHighWord'
	]
});

ns.push({
	'alias': 'base.hypot',
	'path': '@stdlib/math/base/special/hypot',
	'value': require( '@stdlib/math/base/special/hypot' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.isEven',
	'path': '@stdlib/math/base/utils/is-even',
	'value': require( '@stdlib/math/base/utils/is-even' ),
	'type': 'Function',
	'related': [
		'base.isOdd'
	]
});

ns.push({
	'alias': 'base.isEvenInt32',
	'path': '@stdlib/math/base/utils/int32-is-even',
	'value': require( '@stdlib/math/base/utils/int32-is-even' ),
	'type': 'Function',
	'related': [
		'base.isEven',
		'base.isOddInt32'
	]
});

ns.push({
	'alias': 'base.isFinite',
	'path': '@stdlib/math/base/utils/is-finite',
	'value': require( '@stdlib/math/base/utils/is-finite' ),
	'type': 'Function',
	'related': [
		'base.isInfinite'
	]
});

ns.push({
	'alias': 'base.isInfinite',
	'path': '@stdlib/math/base/utils/is-infinite',
	'value': require( '@stdlib/math/base/utils/is-infinite' ),
	'type': 'Function',
	'related': [
		'base.isFinite'
	]
});

ns.push({
	'alias': 'base.isInteger',
	'path': '@stdlib/math/base/utils/is-integer',
	'value': require( '@stdlib/math/base/utils/is-integer' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.isnan',
	'path': '@stdlib/math/base/utils/is-nan',
	'value': require( '@stdlib/math/base/utils/is-nan' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.isNegativeInteger',
	'path': '@stdlib/math/base/utils/is-negative-integer',
	'value': require( '@stdlib/math/base/utils/is-negative-integer' ),
	'type': 'Function',
	'related': [
		'base.isInteger',
		'base.isNonNegativeInteger',
		'base.isNonPositiveInteger',
		'base.isPositiveInteger'
	]
});

ns.push({
	'alias': 'base.isNegativeZero',
	'path': '@stdlib/math/base/utils/is-negative-zero',
	'value': require( '@stdlib/math/base/utils/is-negative-zero' ),
	'type': 'Function',
	'related': [
		'base.isPositiveZero'
	]
});

ns.push({
	'alias': 'base.isNonNegativeInteger',
	'path': '@stdlib/math/base/utils/is-nonnegative-integer',
	'value': require( '@stdlib/math/base/utils/is-nonnegative-integer' ),
	'type': 'Function',
	'related': [
		'base.isInteger',
		'base.isNegativeInteger',
		'base.isNonPositiveInteger',
		'base.isPositiveInteger'
	]
});

ns.push({
	'alias': 'base.isNonPositiveInteger',
	'path': '@stdlib/math/base/utils/is-nonpositive-integer',
	'value': require( '@stdlib/math/base/utils/is-nonpositive-integer' ),
	'type': 'Function',
	'related': [
		'base.isInteger',
		'base.isNegativeInteger',
		'base.isNonNegativeInteger',
		'base.isPositiveInteger'
	]
});

ns.push({
	'alias': 'base.isOdd',
	'path': '@stdlib/math/base/utils/is-odd',
	'value': require( '@stdlib/math/base/utils/is-odd' ),
	'type': 'Function',
	'related': [
		'base.isEven'
	]
});

ns.push({
	'alias': 'base.isOddInt32',
	'path': '@stdlib/math/base/utils/int32-is-odd',
	'value': require( '@stdlib/math/base/utils/int32-is-odd' ),
	'type': 'Function',
	'related': [
		'base.isEvenInt32',
		'base.isOdd'
	]
});

ns.push({
	'alias': 'base.isPositiveInteger',
	'path': '@stdlib/math/base/utils/is-positive-integer',
	'value': require( '@stdlib/math/base/utils/is-positive-integer' ),
	'type': 'Function',
	'related': [
		'base.isInteger',
		'base.isNegativeInteger',
		'base.isNonNegativeInteger',
		'base.isNonPositiveInteger'
	]
});

ns.push({
	'alias': 'base.isPositiveZero',
	'path': '@stdlib/math/base/utils/is-positive-zero',
	'value': require( '@stdlib/math/base/utils/is-positive-zero' ),
	'type': 'Function',
	'related': [
		'base.isNegativeZero'
	]
});

ns.push({
	'alias': 'base.isProbability',
	'path': '@stdlib/math/base/utils/is-probability',
	'value': require( '@stdlib/math/base/utils/is-probability' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.isSafeInteger',
	'path': '@stdlib/math/base/utils/is-safe-integer',
	'value': require( '@stdlib/math/base/utils/is-safe-integer' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.labs',
	'path': '@stdlib/math/base/special/int32-abs',
	'value': require( '@stdlib/math/base/special/int32-abs' ),
	'type': 'Function',
	'related': [
		'base.abs'
	]
});

ns.push({
	'alias': 'base.lcm',
	'path': '@stdlib/math/base/special/lcm',
	'value': require( '@stdlib/math/base/special/lcm' ),
	'type': 'Function',
	'related': [
		'base.gcd'
	]
});

ns.push({
	'alias': 'base.ldexp',
	'path': '@stdlib/math/base/special/ldexp',
	'value': require( '@stdlib/math/base/special/ldexp' ),
	'type': 'Function',
	'related': [
		'base.frexp'
	]
});

ns.push({
	'alias': 'base.ln',
	'path': '@stdlib/math/base/special/ln',
	'value': require( '@stdlib/math/base/special/ln' ),
	'type': 'Function',
	'related': [
		'base.exp',
		'base.log10',
		'base.log1p',
		'base.log2'
	]
});

ns.push({
	'alias': 'base.log10',
	'path': '@stdlib/math/base/special/log10',
	'value': require( '@stdlib/math/base/special/log10' ),
	'type': 'Function',
	'related': [
		'base.exp10',
		'base.ln'
	]
});

ns.push({
	'alias': 'base.log1p',
	'path': '@stdlib/math/base/special/log1p',
	'value': require( '@stdlib/math/base/special/log1p' ),
	'type': 'Function',
	'related': [
		'base.ln'
	]
});

ns.push({
	'alias': 'base.log2',
	'path': '@stdlib/math/base/special/log2',
	'value': require( '@stdlib/math/base/special/log2' ),
	'type': 'Function',
	'related': [
		'base.exp2',
		'base.ln'
	]
});

ns.push({
	'alias': 'base.logit',
	'path': '@stdlib/math/base/special/logit',
	'value': require( '@stdlib/math/base/special/logit' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.max',
	'path': '@stdlib/math/base/special/max',
	'value': require( '@stdlib/math/base/special/max' ),
	'type': 'Function',
	'related': [
		'base.min'
	]
});

ns.push({
	'alias': 'base.min',
	'path': '@stdlib/math/base/special/min',
	'value': require( '@stdlib/math/base/special/min' ),
	'type': 'Function',
	'related': [
		'base.max'
	]
});

ns.push({
	'alias': 'base.modf',
	'path': '@stdlib/math/base/special/modf',
	'value': require( '@stdlib/math/base/special/modf' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.normalize',
	'path': '@stdlib/math/base/utils/float64-normalize',
	'value': require( '@stdlib/math/base/utils/float64-normalize' ),
	'type': 'Function',
	'related': [
		'base.normalizef'
	]
});

ns.push({
	'alias': 'base.normalizef',
	'path': '@stdlib/math/base/utils/float32-normalize',
	'value': require( '@stdlib/math/base/utils/float32-normalize' ),
	'type': 'Function',
	'related': [
		'base.normalize'
	]
});

ns.push({
	'alias': 'base.pdiff',
	'path': '@stdlib/math/base/special/pdiff',
	'value': require( '@stdlib/math/base/special/pdiff' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.pow',
	'path': '@stdlib/math/base/special/pow',
	'value': require( '@stdlib/math/base/special/pow' ),
	'type': 'Function',
	'related': [
		'base.exp',
		'base.powm1'
	]
});

ns.push({
	'alias': 'base.powm1',
	'path': '@stdlib/math/base/special/powm1',
	'value': require( '@stdlib/math/base/special/powm1' ),
	'type': 'Function',
	'related': [
		'base.pow'
	]
});

ns.push({
	'alias': 'base.rad2deg',
	'path': '@stdlib/math/base/special/rad2deg',
	'value': require( '@stdlib/math/base/special/rad2deg' ),
	'type': 'Function',
	'related': [
		'base.deg2rad'
	]
});

ns.push({
	'alias': 'base.random.beta',
	'path': '@stdlib/math/base/random/beta',
	'value': require( '@stdlib/math/base/random/beta' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.binomial',
	'path': '@stdlib/math/base/random/binomial',
	'value': require( '@stdlib/math/base/random/binomial' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.boxMuller',
	'path': '@stdlib/math/base/random/box)-muller',
	'value': require( '@stdlib/math/base/random/box-muller' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.cauchy',
	'path': '@stdlib/math/base/random/cauchy',
	'value': require( '@stdlib/math/base/random/cauchy' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.chisquare',
	'path': '@stdlib/math/base/random/chisquare',
	'value': require( '@stdlib/math/base/random/chisquare' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.erlang',
	'path': '@stdlib/math/base/random/erlang',
	'value': require( '@stdlib/math/base/random/erlang' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.exponential',
	'path': '@stdlib/math/base/random/exponential',
	'value': require( '@stdlib/math/base/random/exponential' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.f',
	'path': '@stdlib/math/base/random/f',
	'value': require( '@stdlib/math/base/random/f' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.gamma',
	'path': '@stdlib/math/base/random/gamma',
	'value': require( '@stdlib/math/base/random/gamma' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.geometric',
	'path': '@stdlib/math/base/random/geometric',
	'value': require( '@stdlib/math/base/random/geometric' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.gumbel',
	'path': '@stdlib/math/base/random/gumbel',
	'value': require( '@stdlib/math/base/random/gumbel' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.hypergeometric',
	'path': '@stdlib/math/base/random/hypergeometric',
	'value': require( '@stdlib/math/base/random/hypergeometric' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.improvedZiggurat',
	'path': '@stdlib/math/base/random/improved-ziggurat',
	'value': require( '@stdlib/math/base/random/improved-ziggurat' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.invgamma',
	'path': '@stdlib/math/base/random/invgamma',
	'value': require( '@stdlib/math/base/random/invgamma' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.laplace',
	'path': '@stdlib/math/base/random/laplace',
	'value': require( '@stdlib/math/base/random/laplace' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.logistic',
	'path': '@stdlib/math/base/random/logistic',
	'value': require( '@stdlib/math/base/random/logistic' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.lognormal',
	'path': '@stdlib/math/base/random/lognormal',
	'value': require( '@stdlib/math/base/random/lognormal' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.minstd',
	'path': '@stdlib/math/base/random/minstd',
	'value': require( '@stdlib/math/base/random/minstd' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.minstdShuffle',
	'path': '@stdlib/math/base/random/minstd-shuffle',
	'value': require( '@stdlib/math/base/random/minstd-shuffle' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.negativeBinomial',
	'path': '@stdlib/math/base/random/negative-binomial',
	'value': require( '@stdlib/math/base/random/negative-binomial' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.normal',
	'path': '@stdlib/math/base/random/normal',
	'value': require( '@stdlib/math/base/random/normal' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.pareto1',
	'path': '@stdlib/math/base/random/pareto-type1',
	'value': require( '@stdlib/math/base/random/pareto-type1' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.poisson',
	'path': '@stdlib/math/base/random/poisson',
	'value': require( '@stdlib/math/base/random/poisson' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.randn',
	'path': '@stdlib/math/base/random/randn',
	'value': require( '@stdlib/math/base/random/randn' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.randu',
	'path': '@stdlib/math/base/random/randu',
	'value': require( '@stdlib/math/base/random/randu' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.rayleigh',
	'path': '@stdlib/math/base/random/rayleigh',
	'value': require( '@stdlib/math/base/random/rayleigh' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.t',
	'path': '@stdlib/math/base/random/t',
	'value': require( '@stdlib/math/base/random/t' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.triangular',
	'path': '@stdlib/math/base/random/triangular',
	'value': require( '@stdlib/math/base/random/triangular' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.uniform',
	'path': '@stdlib/math/base/random/uniform',
	'value': require( '@stdlib/math/base/random/uniform' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.random.weibull',
	'path': '@stdlib/math/base/random/weibull',
	'value': require( '@stdlib/math/base/random/weibull' ),
	'type': 'Function',
	'related': [
		'base.random'
	]
});

ns.push({
	'alias': 'base.reldiff',
	'path': '@stdlib/math/base/utils/relative-difference',
	'value': require( '@stdlib/math/base/utils/relative-difference' ),
	'type': 'Function',
	'related': [
		'base.absdiff',
		'base.epsdiff'
	]
});

ns.push({
	'alias': 'base.round',
	'path': '@stdlib/math/base/special/round',
	'value': require( '@stdlib/math/base/special/round' ),
	'type': 'Function',
	'related': [
		'base.ceil',
		'base.floor',
		'base.roundn'
	]
});

ns.push({
	'alias': 'base.roundn',
	'path': '@stdlib/math/base/special/roundn',
	'value': require( '@stdlib/math/base/special/roundn' ),
	'type': 'Function',
	'related': [
		'base.round'
	]
});

ns.push({
	'alias': 'base.setHighWord',
	'path': '@stdlib/math/base/utils/float64-set-high-word',
	'value': require( '@stdlib/math/base/utils/float64-set-high-word' ),
	'type': 'Function',
	'related': [
		'base.getHighWord',
		'base.setLowWord'
	]
});

ns.push({
	'alias': 'base.setLowWord',
	'path': '@stdlib/math/base/utils/float64-set-low-word',
	'value': require( '@stdlib/math/base/utils/float64-set-low-word' ),
	'type': 'Function',
	'related': [
		'base.getLowWord',
		'base.setHighWord'
	]
});

ns.push({
	'alias': 'base.signbit',
	'path': '@stdlib/math/base/utils/float64-signbit',
	'value': require( '@stdlib/math/base/utils/float64-signbit' ),
	'type': 'Function',
	'related': [
		'base.signbitf'
	]
});

ns.push({
	'alias': 'base.signbitf',
	'path': '@stdlib/math/base/utils/float32-signbit',
	'value': require( '@stdlib/math/base/utils/float32-signbit' ),
	'type': 'Function',
	'related': [
		'base.signbit'
	]
});

ns.push({
	'alias': 'base.significandf',
	'path': '@stdlib/math/base/utils/float32-significand',
	'value': require( '@stdlib/math/base/utils/float32-significand' ),
	'type': 'Function',
	'related': [
		'base.significand'
	]
});

ns.push({
	'alias': 'base.signum',
	'path': '@stdlib/math/base/special/signum',
	'value': require( '@stdlib/math/base/special/signum' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.sin',
	'path': '@stdlib/math/base/special/sin',
	'value': require( '@stdlib/math/base/special/sin' ),
	'type': 'Function',
	'related': [
		'base.cos',
		'base.sinpi',
		'base.tan'
	]
});

ns.push({
	'alias': 'base.sinh',
	'path': '@stdlib/math/base/special/sinh',
	'value': require( '@stdlib/math/base/special/sinh' ),
	'type': 'Function',
	'related': [
		'base.cosh',
		'base.sin',
		'base.tanh'
	]
});

ns.push({
	'alias': 'base.sinpi',
	'path': '@stdlib/math/base/special/sinpi',
	'value': require( '@stdlib/math/base/special/sinpi' ),
	'type': 'Function',
	'related': [
		'base.sin'
	]
});

ns.push({
	'alias': 'base.sqrt',
	'path': '@stdlib/math/base/special/sqrt',
	'value': require( '@stdlib/math/base/special/sqrt' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.sumSeries',
	'path': '@stdlib/math/base/tools/sum-series',
	'value': require( '@stdlib/math/base/tools/sum-series' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.tan',
	'path': '@stdlib/math/base/special/tan',
	'value': require( '@stdlib/math/base/special/tan' ),
	'type': 'Function',
	'related': [
		'base.cos',
		'base.sin'
	]
});

ns.push({
	'alias': 'base.tanh',
	'path': '@stdlib/math/base/special/tanh',
	'value': require( '@stdlib/math/base/special/tanh' ),
	'type': 'Function',
	'related': [
		'base.cosh',
		'base.sinh',
		'base.tan'
	]
});

ns.push({
	'alias': 'base.toBinaryString',
	'path': '@stdlib/math/base/utils/float64-to-binary-string',
	'value': require( '@stdlib/math/base/utils/float64-to-binary-string' ),
	'type': 'Function',
	'related': [
		'base.fromBinaryString',
		'base.toBinaryStringf'
	]
});

ns.push({
	'alias': 'base.toBinaryStringf',
	'path': '@stdlib/math/base/utils/float32-to-binary-string',
	'value': require( '@stdlib/math/base/utils/float32-to-binary-string' ),
	'type': 'Function',
	'related': [
		'base.fromBinaryStringf',
		'base.toBinaryString'
	]
});

ns.push({
	'alias': 'base.toBinaryStringUint16',
	'path': '@stdlib/math/base/utils/uint16-to-binary-string',
	'value': require( '@stdlib/math/base/utils/uint16-to-binary-string' ),
	'type': 'Function',
	'related': [
		'base.toBinaryString'
	]
});

ns.push({
	'alias': 'base.toBinaryStringUint32',
	'path': '@stdlib/math/base/utils/uint32-to-binary-string',
	'value': require( '@stdlib/math/base/utils/uint32-to-binary-string' ),
	'type': 'Function',
	'related': [
		'base.toBinaryString'
	]
});

ns.push({
	'alias': 'base.toBinaryStringUint8',
	'path': '@stdlib/math/base/utils/uint8-to-binary-string',
	'value': require( '@stdlib/math/base/utils/uint8-to-binary-string' ),
	'type': 'Function',
	'related': [
		'base.toBinaryString'
	]
});

ns.push({
	'alias': 'base.toWordf',
	'path': '@stdlib/math/base/utils/float32-to-word',
	'value': require( '@stdlib/math/base/utils/float32-to-word' ),
	'type': 'Function',
	'related': [
		'base.fromWordf',
		'base.toWords'
	]
});

ns.push({
	'alias': 'base.toWords',
	'path': '@stdlib/math/base/utils/float64-to-words',
	'value': require( '@stdlib/math/base/utils/float64-to-words' ),
	'type': 'Function',
	'related': [
		'base.fromWords',
		'base.toWordf'
	]
});

ns.push({
	'alias': 'base.truncate',
	'path': '@stdlib/math/base/special/truncate',
	'value': require( '@stdlib/math/base/special/truncate' ),
	'type': 'Function',
	'related': [
		'base.ceil',
		'base.floor',
		'base.round'
	]
});

ns.push({
	'alias': 'base.uint32ToInt32',
	'path': '@stdlib/math/base/utils/uint32-to-int32',
	'value': require( '@stdlib/math/base/utils/uint32-to-int32' ),
	'type': 'Function',
	'related': []
});

ns.push({
	'alias': 'base.zeta',
	'path': '@stdlib/math/base/special/riemann-zeta',
	'value': require( '@stdlib/math/base/special/riemann-zeta' ),
	'type': 'Function',
	'related': []
});


// EXPORTS //

module.exports = ns;
