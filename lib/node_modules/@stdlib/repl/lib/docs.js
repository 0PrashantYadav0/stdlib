// This file is generated by scripts/build.js.
'use strict';

/* eslint-disable quotes */

module.exports = {
	"base.dasum": "\nbase.dasum( N, x, stride )\n    Compute the sum of the absolute values.\n\n    The sum of absolute values corresponds to the *L1* normm.\n\n    The `N` and `stride` parameters determine which elements in `x` are used to\n    compute the sum.\n\n    Indexing is relative to the first index. To introduce an offset, use typed\n    array views.\n\n    If `N` or `stride` is less than `0`, the function returns `0`.\n\n    Parameters\n    ----------\n    N: integer\n        Number of elements to sum.\n\n    x: Array|TypedArray\n        Input array.\n\n    stride: integer\n        Index increment.\n\n    Returns\n    -------\n    sum: double\n        Sum of absolute values.\n\n    Examples\n    --------\n    // Standard usage:\n    > var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];\n\n    > var sum = base.dasum( x.length, x, 1 );\n    19.0\n\n    // Sum every other value:\n    > var N = floor( x.length / 2 );\n\n    > var stride = 2;\n\n    > sum = base.dasum( N, x, stride );\n    10.0\n\n    // Use view offset; e.g., starting at 2nd element:\n    > var x0 = new Float64Array( [ 1.0, -2.0, 3.0, -4.0, 5.0, -6.0 ] );\n\n    > var x1 = new Float64Array( x0.buffer, x0.BYTES_PER_ELEMENT*1 );\n\n    > N = floor( x0.length / 2 );\n\n    > sum = base.dasum( N, x1, stride );\n    12.0\n\n\nbase.dasum.ndarray( N, x, stride, offset )\n    Computes the sum of absolute values using alternative indexing semantics.\n\n    While typed array views mandate a view offset based on the underlying\n    buffer, the `offset` parameter supports indexing semantics based on a\n    starting index.\n\n    Parameters\n    ----------\n    N: integer\n        Number of elements to sum.\n\n    x: Array|TypedArray\n        Input array.\n\n    stride: integer\n        Index increment.\n\n    offset: integer\n        Starting index.\n\n    Returns\n    -------\n    sum: double\n        Sum of absolute values.\n\n    Examples\n    --------\n    // Standard usage:\n    > var x = [ -2.0, 1.0, 3.0, -5.0, 4.0, 0.0, -1.0, -3.0 ];\n\n    > var sum = base.dasum.ndarray( x.length, x, 1, 0 );\n    19.0\n\n    // Sum the last three elements:\n    > x = [ 1.0, -2.0, 3.0, -4.0, 5.0, -6.0 ];\n\n    > sum = base.dasum.ndarray( 3, x, -1, x.length-1 );\n    15.0\n\n    See Also\n    --------\n    base.daxpy, base.dcopy\n",
	"base.daxpy": "\nbase.daxpy( N, alpha, x, strideX, y, strideY )\n    Multiplies `x` by a constant `alpha` and adds the result to `y`.\n\n    The `N` and `stride` parameters determine which elements in `x` and `y` are\n    accessed at runtime.\n\n    Indexing is relative to the first index. To introduce an offset, use typed\n    array views.\n\n    If `N <= 0` or `alpha == 0`, the function returns `y` unchanged.\n\n    Parameters\n    ----------\n    N: integer\n        Number of indexed elements.\n\n    alpha: scalar\n        Constant.\n\n    x: Array|TypedArray\n        Input array.\n\n    strideX: integer\n        Index increment for `x`.\n\n    y: Array|TypedArray\n        Destination array.\n\n    strideY: integer\n        Index increment for `y`.\n\n    Returns\n    -------\n    y: Array|TypedArray\n        Input array `y`.\n\n    Examples\n    --------\n    // Standard usage:\n    > var x = [ 1.0, 2.0, 3.0, 4.0, 5.0 ];\n\n    > var y = [ 1.0, 1.0, 1.0, 1.0, 1.0 ];\n\n    > var alpha = 5.0;\n\n    > base.daxpy( x.length, alpha, x, 1, y, 1 );\n    [ 6.0, 11.0, 16.0, 21.0, 26.0 ]\n\n    // Using `N` and `stride` parameters:\n    > var N = floor( x.length / 2 );\n\n    > base.daxpy( N, alpha, x, 2, y, -1 );\n    [ 26.0, 16.0, 6.0, 1.0, 1.0, 1.0 ]\n\n    // Using view offsets:\n    > var x0 = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n\n    > var y0 = new Float64Array( [ 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n\n    // Create offset views:\n    > var x1 = new Float64Array( x0.buffer, x0.BYTES_PER_ELEMENT*1 );\n\n    > var y1 = new Float64Array( y0.buffer, y0.BYTES_PER_ELEMENT*3 );\n\n    > N = floor( x0.length / 2 );\n\n    > base.daxpy( N, 5.0, x1, -2, y1, 1 );\n    [ 7.0, 8.0, 9.0, 40.0, 33.0, 22.0 ]\n\n\nbase.daxpy.ndarray( N, alpha, x, strideX, offsetX, y, strideY, offsetY )\n    Multiplies `x` by a constant `alpha` and adds the result to `y`, with\n    alternative indexing semantics.\n\n    While typed array views mandate a view offset based on the underlying\n    buffer, the `offsetX` and `offsetY` parameters support indexing semantics\n    based on starting indices.\n\n    Parameters\n    ----------\n    N: integer\n        Number of indexed elements.\n\n    alpha: scalar\n        Constant.\n\n    x: Array|TypedArray\n        Input array.\n\n    strideX: integer\n        Index increment for `x`.\n\n    offsetX: integer\n        Starting index for `x`.\n\n    y: Array|TypedArray\n        Destination array.\n\n    strideY: integer\n        Index increment for `y`.\n\n    offsetY: integer\n        Starting index for `y`.\n\n    Returns\n    -------\n    y: Array|TypedArray\n        Input array `y`.\n\n    Examples\n    --------\n    // Standard usage:\n    > var x = [ 1.0, 2.0, 3.0, 4.0, 5.0 ];\n\n    > var y = [ 1.0, 1.0, 1.0, 1.0, 1.0 ];\n\n    > var alpha = 5.0;\n\n    > base.daxpy.ndarray( x.length, alpha, x, 1, 0, y, 1, 0 );\n    [ 6.0, 11.0, 16.0, 21.0, 26.0 ]\n\n    // Advanced indexing:\n    > x = [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ];\n\n    > y = [ 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ];\n\n    > var N = floor( x.length / 2 );\n\n    > base.daxpy.ndarray( N, alpha, x, 2, 1, y, -1, y.length-1 );\n    [ 7.0, 8.0, 9.0, 40.0, 31.0, 22.0 ]\n\n    See Also\n    --------\n    base.dasum, base.dcopy\n",
	"base.dcopy": "\nbase.dcopy( N, x, strideX, y, strideY )\n    Copies values from `x` into `y`.\n\n    The `N` and `stride` parameters determine how values from `x` are copied\n    into `y`.\n\n    Indexing is relative to the first index. To introduce an offset, use typed\n    array views.\n\n    If `N` is less than `0`, the function returns `y` unchanged.\n\n    Parameters\n    ----------\n    N: integer\n        Number of values to copy.\n\n    x: Array|TypedArray\n        Input array.\n\n    strideX: integer\n        Index increment for `x`.\n\n    y: Array|TypedArray\n        Destination array.\n\n    strideY: integer\n        Index increment for `y`.\n\n    Returns\n    -------\n    y: Array|TypedArray\n        Input array `y`.\n\n    Examples\n    --------\n    // Standard usage:\n    > var x = [ 1.0, 2.0, 3.0, 4.0, 5.0 ];\n\n    > var y = [ 6.0, 7.0, 8.0, 9.0, 10.0 ];\n\n    > base.dcopy( x.length, x, 1, y, 1 );\n    [ 1.0, 2.0, 3.0, 4.0, 5.0 ]\n\n    // Advanced indexing:\n    > x = [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ];\n\n    > y = [ 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ];\n\n    > var N = floor( x.length / 2 );\n\n    > base.dcopy( N, x, -2, y, 1 );\n    [ 5.0, 3.0, 1.0, 10.0, 11.0, 12.0 ]\n\n    // Using typed array views:\n    > var x0 = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ] );\n\n    > var y0 = new Float64Array( [ 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n\n    > var x1 = new Float64Array( x0.buffer, x0.BYTES_PER_ELEMENT*1 );\n\n    > var y1 = new Float64Array( y0.buffer, y0.BYTES_PER_ELEMENT*3 );\n\n    > N = floor( x0.length / 2 );\n\n    > base.dcopy( N, x1, -2, y1, 1 );\n    [ 7.0, 8.0, 9.0, 6.0, 4.0, 2.0 ]\n\n\nbase.dcopy.ndarray( N, x, strideX, offsetX, y, strideY, offsetY )\n    Copies values from `x` into `y`, with alternative indexing semantics.\n\n    While typed array views mandate a view offset based on the underlying\n    buffer, the `offset` parameters support indexing semantics based on starting\n    indices.\n\n    Parameters\n    ----------\n    N: integer\n        Number of values to copy.\n\n    x: Array|TypedArray\n        Input array.\n\n    strideX: integer\n        Index increment for `x`.\n\n    offsetX: integer\n        Starting index for `x`.\n\n    y: Array|TypedArray\n        Destination array.\n\n    strideY: integer\n        Index increment for `y`.\n\n    offsetY: integer\n        Starting index for `y`.\n\n    Returns\n    -------\n    y: Array|TypedArray\n        Input array `y`.\n\n    Examples\n    --------\n    // Standard usage:\n    > var x = [ 1.0, 2.0, 3.0, 4.0, 5.0 ];\n\n    > var y = [ 6.0, 7.0, 8.0, 9.0, 10.0 ];\n\n    > base.dcopy.ndarray( x.length, x, 1, 0, y, 1, 0 );\n    [ 1.0, 2.0, 3.0, 4.0, 5.0 ]\n\n    // Advanced indexing:\n    > x = [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 ];\n\n    > y = [ 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ];\n\n    > var N = floor( x.length / 2 );\n\n    > base.dcopy.ndarray( N, x, 2, 1, y, -1, y.length-1 );\n    [ 7.0, 8.0, 9.0, 6.0, 4.0, 2.0 ]\n\n    See Also\n    --------\n    base.dasum, base.daxpy\n",
	"exists": "\nexists( path )\n    Synchronously tests whether a path exists on the filesystem.\n\n    Parameters\n    ----------\n    path: string|Buffer\n        Path to test.\n\n    Returns\n    -------\n    bool: boolean\n        Boolean indicating whether the path exists.\n\n    Examples\n    --------\n    > var bool = exists( './beep/boop' );\n\n    See Also\n    --------\n    readFile, readDir\n",
	"readDir": "\nreadDir( path )\n    Synchronously reads the contents of a directory.\n\n    Parameters\n    ----------\n    path: string|Buffer\n        Directory path.\n\n    Returns\n    -------\n    out: Error|Array|Array<string>\n        Directory contents.\n\n    Examples\n    --------\n    > var out = readDir( './beep/boop' );\n\n    See Also\n    --------\n    exists, readFile\n",
	"readFile": "\nreadFile( file[, options] )\n    Synchronously reads the entire contents of a file.\n\n    If provided an encoding, the function returns a string. Otherwise, the\n    function returns a Buffer object.\n\n    Parameters\n    ----------\n    file: string|Buffer|integer\n        Filename or file descriptor.\n\n    options: Object (optional)\n        Options.\n\n    options.encoding: string|null (optional)\n        Encoding. Default: null.\n\n    options.flag: string (optional)\n        Flag. Default: 'r'.\n\n    Returns\n    -------\n    out: Error|Buffer|string\n        File contents.\n\n    Examples\n    --------\n    > var out = readFile( './beep/boop.js' );\n\n    See Also\n    --------\n    exists, readDir, readJSON\n",
	"readFileList": "\nreadFileList( filepaths[, options] )\n    Synchronously reads the entire contents of each file in a file list.\n\n    If a provided an encoding, the function returns file contents as strings.\n    Otherwise, the function returns Buffer objects.\n\n    Parameters\n    ----------\n    filepaths: Array<string>\n        Filepaths.\n\n    options: Object (optional)\n        Options.\n\n    options.encoding: string|null (optional)\n        Encoding. Default: null.\n\n    options.flag: string (optional)\n        Flag. Default: 'r'.\n\n    Returns\n    -------\n    out: Error|Array|Array<string>\n        File contents.\n\n    out[ i ].file: string\n        File path.\n\n    out[ i ].data: Buffer|string\n        File contents.\n\n    Examples\n    --------\n    > var filepaths = [ './beep/boop.txt', './foo/bar.txt' ];\n\n    > var out = readFileList( filepaths );\n\n",
	"readJSON": "\nreadJSON( file[, options] )\n    Synchronously reads a file as JSON.\n\n    Parameters\n    ----------\n    file: string|Buffer|integer\n        Filename or file descriptor.\n\n    options: Object (optional)\n        Options.\n\n    options.encoding: string|null (optional)\n        Encoding. Default: null.\n\n    options.flag: string (optional)\n        Flag. Default: 'r'.\n\n    options.reviver: Function (optional)\n        JSON transformation function.\n\n    Returns\n    -------\n    out: Error|JSON\n        File contents.\n\n    Examples\n    --------\n    > var out = readJSON( './beep/boop.json' );\n\n    See Also\n    --------\n    readFile\n",
	"resolveParentPath": "\nresolveParentPath( path[, options] )\n    Synchronously resolves a path by walking parent directories.\n\n    Parameters\n    ----------\n    path: string\n        Path to resolve.\n\n    options: Object (optional)\n        Options.\n\n    options.dir: string (optional)\n        Base directory from which to search. Default: current working directory.\n\n    Returns\n    -------\n    out: string|null\n        Resolved path.\n\n    Examples\n    --------\n    > var out = resolveParentPath( 'package.json' );\n\n"
};
