/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var roundn = require( '@stdlib/math/base/special/roundn' );
var epsdiff = require( '@stdlib/math/base/utils/float64-epsilon-difference' );
var indexOf = require( '@stdlib/utils/index-of' );
var typeOf = require( '@stdlib/utils/type-of' );
var deepEqual = require( '@stdlib/assert/deep-equal' );
var isNull = require( '@stdlib/assert/is-null' );
var isArray = require( '@stdlib/assert/is-array' );
var isNumber = require( '@stdlib/assert/is-number' ).isPrimitive;
var isObject = require( '@stdlib/assert/is-object' );
var isBoolean = require( '@stdlib/assert/is-boolean' ).isPrimitive;
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var isObjectLike = require( '@stdlib/assert/is-object-like' );
var isTypedArray = require( '@stdlib/assert/is-typed-array' );
var startsWith = require( '@stdlib/string/starts-with' );
var contains = require( '@stdlib/assert/contains' );
var endsWith = require( '@stdlib/string/ends-with' );
var removeFirst = require( '@stdlib/string/remove-first' );
var removeLast = require( '@stdlib/string/remove-last' );
var replace = require( '@stdlib/string/replace' );
var trim = require( '@stdlib/string/trim' );


// VARIABLES //

var RE_UNQUOTED_KEYS = /([\w]+)\s*:/g;
var RE_SINGLE_QUOTED_KEYS = /'([^']*)'/g;
var RE_COMMA_BEFORE = / ([\]}])/g;
var RE_COMMA_AFTER = /([{[,:]) /g;
var RE_DECIMAL_DOT = /([\d])\.0([^\d])/g;
var RE_INSTANCE_ANNOTATION = /<([^>]+)>(\[?[^\]]*\]?)/;
var RE_ARRAY = /\[([^\]]+)\]/;


// FUNCTIONS //

/**
* Checks whether number value matches return annotations.
*
* @private
* @param {number} actual - number return value
* @param {string} expected - return value annotation
* @returns {boolean} boolean indicating whether number value matches return annotations.
*/
function checkNumber( actual, expected ) {
	var dgts;
	var a;
	var b;

	if ( startsWith( expected, '~' ) ) {
		if ( contains( expected, 'e' ) ) {
			dgts = indexOf( expected, 'e' ) - indexOf( expected, '.' );
			a = actual.toPrecision( dgts );
			b = removeFirst( expected );
		} else {
			dgts = expected.length - indexOf( expected, '.' ) - 1;
			a = roundn( actual, -dgts );
			b = roundn( parseFloat( removeFirst( expected ) ), -dgts );
		}
	} else {
		a = actual;
		b = parseFloat( expected );
	}
	return epsdiff( a, b ) < 10.0;
}

/**
* Wraps captured match in double quotes.
*
* @private
* @param {string} match - entire match
* @param {string} $1 - first capture group
* @returns {string} quoted match
*/
function replacer( match, $1 ) {
	return '"'+$1+'"';
}

/**
* Formats return annotation as JSON.
*
* @private
* @param {string} str - return annotation string
* @returns {string} JSON-formatted string
*/
function formatJSON( str ) {
	var out = replace( str, RE_UNQUOTED_KEYS, replacer );
	out = replace( out, RE_SINGLE_QUOTED_KEYS, replacer );
	out = replace( out, RE_DECIMAL_DOT, '$1$2' );
	out = replace( out, RE_COMMA_BEFORE, '$1' );
	out = replace( out, RE_COMMA_AFTER, '$1' );
	return out;
}

/**
* Checks whether expected values are type placeholders and if so, whether the actual return values are of the respective type.
*
* @private
* @param {*} actual - actual return value
* @param {string} expected - return value annotation
* @returns {(boolean|string)} boolean indicating whether annotation is a placeholder or error message in case the annotation and value do not match
*/
function checkForPlaceholders( actual, expected ) {
	if ( expected === '<boolean>' || expected === '<Boolean>' ) {
		if ( !isBoolean( actual ) ) {
			return 'Expected a boolean, but received: `'+actual+'`';
		}
		return true;
	}
	if ( expected === '<string>'|| expected === '<String>' ) {
		if ( !isString( actual ) ) {
			return 'Expected a string, but received: `'+actual+'`';
		}
		return true;
	}
	if ( expected === '<number>' || expected === '<Number>' ) {
		if ( !isNumber( actual ) ) {
			return 'Expected a number, but received: `'+actual+'`';
		}
		return true;
	}
	if ( expected === '<Node>' ) {
		if ( !isObject( actual ) ) {
			return 'Expected a node object, but received: `'+actual+'`';
		}
		return true;
	}
	return false;
}

/**
* For a typed array, if the return annotation asserts deep instance equality, check whether it corresponds to the actual value; otherwise, check whether the return annotation signals the correct type.
*
* @private
* @param {*} actual - actual return value
* @param {string} expected - return value annotation
* @returns {(string|null)} error message in case the annotation and value do not match, `null` otherwise
*/
function checkTypedArrays( actual, expected ) {
	var entries;
	var match;
	var type;
	var i;

	match = RE_INSTANCE_ANNOTATION.exec( expected );
	if ( match ) {
		type = match[ 1 ];
		entries = match[ 2 ];
		if ( actual.constructor.name !== type ) {
			return 'Expected instance type <'+actual.constructor.name+'>, but observed <'+type+'>';
		}
		if ( entries ) {
			entries = JSON.parse( entries );
			for ( i = 0; i < entries.length; i++ ) {
				if ( entries[ i ] !== actual[ i ] ) {
					return 'Expected array entries ['+entries+'], but observed ['+actual+']';
				}
			}
		}
		return null;
	}
	return 'Typed arrays should be documented using instance annotation';
}

/**
* Checks whether the elements of an array match the return annotation.
*
* @private
* @param {*} actual - actual return value
* @param {string} expected - return value annotation
* @returns {(string|null)} error message in case the annotation and value do not match, `null` otherwise
*/
function checkArray( actual, expected ) {
	var entries;
	var match;
	var val;
	var i;

	match = RE_ARRAY.exec( expected );
	if ( match ) {
		entries = match[ 1 ].split( ',' );
		for ( i = 0; i < entries.length; i++ ) {
			val = trim( entries[ i ] );
			if ( val === '...' ) {
				break;
			}
			if ( !checkNumber( actual[ i ], val ) ) {
				return 'Displayed return value is `'+expected+'`, but function returns `'+JSON.stringify( actual )+'` instead';
			}
		}
		return null;
	}
	return 'Arrays should be documented using square brackets';
}


// MAIN //

/**
* Checks whether a return value is equal to the value of a return annotation.
*
* @private
* @param {*} actual - actual return value
* @param {string} expected - return value annotation
* @returns {(string|null)} error message in case of mismatch, `null` otherwise
*
* @example
* var out = compareValues( [ 1, 2, 3 ], '[ 1, 2, ... ]' );
* // returns null
*/
function compareValues( actual, expected ) {
	var expectedString;
	var expectedValue;
	var actualString;
	var actualValue;
	var parts;
	var type;
	var msg1;
	var msg2;
	var a;
	var b;

	if ( contains( expected, '||' ) ) {
		parts = expected.split( '||' );
		a = trim( parts[ 0 ] );
		b = trim( parts[ 1 ] );
		msg1 = compareValues( actual, a );
		msg2 = compareValues( actual, b );
		if ( msg1 && msg2 ) {
			return 'Displayed return value should be '+a+' or '+b+', but actual value is `'+actual+'`';
		}
		return null;
	}
	if ( contains( expected, 'e.g.' ) ) {
		// Early return since we cannot compare actual value to return annotation value:
		return null;
	}
	msg1 = checkForPlaceholders( actual, expected );
	if ( msg1 ) {
		return ( isString( msg1 ) ) ? msg1 : null;
	}
	if ( expected === 'NaN' ) {
		if ( !isNaN( actual ) ) {
			return 'Displayed return value is `NaN`, but function returns `'+actual+'` instead';
		}
	}
	else if ( expected === 'null' ) {
		if ( !isNull( actual ) ) {
			return 'Displayed return value is `null`, but function returns `'+actual+'` instead';
		}
	}
	type = typeOf( actual );
	if ( type === 'number' ) {
		if ( !checkNumber( actual, expected ) ) {
			return 'Displayed return value is `'+expected+'`, but function returns `'+actual+'` instead';
		}
	}
	else if ( type === 'boolean' ) {
		actual = String( actual );
		if ( expected !== actual ) {
			return 'Displayed return value is `'+expected+'`, but function returns `'+actual+'` instead';
		}
	}
	else if ( type === 'string' ) {
		if ( !startsWith( expected, '\'' ) || !endsWith( expected, '\'' ) ) {
			return '`'+expected+'` should be wrapped in single quotes';
		}
		expected = removeFirst( removeLast( expected ) );

		// Harmonize escapes between annotations and actual values:
		expected = replace( expected, '\\\'', '\'' );
		actual = replace( actual, '\n', '\\n' );
		actual = replace( actual, '\t', '\\t' );
		if ( expected !== actual && expected !== '...' ) {
			return 'Displayed return value is `'+expected+'`, but function returns `'+actual+'` instead';
		}
	}
	else if ( isTypedArray( actual ) ) {
		return checkTypedArrays( actual, expected );
	}
	if ( isArray( actual ) ) {
		return checkArray( actual, expected );
	}
	if ( isObjectLike( actual ) ) {
		if ( !contains( expected, '...' ) ) {
			expectedString = formatJSON( expected );
			try {
				expectedValue = JSON.parse( expectedString );
			} catch ( err ) {
				return 'Malformed return annotation. Encountered error while parsing: '+err.message;
			}
			actualString = JSON.stringify( actual );
			actualValue = JSON.parse( actualString );
			if ( !deepEqual( expectedValue, actualValue ) ) {
				return 'Displayed return value is `'+expectedString+'`, but function returns `'+actualString+'` instead';
			}
		}
	}
	return null;
}


// EXPORTS //

module.exports = compareValues;
