'use strict';

// MODULES //

var doctrine = require( 'doctrine' );
var join = require( 'path' ).join;
var parse = require( 'acorn' ).parse;
var copy = require( '@stdlib/utils/copy' );
var readFile = require( '@stdlib/fs/read-file' ).sync;
var hasOwn = require( '@stdlib/assert/has-own-property' );
var isObject = require( '@stdlib/assert/is-object' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var startsWith = require( '@stdlib/string/starts-with' );
var replace = require( '@stdlib/string/replace' );
var VALID_VALS = require( './valid_values.json' );
var VALUES = require( './values.json' );


// VARIABLES //

var RE_JSDOC = /^\*\n\* Validates function options./;
var UNRECOGNIZED = readFile( join( __dirname, 'templates', 'unrecognized.txt' ) ).toString();
var VALID = readFile( join( __dirname, 'templates', 'valid.txt' ) ).toString();
var START = readFile( join( __dirname, 'templates', 'start.txt' ) ).toString();
var TEST = readFile( join( __dirname, 'templates', 'test.txt' ) ).toString();


// FUNCTIONS //

/**
* Returns the JSDoc comment of the validate function.
*
* @private
* @param {ObjectArray} comments - array of comment objects
* @returns {(string|null)} JSDoc comment for validate function
*/
function extractValidateJSDoc( comments ) {
	var comment;
	var i;
	for ( i = 0; i < comments.length; i++ ) {
		comment = comments[ i ];
		if ( comment.type === 'Block' && RE_JSDOC.test( comment.value ) ) {
			return comment.value;
		}
	}
	return null;
} // end FUNCTION extractValidateJSDoc()

/**
* Generates description string fragment.
*
* @private
* @param {string} type - parameter type
* @returns {string} description fragment
*/
function generateDescription( type ) {
	switch ( type ) {
	case 'NonNegativeInteger':
		return 'a nonnegative integer';
	case 'NonPositiveInteger':
		return 'a nonpositive integer';
	case 'NegativeInteger':
		return 'a negative integer';
	case 'PositiveInteger':
		return 'a positive integer';
	case 'boolean':
		return 'a boolean primitive';
	case 'string':
		return 'a string primitive';
	case 'Array':
		return 'an array';
	case 'Buffer':
		return 'a `Buffer`';
	case 'Object':
		return 'an object';
	default:
		return '{{TODO:desc}}';
	}
} // end FUNCTION generateDescription()

/**
* Generates values string fragment.
*
* @private
* @param {string} type - parameter type
* @returns {string} values fragment
*/
function generateValues( type ) {
	var vals = copy( VALUES );
	switch ( type ) {
	case 'NonNegativeInteger':
		vals.splice( 1, 1 );
		vals = vals.concat( [ 3.14, -2 ] );
		break;
	case 'NegativeInteger':
		vals.splice( 1, 1 );
		vals = vals.concat( [ 3.14, 2, 0 ] );
		break;
	case 'NonPositiveInteger':
		vals.splice( 1, 1 );
		vals = vals.concat( [ 3.14, 2 ] );
		break;
	case 'PositiveInteger':
		vals.splice( 1, 1 );
		vals = vals.concat( [ 3.14, -2, 0 ] );
		break;
	case 'string':
		vals.splice( 0, 1 );
		break;
	case 'boolean':
		vals.splice( 2, 2 );
		break;
	case 'Array':
		vals.splice( 7, 1 );
		break;
	case 'Object':
		vals.splice( 8, 1 );
		break;
	case 'Buffer':
		break;
	default:
		vals.push( '// TODO: change elements' );
		break;
	}
	return vals.join( ',\n\t\t' );
} // end FUNCTION generateValues()

/**
* Creates a test for a parameter of a given type.
*
* @private
* @param {string} param - parameter name
* @param {string} type - parameter type
* @returns {string} generated test
*/
function createTest( param, type ) {
	var tmpl = replace( TEST, '{{param}}', param );
	tmpl = replace( tmpl, '{{desc}}', generateDescription( type ) );
	tmpl = replace( tmpl, '{{values}}', generateValues( type ) );
	return tmpl;
} // end FUNCTION createTest()

/**
* Creates a test for a parameter of a given type.
*
* @private
* @param {string} param - parameter name
* @param {ObjectArray} elements - union elements
* @returns {string} generated test
*/
function createUnionTest( param, elements ) {
	var vals;
	var desc;
	var tmpl;
	var i;

	desc = '';
	for ( i = 0; i < elements.length; i++ ) {
		if ( i > 0 ) {
			desc += ' or ';
		}
		desc += generateDescription( elements[ i ].name );
	}
	vals = copy( VALUES );
	vals.push( '// TODO: change elements' );
	vals = vals.join( '\n\t\t' );

	tmpl = replace( TEST, '{{param}}', param );
	tmpl = replace( tmpl, '{{desc}}', desc );
	tmpl = replace( tmpl, '{{values}}', vals );
	return tmpl;
} // end FUNCTION createUnionTest()


// MAIN //

/**
* Returns contents of a `test.validate.js` file.
*
* @param {string} str - source code
* @returns {string} validate.js tests
*
* @example
* var create = require( '@stdlib/_tools/scaffold/test-validate-js' );
*
* var code = [
*     '/**',
*     '* Validates function options.',
*     '*',
*     '* @private',
*     '* @param {Object} opts - destination object',
*     '* @param {Options} options - function options',
*     '* @param {string} [options.sep] - separator',
*     '* @returns {(Error|null)} null or an error object',
*     '*\/'
* ];
* code = code.join( '\n' );
*
* var tests = create( code );
*/
function create( str ) {
	var validVals;
	var comments;
	var jsdoc;
	var param;
	var tags;
	var type;
	var ast;
	var out;
	var tag;
	var i;

	if ( !isString( str ) ) {
		throw new TypeError( 'invalid input argument. Must provide a string primitive. Value: `' + str + '`.' );
	}
	comments = [];
	parse( str, {
		'onComment': comments
	});
	jsdoc = extractValidateJSDoc( comments );
	if ( !isString( jsdoc ) ) {
		throw new Error( 'invalid input argument. Source code does not contain JSDoc comment for validate function.' );
	}
	ast = doctrine.parse( jsdoc, {
		'sloppy': true,
		'unwrap': true
	});
	tags = ast.tags;
	out = START;
	validVals = [];
	for ( i = 0; i < tags.length; i++ ) {
		tag = tags[ i ];
		if (
			isObject( tag.type ) &&
			tag.type.type === 'OptionalType' &&
			startsWith( tag.name, 'options.' )
		) {
			param = replace( tag.name, 'options.', '' );
			out += '\n';
			if ( tag.type.expression.type === 'NameExpression' ) {
				type = tag.type.expression.name;
				if ( hasOwn( VALID_VALS, type ) ) {
					validVals.push( '\''+param+'\': '+VALID_VALS[ type ] );
				}
				out += createTest( param, type );
			}
			else if ( tag.type.expression.type === 'UnionType' ) {
				out += createUnionTest( param, tag.type.expression.elements );
			}
		}
	}
	out += '\n';
	out += replace( VALID, '{{valid}}', validVals.join( ',\n\t\t' ) );
	out += '\n';
	out += UNRECOGNIZED;
	return out;
} // end FUNCTION create()


// EXPORTS //

module.exports = create;
