#!/usr/bin/env bash
#
# @license Apache-2.0
#
# Copyright (c) 2020 The Stdlib Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

## USER-DEFINED VARIABLES ##

# Define the main export alias:
ALIAS='dceil'

# Define the package description:
PKG_DESC='Round each element in a double-precision floating-point strided array toward positive infinity.'

# Define the module description:
# shellcheck disable=SC2016
MODULE_DESC='Round each element in a double-precision floating-point strided array `x` toward positive infinity and assigns the results to elements in a double-precision floating-point strided array `y`.'

# Define main export description:
# shellcheck disable=SC2016
MAIN_DESC='Rounds each element in a double-precision floating-point strided array `x` toward positive infinity and assigns the results to elements in a double-precision floating-point strided array `y`.'

# Define the ndarray method description:
# shellcheck disable=SC2001
NDARRAY_DESC=$(echo "${MAIN_DESC}" | sed 's/\.$//')
NDARRAY_DESC="${NDARRAY_DESC} using alternative indexing semantics."

# Define the test description:
TEST_DESC='rounds each element toward positive infinity'

# Define the main C description:
# shellcheck disable=SC2016
C_MAIN_DESC='Rounds each element in a double-precision floating-point strided array `x` toward positive infinity and assigns the results to elements in a double-precision floating-point strided array `Y`.'

# Define the REPL text main export description (note: 4 space indent and wrap at 80 characters):
# shellcheck disable=SC2016
REPL_TEXT_MAIN_DESC='Rounds each element in a double-precision floating-point strided array `x`\n    toward positive infinity and assigns the results to elements in a double-\n    precision floating-point strided array `y`.'

# Define the REPL text ndarray method description (note: 4 space indent and wrap at 80 characters):
# shellcheck disable=SC2016
REPL_TEXT_NDARRAY_DESC='Rounds each element in a double-precision floating-point strided array `x`\n    toward positive infinity and assigns the results to elements in a double-\n    precision floating-point strided array `y` using alternative indexing\n    semantics.'

# Define a list of keywords:
KEYWORDS=(
    "stdmath"
    "mathematics"
    "math"
    "math.ceil"
    "ceil"
    "round"
    "integer"
    "nearest"
    "double"
    "dbl"
    "float64"
    "float64array"
)

# Define the minimum value of generated values when benchmarking and testing the implementation:
C_RAND_MIN='-10.0'

# Define the maximum value of generated values when benchmarking and testing the implementation:
C_RAND_MAX='10.0'

# Define lists of input array values:
X_VALUES_LEN_4='1.1, 2.5, -3.5, 4.0'
X_VALUES_LEN_5='1.1, 2.5, -3.5, 4.0, -5.9'
X_VALUES_LEN_6='1.1, 2.5, -3.5, 4.0, -5.9, 6.4'

C_X_VALUES_LEN_8='1.1, 2.5, -3.5, 4.0, -5.9, 6.4, -7.0, 8.2'

# Define lists of output array values:
EXPECTED_LEN_4='2.0, 3.0, -3.0, 4.0'
EXPECTED_LEN_5='2.0, 3.0, -3.0, 4.0, -5.0'

# X_VALUES_LEN_4
EXPECTED_LEN_2_X2_YM1='-3.0, 2.0'
EXPECTED_LEN_2_XM2_Y1='-3.0, 2.0'

# X_VALUES_LEN_6
EXPECTED_LEN_3_X2_YM1='-5.0, -3.0, 2.0'

# X_VALUES_LEN_6 starting at 2nd element:
EXPECTED_LEN_3_XM2_Y1='7.0, 4.0, 3.0'


## COMPUTED VARIABLES ##

# Define the unary function alias:
UNARY_ALIAS="${ALIAS:1}"

# Define the destination package name:
PKG="stdlib/math/strided/special/${ALIAS}"

# Define the package containing the unary function to apply:
UNARY_PKG="stdlib/math/base/special/${UNARY_ALIAS}"

# Define the C unary function alias:
C_UNARY_ALIAS="base_${UNARY_ALIAS}"

# Define the strided apply function alias:
STRIDED_APPLY_ALIAS="${ALIAS:0:1}map"

# Define the C strided apply macro alias:
C_STRIDED_APPLY_MACRO_ALIAS=$(echo "${STRIDED_APPLY_ALIAS}" | tr '[:lower:]' '[:upper:]')

# Define the typed array data type:
if [ "${ALIAS:0:1}" == "d" ]; then
	TYPED_ARRAY_DTYPE='float64'
else
	TYPED_ARRAY_DTYPE='float32'
fi

# Define the typed array constructor:
TYPED_ARRAY_CTOR="$(echo ${TYPED_ARRAY_DTYPE:0:1} | tr '[:lower:]' '[:upper:]')${TYPED_ARRAY_DTYPE:1}Array"

# Define the C data type:
if [ "${TYPED_ARRAY_DTYPE}" == "float64" ]; then
	C_TYPE='double'
else
	C_TYPE='float'
fi

# Define the C data type suffix (e.g., if float32, then 'f'):
if [ "${C_TYPE}" == "double" ]; then
	C_TYPE_SUFFIX=''
else
	C_TYPE_SUFFIX='f'
fi

# Define the C print format (e.g., if float64, then 'lf'; if float32, then 'f'):
if [ "${C_TYPE}" == "double" ]; then
	C_PRINT_FMT='lf'
else
	C_PRINT_FMT='f'
fi

# Define the C header guard:
C_HEADER_GUARD=$(echo "${PKG}" | sed "s/\\//_/g" | tr '[:lower:]' '[:upper:]')

# Define the copyright year:
YEAR=$(date +'%Y')

# Define the copyright holders:
COPYRIGHT='The Stdlib Authors'


## SCRIPT ##

# Determine the root project directory:
root_dir="$(git rev-parse --show-toplevel)"

# Define the project source code directory:
base_dir="${root_dir}/lib/node_modules"

# Define the destination path:
dest_dir="${base_dir}/@${PKG}"

# Define the location of this scaffold:
this_dir="${base_dir}/@stdlib/_tools/scaffold/strided-typed-unary"

# Define the list of scaffold directories:
dirs=(
	"benchmark"
	"benchmark/c"
	"docs"
	"docs/types"
	"examples"
	"examples/c"
	"include"
	"lib"
	"src"
	"test"
)

# Define the list of scaffold files:
files=(
	"benchmark/c/benchmark.length.c"
	"benchmark/c/Makefile"
	"benchmark/benchmark.js"
	"benchmark/benchmark.native.js"
	"benchmark/benchmark.ndarray.js"
	"benchmark/benchmark.ndarray.native.js"
	"docs/types/index.d.ts"
	"docs/types/test.ts"
	"docs/repl.txt"
	"examples/c/example.c"
	"examples/c/Makefile"
	"examples/index.js"
	"include/alias.h"
	"lib/alias.js"
	"lib/alias.native.js"
	"lib/index.js"
	"lib/main.js"
	"lib/native.js"
	"lib/ndarray.js"
	"lib/ndarray.native.js"
	"src/addon.c"
	"src/alias.c"
	"src/Makefile"
	"test/test.alias.js"
	"test/test.alias.native.js"
	"test/test.js"
	"test/test.ndarray.js"
	"test/test.ndarray.native.js"
	"binding.gyp"
	"include.gypi"
	"manifest.json"
	"package.json"
	"README.md"
)

# Create the destination directories...
for dir in ${dirs[*]}; do
	if [ "${dir}" == "include" ]; then
		mkdir -p "${dest_dir}/include/${PKG/\/${ALIAS}/}"
	else
		mkdir -p "${dest_dir}/${dir}"
	fi
done

# Copy the scaffold files to the destination directory...
for file in ${files[*]}; do
	if [ "${file}" == "include/alias.h" ]; then
		cp "${this_dir}/data/${file}" "${dest_dir}/include/${PKG}.h"
	elif echo "${file}" | grep -q "alias"; then
		cp "${this_dir}/data/${file}" "${dest_dir}/${file/alias/${ALIAS}}"
	else
		cp "${this_dir}/data/${file}" "${dest_dir}/${file}"
	fi
done

# Performs a find and replace across the destination directory.
#
# $1 - regular expression
find_and_replace() {
	find "${dest_dir}" -type f -print0 | xargs -0 perl -pi -w -e "$1"
}

# Joins a list of strings.
#
# $1 - separator
# $* - list of strings to join
join() {
	local d=$1; shift; local f=$1; shift; printf %s "$f" "${@/#/$d}";
}

# For each of the variables defined above, insert into the scaffold files...
regex="s/\\{\\{YEAR\\}\\}/${YEAR}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{COPYRIGHT\\}\\}/${COPYRIGHT}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{ALIAS\\}\\}/${ALIAS}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{PKG\\}\\}/${PKG//\//\\/}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{PKG_DESC\\}\\}/${PKG_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{MODULE_DESC\\}\\}/${MODULE_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{MAIN_DESC\\}\\}/${MAIN_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{NDARRAY_DESC\\}\\}/${NDARRAY_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{TEST_DESC\\}\\}/${TEST_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{C_MAIN_DESC\\}\\}/${C_MAIN_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{REPL_TEXT_MAIN_DESC\\}\\}/${REPL_TEXT_MAIN_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{REPL_TEXT_NDARRAY_DESC\\}\\}/${REPL_TEXT_NDARRAY_DESC}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{UNARY_PKG\\}\\}/${UNARY_PKG//\//\\/}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{UNARY_ALIAS\\}\\}/${UNARY_ALIAS}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{C_UNARY_ALIAS\\}\\}/${C_UNARY_ALIAS}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{STRIDED_APPLY_ALIAS\\}\\}/${STRIDED_APPLY_ALIAS}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{C_STRIDED_APPLY_MACRO_ALIAS\\}\\}/${C_STRIDED_APPLY_MACRO_ALIAS}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{C_HEADER_GUARD\\}\\}/${C_HEADER_GUARD}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{C_TYPE\\}\\}/${C_TYPE}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{C_TYPE_SUFFIX\\}\\}/${C_TYPE_SUFFIX}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{C_PRINT_FMT\\}\\}/${C_PRINT_FMT}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{TYPED_ARRAY_CTOR\\}\\}/${TYPED_ARRAY_CTOR}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{TYPED_ARRAY_DTYPE\\}\\}/${TYPED_ARRAY_DTYPE}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{C_RAND_MIN\\}\\}/${C_RAND_MIN}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{C_RAND_MAX\\}\\}/${C_RAND_MAX}/g;"
find_and_replace "${regex}"

keywords_sep='",\n    "'
if [ "${#KEYWORDS[*]}" -eq 0 ]; then
	keywords=''
else
	keywords=$(join "${keywords_sep}" "${KEYWORDS[@]}")
	keywords="\\n    \"${keywords}\","
fi
regex="s/\\{\\{KEYWORDS\\}\\}/${keywords}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{X_VALUES_LEN_4\\}\\}/${X_VALUES_LEN_4}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{X_VALUES_LEN_5\\}\\}/${X_VALUES_LEN_5}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{X_VALUES_LEN_6\\}\\}/${X_VALUES_LEN_6}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{C_X_VALUES_LEN_8\\}\\}/${C_X_VALUES_LEN_8}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{EXPECTED_LEN_4\\}\\}/${EXPECTED_LEN_4}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{EXPECTED_LEN_5\\}\\}/${EXPECTED_LEN_5}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{EXPECTED_LEN_2_X2_YM1\\}\\}/${EXPECTED_LEN_2_X2_YM1}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{EXPECTED_LEN_2_XM2_Y1\\}\\}/${EXPECTED_LEN_2_XM2_Y1}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{EXPECTED_LEN_3_X2_YM1\\}\\}/${EXPECTED_LEN_3_X2_YM1}/g;"
find_and_replace "${regex}"

regex="s/\\{\\{EXPECTED_LEN_3_XM2_Y1\\}\\}/${EXPECTED_LEN_3_XM2_Y1}/g;"
find_and_replace "${regex}"
