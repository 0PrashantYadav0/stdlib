/**
* @license Apache-2.0
*
* Copyright (c) 2023 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var logger = require( 'debug' );
var pkg2id = require( '@stdlib/error/tools/pkg2id' );
var msg2id = require( '@stdlib/error/tools/msg2id');
var ENV = require( '@stdlib/process/env' );


// VARIABLES //

var debug = logger( 'scripts:transform-error-messages' );
var pkg = ENV[ 'STDLIB_PKG' ];
var prefix = pkg2id( pkg );
var ERROR_NAMES = [
	'Error',
	'AssertionError',
	'RangeError',
	'ReferenceError',
	'SyntaxError',
	'TypeError',
	'URIError'
];


// MAIN //

/**
* Transforms a file.
*
* ## Notes
*
* -   This code is adapted from the respective stdlib [GitHub Action][1].
*
* [1]: https://github.com/stdlib-js/transform-errors-action
*
* @param {Object} fileInfo - file information
* @param {Object} api - JSCodeshift API
* @returns {Object} transformed file
*/
function transformer( fileInfo, api ) {
	var formatRequire;
	var replacement;
	var nRequires;
	var requires;
	var code;
	var root;
	var id;
	var j;

	j = api.jscodeshift;
	root = j( fileInfo.source );

	debug( 'Transforming file: %s', fileInfo.path );
	return root
		.find( j.Literal )
		.forEach( onStringLiteral )
		.toSource();

	/**
	* Callback invoked upon finding a string literal.
	*
	* @private
	* @param {Object} node - AST node
	* @returns {void}
	*/
	function onStringLiteral( node ) {
		if ( node.value.value === '@stdlib/string-format' ) {
			debug( 'Replacing `@stdlib/string-format` with `@stdlib/error-tools-fmtprodmsg`...' );
			j( node )
				.replaceWith( j.stringLiteral( '@stdlib/error-tools-fmtprodmsg' ) );
		}
		// If the string literal is inside a NewExpression for an error, replace the string literal with the error message...
		else if (
			// Case: new Error( format( '...', ... ) )
			( node.parent.parent.value.type === 'NewExpression' &&
			ERROR_NAMES.includes( node.parent.parent.value.callee.name ) )
		) {
			id = msg2id( node.value.value );
			if ( id ) {
				code = prefix + id;
				debug( 'Replacing format string "'+node.value.value+'" with error code "'+code+'"...' );
				j( node )
					.replaceWith( j.stringLiteral( code ) );
			}
		}
		else if (
			// Case: new Error( '...' )
			( node.parent.value.type === 'NewExpression' &&
			ERROR_NAMES.includes( node.parent.value.callee.name ) )
		) {
			id = msg2id( node.value.value );
			if ( id ) {
				code = prefix + id;
				debug( 'Replacing string literal "'+node.value.value+'" with error code "'+code+'"...' );

				// Replace with call to `format` with the error code...
				replacement = j.callExpression(j.identifier( 'format' ), [
					j.stringLiteral( code )
				]);
				j( node ).replaceWith( replacement );

				// Add `require` call to `@stdlib/error-tools-fmtprodmsg` if not already present...
				requires = root.find( j.CallExpression, {
					'callee': {
						'name': 'require',
						'type': 'Identifier'
					}
				});
				nRequires = requires.size();
				debug( 'Found ' + nRequires + ' `require` calls...' );
				if ( !requires.some( hasRequire ) ) {
					formatRequire = j.variableDeclaration('var', [
						j.variableDeclarator(j.identifier( 'format' ), j.callExpression(j.identifier( 'require' ), [
							j.stringLiteral( '@stdlib/error-tools-fmtprodmsg' )
						]))
					]);
					debug( 'Adding `require` call to `@stdlib/error-tools-fmtprodmsg`...' );
					j( root.find( j.Declaration ).at( 0 ).get() ).insertBefore( formatRequire );
				}
			}
		}
	}

	/**
	* Tests whether a node is a require call for `@stdlib/error-tools-fmtprodmsg`.
	*
	* @private
	* @param {Object} node - node to test
	* @returns {boolean} boolean indicating whether a node is a require call for `@stdlib/error-tools-fmtprodmsg`
	*/
	function hasRequire( node ) {
		return node.value.callee.name === 'require' &&
			node.value.arguments[ 0 ].value === '@stdlib/error-tools-fmtprodmsg';
	}
}


// EXPORTS //

module.exports = transformer;
