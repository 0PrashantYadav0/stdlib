#!/usr/bin/env node

/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-console, no-sync */

'use strict';

// MODULES //

var shell = require( 'child_process' ).execSync;
var join = require( 'path' ).join;
var tmpdir = require( 'os' ).tmpdir;
var argv = require( '@stdlib/process/argv' );
var createWorkflowDispatch = require( '@stdlib/_tools/github/dispatch-workflow' );
var readJSON = require( '@stdlib/fs/read-json' ).sync;
var contains = require( '@stdlib/assert/contains' );
var replace = require( '@stdlib/string/replace' );
var ENV = require( '@stdlib/process/env' );


// VARIABLES //

var START_PKG_INDEX = 0;
var END_PKG_INDEX = 5000;
var mainDir = join( __dirname, '..', '..', '..', '..', '..' );


// FUNCTIONS //

/**
* Creates a workflow dispatch event in for the respective GitHub repository.
*
* @private
* @param {string} pkg - package name
* @param {Function} clbk - callback function
* @returns {void}
*/
function dispatch( pkg, clbk ) {
	var slug;
	var opts;

	slug = 'stdlib-js/'+replace( pkg, '/', '-' );
	opts = {
		'token': ENV.GITHUB_TOKEN
	};
	console.log( 'Creating workflow dispatch events for `'+slug+'`.' );
	createWorkflowDispatch( slug, 'test.yml', opts, onTest );

	/**
	* Callback invoked upon creating a test workflow dispatch event.
	*
	* @private
	* @param {(Error|null)} error - encountered error
	* @returns {void}
	*/
	function onTest( error ) {
		if ( error ) {
			console.error( error );
		}
		createWorkflowDispatch( slug, 'test_coverage.yml', opts, onCoverage );
	}

	/**
	* Callback invoked upon creating a coverage workflow dispatch event.
	*
	* @private
	* @param {(Error|null)} error - encountered error
	* @param {Object} info - rate limit info
	* @returns {void}
	*/
	function onCoverage( error, info ) {
		var currentTime;
		var waitTime;
		if ( error ) {
			console.error( error );
		}
		console.log( 'Rate limit information: '+JSON.stringify( info ) );

		if ( info.remaining <= 1 ) {
			currentTime = new Date().getTime();
			waitTime = new Date( info.reset * 1000 ).getTime() - currentTime;
			return setTimeout( clbk, waitTime );
		}
		return clbk();
	}
}


// MAIN //

/**
* Main execution sequence.
*
* @private
* @returns {void}
*/
function main() {
	var onlyToplevel;
	var filename;
	var command;
	var pkgs;
	var pkg;
	var tmp;
	var i;

	filename = join( tmpdir(), 'stdlib_ordered_pkg_list.json' );
	pkgs = readJSON( filename );
	if ( pkgs instanceof Error ) {
		console.log( 'Encountered an error: '+pkgs.message+'. Recreating ordered package list.' );
		command = join( mainDir, 'lib', 'node_modules', '@stdlib', '_tools', 'scripts', 'create_ordered_pkg_list.js' );
		command = 'node '+command+' > '+filename;
		shell( command );
		pkgs = readJSON( filename );
	}
	pkgs = pkgs.slice( START_PKG_INDEX, END_PKG_INDEX );
	for ( i = 0; i < pkgs.length; i++ ) {
		pkgs[ i ] = replace( pkgs[ i ], '@stdlib/', '' );
	}
	onlyToplevel = contains( argv, '--only-toplevel' );
	if ( onlyToplevel ) {
		tmp = [];
		for ( i = 0; i < pkgs.length; i++ ) {
			if ( !contains( pkgs[ i ], '/' ) ) {
				tmp.push( pkgs[ i ] );
			}
		}
		pkgs = tmp;
	}

	console.log( 'Triggering events for '+pkgs.length+' `stdlib` packages...' );
	pkg = pkgs.shift();

	dispatch( pkg, onCallback );

	/**
	* Callback invoked once workflow dispatch events have been created.
	*
	* @private
	*/
	function onCallback( ) {
		pkg = pkgs.shift();
		if ( pkg ) {
			console.log( 'Now processing the following package: '+pkg );
			dispatch( pkg, onCallback );
		}
	}
}

main();
