'use strict';

// MODULES //

var tape = require( 'tape' );
var RuleTester = require( 'eslint' ).RuleTester;
var rule = require( './../lib' );


// FIXTURES //

var valid = require( './fixtures/valid.js' );
var invalid = require( './fixtures/invalid.js' );
var unvalidated = require( './fixtures/unvalidated.js' );


// TESTS //

tape( 'main export is an object', function test( t ) {
	t.ok( true, __filename );
	t.equal( typeof rule, 'object', 'main export is an object' );
	t.end();
});

tape( 'the function positively validates code with an empty line before single-line comments (except when the comment is the first line of a block expression)', function test( t ) {
	var tester = new RuleTester();

	try {
		tester.run( 'empty-line-before-comment', rule, {
			'valid': valid,
			'invalid': []
		});
		t.pass( 'passed without errors' );
	} catch ( err ) {
		t.fail( 'encountered an error: ' + err.message );
	}
	t.end();
});

tape( 'the function negatively validates code without an empty line before single-line comments', function test( t ) {
	var tester = new RuleTester();

	try {
		tester.run( 'empty-line-before-comment', rule, {
			'valid': [],
			'invalid': invalid
		});
		t.pass( 'passed without errors' );
	} catch ( err ) {
		t.fail( 'encountered an error: ' + err.message );
	}
	t.end();
});

tape( 'the function does not validate single-line comments that do not start the line', function test( t ) {
	var tester = new RuleTester();

	try {
		tester.run( 'empty-line-before-comment', rule, {
			'valid': unvalidated,
			'invalid': []
		});
		t.pass( 'passed without errors' );
	} catch ( err ) {
		t.fail( 'encountered an error: ' + err.message );
	}
	t.end();
});

