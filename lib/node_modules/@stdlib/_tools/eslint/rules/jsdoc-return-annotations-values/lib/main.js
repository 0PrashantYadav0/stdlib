/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var vm = require( 'vm' );
var join = require( 'path' ).join;
var dirname = require( 'path' ).dirname;
var parseJSDoc = require( 'doctrine' ).parse;
var Buffer = require( '@stdlib/buffer/ctor' );
var isNull = require( '@stdlib/assert/is-null' );
var isObject = require( '@stdlib/assert/is-object' );
var findJSDoc = require( '@stdlib/_tools/eslint/utils/find-jsdoc' );
var roundn = require( '@stdlib/math/base/special/roundn' );
var epsdiff = require( '@stdlib/math/base/utils/float64-epsilon-difference' );
var indexOf = require( '@stdlib/utils/index-of' );
var isNumber = require( '@stdlib/assert/is-number' ).isPrimitive;
var isBoolean = require( '@stdlib/assert/is-boolean' ).isPrimitive;
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var contains = require( '@stdlib/assert/contains' );
var endsWith = require( '@stdlib/string/ends-with' );
var startsWith = require( '@stdlib/string/starts-with' );
var removeFirst = require( '@stdlib/string/remove-first' );
var removeLast = require( '@stdlib/string/remove-last' );
var replace = require( '@stdlib/string/replace' );
var trim = require( '@stdlib/string/trim' );


// VARIABLES //

var RE_ANNOTATION = /(?:var|let|const)? ?([a-zA-Z0-9]*) ?=[^\n]*\n\/\/ ?(?:returns|=>|throws) {0,1}([\s\S]*?)(\n\n|$)/g;
var DOPTS = {
	'sloppy': true,
	'unwrap': true,
	'tags': [ 'example' ]
};
var rule;


// MAIN //

/**
* Rule for validating that return annotations in example code match the actual output.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	var filename;
	var source;
	var scope;
	var dir;

	filename = context.getFilename();
	dir = dirname( filename );
	/**
	* Requires modules after converting relative to absolute paths.
	*
	* @private
	* @param {string} path - module path
	* @returns {*} required module
	*/
	function customRequire( path ) {
		if ( startsWith( path, './' ) ) {
			return require( join( dir, path ) ); // eslint-disable-line stdlib/no-dynamic-require
		}
		return require( path ); // eslint-disable-line stdlib/no-dynamic-require
	}

	source = context.getSourceCode();
	scope = {
		'require': customRequire,
		'exports': exports,
		'module': module,
		'process': process,
		'setTimeout': setTimeout,
		'clearTimeout': clearTimeout,
		'setInterval': setInterval,
		'clearInterval': clearInterval,
		'Buffer': Buffer,
		'__dirname': dir,
		'__filename': filename
	};

	vm.createContext( scope );
	vm.runInContext( source.text, scope );

	/**
	* Reports the error message.
	*
	* @private
	* @param {ASTNode} node - node to examine
	* @param {string} msg - error message
	*/
	function report( node, msg ) {
		context.report({
			'node': node,
			'message': msg
		});
	}

	/**
	* Checks whether return annotations in example code match the actual output.
	*
	* @private
	* @param {ASTNode} node - node to examine
	*/
	function validate( node ) {
		var expected;
		var actual;
		var jsdoc;
		var code;
		var last;
		var tags;
		var ast;
		var arr;
		var tag;
		var msg;
		var a;
		var b;
		var i;

		if ( node.parent.type !== 'Program' ) {
			// Only validate nodes at the module scope...
			return;
		}
		jsdoc = findJSDoc( source, node );
		if ( isObject( jsdoc ) ) {
			ast = parseJSDoc( jsdoc.value, DOPTS );
			tags = ast.tags;
			expected = [];
			actual = [];
			for ( i = 0; i < tags.length; i++ ) {
				tag = tags[ i ];
				last = 0;

				// Run entire code in case it relies on hoisting of function declarations:
				vm.runInContext( tag.description, scope );

				arr = RE_ANNOTATION.exec( tag.description );
				while ( !isNull( arr ) ) {
					// Run intermediary code:
					code = tag.description.substring( last, arr.index );
					last = arr.index + arr[ 0 ].length;
					if ( code ) {
						vm.runInContext( code, scope );
					}

					// Run code preceding return annotation:
					vm.runInContext( arr[ 0 ], scope );
					actual.push( scope[ arr[ 1 ] ] );
					expected.push( arr[ 2 ] );
					arr = RE_ANNOTATION.exec( tag.description );
				}
			}
			for ( i = 0; i < expected.length; i++ ) {
				a = actual[ i ];
				b = expected[ i ];
				if ( !checkForPlaceholders( a, b, node ) ) {
					msg = compareValues( a, b );
					if ( msg ) {
						report( node, msg );
					}
				}
			}
		}
	}

	return {
		'FunctionExpression:exit': validate,
		'FunctionDeclaration:exit': validate,
		'VariableDeclaration:exit': validate,
		'ExpressionStatement:exit': validate
	};

	/**
	* Checks whether expected values are type placeholders and if so, whether the actual return values are of the respective type.
	*
	* @private
	* @param {*} actual - actual return value
	* @param {string} expected - return value annotation
	* @param {ASTNode} node - examined node
	* @returns {boolean} boolean indicating whether annotation is a placeholder and the actual return type matches
	*/
	function checkForPlaceholders( actual, expected, node ) {
		if ( expected === '<boolean>' || expected === '<Boolean>' ) {
			if ( !isBoolean( actual ) ) {
				report( node, 'Expected a boolean, but received: `'+actual+'`' );
			}
			return true;
		}
		if ( expected === '<string>'|| expected === '<String>' ) {
			if ( !isString( actual ) ) {
				report( node, 'Expected a string, but received: `'+actual+'`' );
			}
			return true;
		}
		if ( expected === '<number>' || expected === '<Number>' ) {
			if ( !isNumber( actual ) ) {
				report( node, 'Expected a number, but received: `'+actual+'`' );
			}
			return true;
		}
		return false;
	}

	/**
	* Checks whether the actual return value is equal to the value of the return annotation.
	*
	* @private
	* @param {*} actual - actual return value
	* @param {string} expected - return value annotation
	* @returns {(string|null)} error message in case of mismatch, `null` otherwise
	*/
	function compareValues( actual, expected ) {
		var parts;
		var dgts;
		var msg1;
		var msg2;
		var a;
		var b;
		if ( contains( expected, '||' ) ) {
			parts = expected.split( '||' );
			a = trim( parts[ 0 ] );
			b = trim( parts[ 1 ] );
			msg1 = compareValues( actual, a );
			msg2 = compareValues( actual, b );
			if ( msg1 && msg2 ) {
				return 'Displayed return value should be '+a+' or '+b+', but actual value is `'+actual+'`';
			}
			return null;
		}
		if ( expected === 'NaN' ) {
			if ( !isNaN( actual ) ) {
				return 'Displayed return value is `NaN`, but function returns `'+actual+'` instead';
			}
		}
		else if ( expected === 'null' ) {
			if ( !isNull( actual ) ) {
				return 'Displayed return value is `null`, but function returns `'+actual+'` instead';
			}
		}
		else if ( isNumber( actual ) ) {
			if ( startsWith( expected, '~' ) ) {
				if ( contains( expected, 'e' ) ) {
					dgts = indexOf( expected, 'e' ) - indexOf( expected, '.' );
					a = actual.toPrecision( dgts );
					b = removeFirst( expected );
				} else {
					dgts = expected.length - indexOf( expected, '.' ) - 1;
					a = roundn( actual, -dgts );
					b = roundn( parseFloat( removeFirst( expected ) ), -dgts );
				}
			} else {
				a = actual;
				b = parseFloat( expected );
			}
			if ( epsdiff( a, b ) > 10.0 ) {
				return 'Displayed return value is `'+expected+'`, but function returns `'+actual+'` instead';
			}
		}
		else if ( isBoolean( actual ) ) {
			actual = String( actual );
			if ( expected !== actual ) {
				return 'Displayed return value is `'+expected+'`, but function returns `'+actual+'` instead';
			}
		}
		else if ( isString( actual ) ) {
			if ( !startsWith( expected, '\'' ) || !endsWith( expected, '\'' ) ) {
				return '`'+expected+'` should be wrapped in single quotes';
			}
			expected = removeFirst( removeLast( expected ) );

			// Harmonize escapes between annotations and actual values:
			expected = replace( expected, '\\\'', '\'' );
			actual = replace( actual, '\n', '\\n' );
			actual = replace( actual, '\t', '\\t' );
			if ( expected !== actual ) {
				return 'Displayed return value is `'+expected+'`, but function returns `'+actual+'` instead';
			}
		}
	}
}


// MAIN //

rule = {
	'meta': {
		'docs': {
			'description': 'validate that return annotations in example code match the actual output'
		},
		'schema': []
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
