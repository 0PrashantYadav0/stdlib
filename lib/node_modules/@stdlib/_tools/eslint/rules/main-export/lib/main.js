/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var parseJSDoc = require( 'doctrine' ).parse;
var contains = require( '@stdlib/assert/contains' );
var tokenize = require( '@stdlib/nlp/tokenize' );
var endsWith = require( '@stdlib/string/ends-with' );
var startsWith = require( '@stdlib/string/starts-with' );
var removeLast = require( '@stdlib/string/remove-last' );
var replace = require( '@stdlib/string/replace' );


// VARIABLES //

var DOPTS = {
	'sloppy': true,
	'unwrap': true,
	'tags': [ 'module', 'example' ]
};
var RE_REQUIRE = /require\( '@([^']+)' \)/;
var rule;


// FUNCTIONS //

/**
* Rule for validating that comments in main export of a package adhere to conventions and contain correct module paths.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	var modulePath;
	var activate;
	var comments;
	var ending;
	var source;

	source = context.getSourceCode();
	modulePath = context.getFilename();

	// Get the part starting with `@stdlib`, shift by one to avoid leading `@`:
	modulePath = modulePath.substr( modulePath.indexOf( '@stdlib' )+1 );

	activate = false;
	ending = '/lib/index.js';
	if ( endsWith( modulePath, ending ) && !contains( source.text, '@namespace' ) ) {
		activate = true;
		modulePath = modulePath.substr( 0, modulePath.length - ending.length );
	}

	/**
	* Reports the error message.
	*
	* @private
	* @param {string} msg - error message
	* @param {Object} loc - lines of code (object with `start` and `end` properties)
	*/
	function report( msg, loc ) {
		context.report({
			'node': null,
			'message': msg,
			'loc': loc
		});
	}

	/**
	* Checks whether the first require statement in example code for the main export of a package requires the module itself.
	*
	* @private
	* @param {Object} tag - example tag
	* @param {Object} loc - lines of code (object with `start` and `end` properties)
	*/
	function checkExample( tag, loc ) {
		var reqPath;
		var match;

		match = tag.description.match( RE_REQUIRE );
		if ( match ) {
			reqPath = match[ 1 ];
			if ( reqPath !== modulePath ) {
				report( 'Example code of main export should first require `@'+modulePath+'`, but encountered `@'+reqPath+'`', loc );
			}
		} else {
			report( 'Example code of main export should require itself, i.e. contain `require( \'@'+modulePath+'\' )`', loc );
		}
	}

	/**
	* Checks whether JSDoc comments of main export adhere to conventions and contain correct module paths.
	*
	* @private
	*/
	function validate() {
		var hasModuleTag;
		var comment;
		var tokens;
		var ast;
		var str;
		var tag;
		var i;
		var j;

		hasModuleTag = false;
		comments = source.getAllComments();
		for ( i = 0; i < comments.length; i++ ) {
			comment = comments[ i ];

			// Check whether comment is JSDoc:
			if ( startsWith( comment.value, '*\n*' ) ) {
				str = comment.value;

				// Replace `@module @stdlib/...` by `@module stdlib/...` to avoid fail of JSDoc parsing:
				str = replace( str, '@module @', '@module ' );
				ast = parseJSDoc( str, DOPTS );

				if ( ast.description ) {
					tokens = tokenize( ast.description );
					if ( endsWith( tokens[ 0 ], 's' ) ) {
						report( 'Begin description with `'+removeLast( tokens[ 0 ] )+'` instead of `'+tokens[ 0 ]+'`', comment.loc );
					}
				}
				for ( j = 0; j < ast.tags.length; j++ ) {
					tag = ast.tags[ j ];
					if ( tag.title === 'module' ) {
						hasModuleTag = true;
						if ( tag.name !== modulePath ) {
							report( 'Expected `@'+modulePath+'` for `@module` tag, but encountered `@'+tag.name+'`', comment.loc );
						}
					}
					else if ( tag.title === 'example' ) {
						checkExample( tag, comment.loc );
					}
				}
			}
		}
		if ( !hasModuleTag ) {
			report( 'JSDoc comment for main export is missing `@module @'+modulePath+'` tag', comment.loc );
		}
	}

	if ( activate ) {
		return {
			'Program:exit': validate
		};
	}
	return {};
}


// MAIN //

rule = {
	'meta': {
		'docs': {
			'description': 'enforce that comments in main export of a package adhere to project conventions and contain correct module paths'
		},
		'schema': []
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
