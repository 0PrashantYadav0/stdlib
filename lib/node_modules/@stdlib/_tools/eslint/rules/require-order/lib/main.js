'use strict';

// MODULES //

var startsWith = require( '@stdlib/string/starts-with' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var isNodeBuiltin = require( '@stdlib/assert/is-node-builtin' );
var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var indexOf = require( '@stdlib/utils/index-of' );
var isRegExpString = require( '@stdlib/assert/is-regexp-string' );
var reFromString = require( '@stdlib/utils/regexp-from-string' );
var DEFAULTS = require( './defaults.json' );


// VARIABLES //

var rule;


// FUNCTIONS //

/**
* Rule for validating `require()` calls follow a specified order.
*
* @param {Object} context - ESLint context
* @returns {Object} validators
*/
function main( context ) {
	var requires;
	var options;
	var regexps;
	var order;
	var i;

	requires = [];
	regexps = [];
	options = context.options[ 0 ];
	order = DEFAULTS.order;
	if ( hasOwnProp( options, 'order' ) ) {
		order = options.order.slice();
	}
	for ( i = 0; i < order.length; i++ ) {
		if ( isRegExpString( order[ i ] ) ) {
			regexps.push( reFromString( order[ i ] ) );
		}
	}

	/**
	* Reports the error message.
	*
	* @private
	* @param {ObjectArray} offenders - array of require statements that are not in order
	*/
	function report( offenders ) {
		var curr;
		var msg;
		var i;
		for ( i = 0; i < offenders.length; i++ ) {
			curr = offenders[ i ];
			msg = '`require( \''+curr.name+'\' )` should come before `require( \''+curr.compared.name+'\' )`';
			context.report({
				'node': null,
				'message': msg,
				'loc': curr.node.loc
			});
		}
	}

	/**
	* Checks for existence of require paths in the current program and registers them.
	*
	* @private
	* @param {ASTNode} node - node to examine
	*/
	function validate( node ) {
		var requirePath;
		if ( node.callee.name === 'require' ) {
			requirePath = node.arguments[ 0 ].value;
			if ( isString( requirePath ) ) {
				registerNode( node, requirePath );
			}
		}
	}

	/**
	* Pushes a node to the current array of `require` statements.
	*
	* @private
	* @param {ASTNode} node - node to examine
	* @param {string} name - package name or path
	*/
	function registerNode( node, name ) {
		var v = rank( name );
		if ( v !== -1 ) {
			requires.push({
				'name': name,
				'node': node,
				'rank': v
			});
		}
	}

	/**
	* Calculates the position rank for a given `require` path.
	*
	* @private
	* @param {string} name - require path
	* @returns {integer} array index
	*/
	function rank( name ) {
		var type;
		var i;

		type = 'external';
		if ( isNodeBuiltin( name ) ) {
			type = 'builtin';
		}
		else if (
			startsWith( name, './' ) ||
			startsWith( name, '/' ) ||
			startsWith( name, '../' )
		) {
			type = 'path';
		}
		for ( i = 0; i < regexps.length; i++ ) {
			if ( regexps[ i ].test( name ) ) {
				type = '/'+regexps[ i ].source+'/';
			}
		}
		return indexOf( order, type );
	}

	/**
	* Returns an array of objects containing all nodes that violate a specified order.
	*
	* @private
	* @returns {ObjectArray} array holding all nodes which violate a specified order
	*/
	function findWronglySorted() {
		var maxNode;
		var arr;
		var i;
		if ( requires.length === 0 ) {
			return [];
		}
		maxNode = requires[ 0 ];
		arr = [];
		for ( i = 0; i < requires.length; i++ ) {
			if ( requires[ i ].rank < maxNode.rank ) {
				requires[ i ].compared = maxNode;
				arr.push( requires[ i ] );
			}
			if ( maxNode.rank < requires[ i ].rank ) {
				maxNode = requires[ i ];
			}
		}
		return arr;
	}

	/**
	* Reports any encountered issues and resets the array of require statements.
	*
	* @private
	*/
	function finish() {
		var offenders = findWronglySorted();
		if ( !offenders.length ) {
			return;
		}
		report( offenders );
		requires = [];
	}

	return {
		'CallExpression': validate,
		'Program:exit': finish
	};
}


// MAIN //

rule = {
	'meta': {
		'docs': {
			'description': 'enforce that `require()` calls follow a specified order'
		},
		'schema': [
			{
				'type': 'object',
				'properties': {
					'order': {
						'type': 'array'
					}
				},
				'additionalProperties': false
			}
		]
	},
	'create': main
};


// EXPORTS //

module.exports = rule;
