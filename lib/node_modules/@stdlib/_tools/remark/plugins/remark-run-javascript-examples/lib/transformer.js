'use strict';

// MODULES //

var exec = require( 'child_process' ).exec;
var logger = require( 'debug' );
var replace = require( '@stdlib/string/replace' );
var cwd = require( '@stdlib/utils/cwd' );


// VARIABLES //

var debug = logger( 'remark-run-javascript-examples:transformer' );

var RE_CONFIG_DISABLE = /^<!--\s+run\s+disable\s+-->$/;

var EXAMPLES_BEGIN = '<section class="examples">';
var EXAMPLES_END = '<!-- /.examples -->';

var USAGE_BEGIN = '<section class="usage">';
var USAGE_END = '<!-- /.usage -->';

var RE_TRAILING_EOL = /\r?\n$/;

var NODE = process.execPath;


// MAIN //

/**
* Returns a transformer function.
*
* @private
* @param {Options} options - transformer options
* @param {string} [options.cwd] - current working directory of the child process
* @param {boolean} [options.quiet] - boolean indicating whether to silence examples writing to `stdout`, but allow writing to `stderr`
* @param {boolean} [options.silent] - boolean indicating whether to silence examples writing to both `stdout` and `stderr`
* @returns {Function} transformer function
*/
function factory( options ) {
	return transformer;

	/**
	* Transforms a Markdown abstract syntax tree (AST).
	*
	* @private
	* @param {Node} tree - root AST node
	* @param {File} file - virtual file
	* @param {Callback} clbk - callback to invoke upon completion
	* @returns {void}
	*/
	function transformer( tree, file, clbk ) {
		var FIRST;
		var total;
		var UFLG;
		var EFLG;
		var idx;

		debug( 'Processing file: %s', file.path || '' );

		idx = -1;
		total = tree.children.length;
		debug( '%d AST nodes.', total );

		if ( total === 0 ) {
			return done();
		}
		return next();

		/**
		* Processes the next AST node.
		*
		* @private
		* @returns {void}
		*/
		function next() {
			var script;
			var node;
			var opts;
			var prev;
			var cmd;
			var j;

			idx += 1;
			debug( 'Processing AST node %d of %d...', idx+1, total );

			node = tree.children[ idx ];
			debug( 'Node type: %s', node.type );

			if ( node.type === 'html' ) {
				if ( node.value === EXAMPLES_BEGIN ) {
					debug( 'Found an examples section.' );
					EFLG = true;
				} else if ( node.value === EXAMPLES_END ) {
					debug( 'Finished processing examples section.' );
					EFLG = false;
				} else if ( node.value === USAGE_BEGIN ) {
					debug( 'Found a usage section.' );
					FIRST = null;
					UFLG = true;
				} else if ( node.value === USAGE_END ) {
					debug( 'Finished processing usage section.' );
					UFLG = false;
				}
				return done();
			}
			if (
				( EFLG || UFLG ) &&
				node.type === 'code' &&
				( node.lang === 'javascript' || node.length === 'js' )
			) {
				debug( 'Found a JavaScript code block.' );
				script = node.value;

				// Escape single quotes (NOTE: bash escaping):
				script = replace( script, '\'', '\'"\'"\'' );

				// Check if this is the first block in a "usage" section...
				if ( UFLG ) {
					if ( FIRST === null ) {
						debug( 'Caching block contents...' );
						FIRST = script;
					} else {
						// Prepend the first block to all subsequent code blocks:
						script = FIRST + '\n\n' + script;
					}
				}
				// Look for HTML comments immediately preceding a code block which may contain configuration...
				debug( 'Searching for a configuration comment...' );
				j = idx - 1;
				prev = tree.children[ j ];
				while ( prev && prev.type === 'html' ) {
					// Check for a configuration comment indicating that a code block should **not** be executed:
					if ( RE_CONFIG_DISABLE.test( prev.value ) ) {
						debug( 'Found a configuration comment disabling execution. Skipping code block...' );
						return done();
					}
					j -= 1;
					prev = tree.children[ j ];
				}
				debug( 'No configuration comment found.' );

				// Create the script command:
				cmd = [ NODE, '-e', '\''+script+'\'' ].join( ' ' );

				// Set the working directory of the script to the file directory:
				opts = {
					'cwd': options.cwd || file.dirname || cwd()
				};

				debug( 'Executing code block...' );
				exec( cmd, opts, onExec );
			} else {
				return done();
			}
		} // end FUNCTION next()

		/**
		* Callback invoked upon executing a code block.
		*
		* @private
		* @param {(Error|null)} error - error object
		* @param {Buffer} stdout - standard output
		* @param {Buffer} stderr - standard error
		* @returns {void}
		*/
		function onExec( error, stdout, stderr ) {
			if ( error ) {
				debug( 'Encountered an error when executing code block: %s', error.message );

				// TODO: the generated error is a bit messy. Cleaning-up may require manual modification of the stacktrace(s), etc.
				error = new Error( 'unexpected error. Encountered an error when executing code block. File: ' + (file.path || '') + '. Message: ' + error.message );
				return done( error );
			}
			if ( !options.quiet && !options.silent ) {
				stdout = stdout.toString();
				if ( stdout ) {
					// Trim off a trailing newline (e.g., prevent `console.log( console.log() )`:
					console.log( replace( stdout, RE_TRAILING_EOL, '' ) ); // eslint-disable-line no-console
				}
			}
			if ( !options.silent ) {
				stderr = stderr.toString();
				if ( stderr ) {
					// Trim off a trailing newline (e.g., prevent `console.error( console.error() )`:
					console.error( replace( stderr, RE_TRAILING_EOL, '' ) ); // eslint-disable-line no-console
				}
			}
			debug( 'Finished executing code block.' );
			done();
		} // end FUNCTION onExec()

		/**
		* Callback invoked upon processing an AST node.
		*
		* @private
		* @param {Error} [error] - error object
		* @returns {void}
		*/
		function done( error ) {
			if ( error ) {
				return clbk( error );
			}
			debug( 'Processed %d of %d AST nodes.', idx+1, total );
			if ( idx === total-1 ) {
				debug( 'Finished processing file.' );
				return clbk();
			}
			next();
		} // end FUNCTION done()
	} // end FUNCTION transformer()
} // end FUNCTION factory()


// EXPORTS //

module.exports = factory;
