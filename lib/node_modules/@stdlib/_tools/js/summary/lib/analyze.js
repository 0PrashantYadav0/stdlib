'use strict';

// MODULES //

var parse = require( 'acorn' ).parse;
var contains = require( '@stdlib/assert/contains' );
var RE_EOL = require( '@stdlib/regexp/eol' );
var flatten = require( './flatten.js' );
var sloc = require( './sloc.js' );
var lloc = require( './lloc.js' );
var emptyLines = require( './empty_lines.js' );
var tabulate = require( './tabulate.js' );
var resultsObject = require( './results.js' );
var onComment = require( './on_comment.js' );
var recurseNodes = require( './recurse_nodes.json' );
var type2key = require( './type2key.js' );


// MAIN //

/**
* Analyzes an AST to generate a summary.
*
* @private
* @param {Object} results - output results object
* @param {Node} ast - AST node
* @param {string} src - source code
* @param {StringArray} lines - source code lines
* @param {Options} opts - parse options
* @returns {Object} results
*/
function analyze( results, ast, src, lines, opts ) {
	var nodes;
	var node;
	var type;
	var res;
	var str;
	var key;
	var i;

	// Compute the number of characters:
	results.length += ast.end - ast.start;

	// Compute the number of physical lines:
	results.lines += ast.loc.end.line - ast.loc.start.line + 1;

	// Flatten the AST:
	nodes = flatten( ( ast.type !== 'Program' && ast.body ) ? ast.body : ast );

	// Calculate the number of source lines of codes (SLOC):
	results.sloc += sloc( nodes );

	// Calculate the number of logical lines of code (LLOC):
	results.lloc += lloc( nodes );

	// Calculate the number of empty lines:
	results.empty += emptyLines( lines );

	// Tabulate AST node occurrences:
	results = tabulate( results, nodes );

	// Recursively analyze AST nodes:
	for ( i = 0; i < nodes.length; i++ ) {
		node = nodes[ i ];
		type = node.type;
		if ( contains( recurseNodes, type ) ) {
			// Initialize a new results object:
			res = resultsObject();

			// Isolate the source code containing the AST node:
			str = src.substring( node.start, node.end );

			// Split the source code string into separate lines:
			lines = str.split( RE_EOL );

			// Generate a new sub-tree in order to also capture comments:
			opts.onComment = onComment( res, lines );
			ast = parse( str, opts );

			// Isolate the AST body (which should consist of only 1 top-level AST node):
			ast = ast.body[ 0 ];

			// Analyze the AST:
			key = type2key( type );
			res = analyze( res, ast, str, lines, opts );

			// Include results specific to particular AST nodes:
			if ( type === 'SwitchStatement' ) {
				res.case = node.cases.length;
			} else if ( type === 'FunctionDeclaration' ) {
				res.params = node.params.length;
			}
			// Cache the sub-tree results:
			results[ key ].data.push( res );
		}
	}
	// Return the results:
	return results;
} // end FUNCTION analyze()


// EXPORTS //

module.exports = analyze;
