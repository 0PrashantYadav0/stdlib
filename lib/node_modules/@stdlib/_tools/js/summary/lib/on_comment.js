'use strict';

// VARIABLES //

var RE_NON_WHITESPACE = /\S/;


// MAIN //

/**
* Returns a callback to be invoked upon encountering a comment.
*
* @private
* @param {Object} results - results object
* @param {StringArray} lines - source code lines
* @returns {Function} callback to be invoked upon encountering a comment
*/
function wrap( results, lines ) {
	return onComment;

	/**
	* Callback invoked upon encountering a comment.
	*
	* @private
	* @param {boolean} block - boolean indicating whether a comment is a block comment
	* @param {string} text - comment text
	* @param {NonNegativeInteger} start - character offset for comment start
	* @param {NonNegativeInteger} end - character offset for comment end
	* @param {Object} pos1 - start location
	* @param {Object} pos2 - end location
	*/
	function onComment( block, text, start, end, pos1, pos2 ) {
		var inline;
		var line;
		var key;
		var len;
		var N;

		// Determine the number of lines:
		N = pos2.line - pos1.line + 1;

		// Determine the comment length:
		len = end - start;

		// Determine if the comment is inline...
		if ( N === 1 ) {
			line = lines[ pos1.line-1 ];
			line = line.substring( 0, pos1.column );
			inline = RE_NON_WHITESPACE.test( line );
		} else {
			inline = false;
		}
		inline = ( inline ) ? 1 : 0;

		// Update sub-comment totals:
		if ( block ) {
			key = 'block';
		} else {
			key = 'line';
		}
		results.comments[ key ].count += 1;
		results.comments[ key ].length += len;
		results.comments[ key ].lines += N;
		results.comments[ key ].inline += inline;

		// Update total comment totals:
		results.comments.count += 1;
		results.comments.length += len;
		results.comments.lines += N;
		results.comments.inline += inline;
	} // end FUNCTION onComment()
} // end FUNCTION wrap()


// EXPORTS //

module.exports = wrap;
