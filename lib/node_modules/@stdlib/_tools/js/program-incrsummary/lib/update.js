/* eslint-disable max-depth */
'use strict';

// MODULES //

var evil = require( '@stdlib/utils/eval' );
var pluck = require( '@stdlib/utils/pluck' );
var flattenArray = require( '@stdlib/utils/flatten-array' );
var isArray = require( '@stdlib/assert/is-array' );
var fields = require( './fields.json' );


// VARIABLES //

var RE_ARRAY = /^\[(.+)\]$/;
var RE_VALUE = /^<(.+)>$/;

var popts = {
	'copy': true
};
var fopts = {
	'depth': 1
};


// MAIN //

/**
* Updates accumulator state.
*
* @private
* @param {Object} state - accumulator state
* @param {Object} engine - accumulator engine
* @param {Object} summary - program summary
* @returns {Object} accumulator state
*/
function update( state, engine, summary ) {
	var parts;
	var path;
	var skey;
	var dkey;
	var acc;
	var tmp;
	var oe;
	var os;
	var v;
	var t;
	var i;
	var j;

	// Walk the field paths to update accumulator state...
	for ( i = 0; i < fields.length; i++ ) {
		oe = engine;
		os = state;

		// Get the state path:
		path = fields[ i ][ 0 ].split( '.' );

		// Get the accumulator and its corresponding state leaf:
		for ( j = 0; j < path.length-1; j++ ) {
			skey = path[ j ];
			oe = oe[ skey ];
			os = os[ skey ];
		}
		skey = path[ j ];
		acc = oe[ skey ];

		// Get the data path:
		path = fields[ i ][ 1 ].split( '.' );

		// Walk the data path while performing any accumulations in order to resolve the update value:
		v = summary;
		for ( j = 0; j < path.length-1; j++ ) {
			dkey = path[ j ];

			// Check if we need to "pluck" values from an array:
			if ( isArray( v ) ) {
				parts = RE_ARRAY.exec( dkey );
				if ( parts ) {
					// E.g., key path: function.[data].variable.[data].name.length
					j += 1;
					v = pluck( v, parts[ 1 ], popts );
					v = flattenArray( v, fopts );
				}
				v = pluck( v, path[ j ], popts );
			} else {
				parts = RE_ARRAY.exec( dkey );
				if ( parts ) {
					// E.g., key path: function.[data].count
					j += 1;
					v = pluck( v[ parts[1] ], path[ j ], popts );
				} else {
					// E.g., key path: function.count
					v = v[ dkey ];
				}
			}
		}
		dkey = path[ j ];

		// Check if we need to perform a reduction:
		if ( isArray( v ) ) {
			if ( v.length === 0 ) {
				// If the array is empty, no data to provide to the accumulator...
				continue;
			}
			if ( dkey === void 0 ) {
				// Update the accumulator for each array value (e.g., key path: function.[data].length):
				for ( j = 0; j < v.length; j++ ) {
					acc( v[ j ] );
				}
			} else {
				parts = RE_VALUE.exec( dkey );
				if ( parts ) {
					// Count the occurrence of some observation; e.g., a particular key value (e.g., key path: function.[data].type.<'declaration'>):
					t = evil( parts[ 1 ] );
					tmp = 0;
					for ( j = 0; j < v.length; j++ ) {
						if ( v[ j ] === t ) {
							tmp += 1;
						}
					}
					// Update the accumulator:
					acc( tmp );
				} else {
					// Update the accumulator by extracting a property value from each array element (e.g., function.[data].params):
					for ( j = 0; j < v.length; j++ ) {
						acc( v[ j ][ dkey ] );
					}
				}
			}
		} else {
			// This is a "program-wide" value, and, thus, suitable to provide to the accumulator, even if zero (e.g., key path: function.count):
			acc( v[ dkey ] );
		}
		// Update the state:
		os[ skey ] = acc();
	}
	return os;
} // end FUNCTION update()


// EXPORTS //

module.exports = update;
