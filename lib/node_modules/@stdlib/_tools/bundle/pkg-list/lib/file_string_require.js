'use strict';

// MODULES //

var debug = require( 'debug' )( 'bundle-pkg-list:to-file-string' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var isBoolean = require( '@stdlib/assert/is-boolean' ).isPrimitive;


// FUNCTIONS //

/**
* Returns a key path.
*
* @private
* @param {(EmptyArray|StringArray)} parts - path segments
* @returns {string} key path
*
* @example
* var out = toPath( [] );
* // returns ''
*
* @example
* var out = toPath( [ 'a', 'b' ] );
* // returns '["a"]["b"]'
*/
function toPath( parts ) {
	var str;
	var i;
	str = '';
	for ( i = 0; i < parts.length; i++ ) {
		str += '[\'' + parts[ i ] + '\']';
	}
	return str;
} // end FUNCTION toPath()


// MAIN //

/**
* Generates a file string from a namespace, where `require` is used as the module loader.
*
* @private
* @param {ArrayArray} namespace - namespace array
* @returns {string} file string
*/
function toFileString( namespace ) {
	var parts;
	var trie;
	var len;
	var str;
	var key;
	var req;
	var ns;
	var p;
	var i;
	var j;

	ns = {};

	str = '"use strict";\n\n';
	str += 'var setReadOnly = require(\'@stdlib/utils/define-read-only-property\');\n\n';
	str += 'var ns = {};\n';
	for ( i = 0; i < namespace.length; i++ ) {
		trie = ns;
		parts = namespace[ i ][ 0 ].split( '.' );
		len = parts.length;
		for ( j = 0; j < len; j++ ) {
			key = parts[ j ];

			// Is this the first time we have seen this key? If so, create a new tree node...
			if ( !hasOwnProp( trie, key ) ) {
				p = toPath( parts.slice( 0, j ) );

				// Will this tree node have descendants?
				if ( j < len-1 ) {
					// Create a sub-trie:
					debug( 'Found a new namespace: %s', parts.slice( 0, j+1 ).join( '.' ) );
					trie[ key ] = {};
					str += 'setReadOnly(ns'+p+',\''+key+'\',{});\n';
				} else {
					// Create a leaf node:
					debug( 'Found a new leaf node: %s', parts.slice( 0, j+1 ).join( '.' ) );
					trie[ key ] = true;
					req = 'require(\''+namespace[i][1]+'\')';
					str += 'setReadOnly(ns'+p+',\''+key+'\','+req+');\n';
				}
			}
			// Does this tree node have descendants and is this node currently a leaf?
			else if ( j < len-1 && isBoolean( trie[ key ] ) ) {
				debug( 'WARNING: possible conflict. Reinterpreting a previously detected leaf node as a namespace. Path: %s.', parts.slice( 0, j+1 ).join( '.' ) );
				trie[ key ] = {};
			}
			trie = trie[ key ];
		}
	}
	str += '\nmodule.exports = ns;\n';
	return str;
} // end FUNCTION toFileString()


// EXPORTS //

module.exports = toFileString;
