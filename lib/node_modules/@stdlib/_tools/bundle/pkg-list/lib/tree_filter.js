'use strict';

// MODULES //

var logger = require( 'debug' );
var indexOf = require( '@stdlib/utils/index-of' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var namespaces = require( './namespaces.js' );
var aliases = require( './aliases.js' );


// VARIABLES //

var debug = logger( 'bundle-pkg-list:tree-filter' );


// MAIN //

/**
* Filters a (unique) sorted list of packages by excluding those stdlib namespace packages with children in the list.
*
* ## Notes
*
* -   If namespace packages with listed children were allowed, we would end up trying to override namespace properties which are read-only. So, our stance is that, if you want a namespace, you should provide a namespace only. And if you only want certain children, then provide the children, but not the namespace. Providing both signals confusion.
* -   The one exception we allow is when a namespace has an alias in the global alias namespace, which indicates that a package is not a "traditional" namespace, possibly providing a function API to namespace packages (e.g., `@stdlib/datasets`).
*
*
* @private
* @param {StringArray} pkgs - list of packages (unique and sorted lexicographically)
* @returns {StringArray} filtered list
*
* @example
* var pkgs = [
*     '@stdlib/math/base',
*     '@stdlib/random/base',
*     '@stdlib/math/base/special/erf'
* ];
*
* var out = filter( pkgs );
* // returns [ '@stdlib/random/base', '@stdlib/math/base/special/erf' ]
*/
function filter( pkgs ) {
	var out;
	var tmp;
	var N;
	var i;

	N = pkgs.length;
	out = [];
	for ( i = 0; i < N; i++ ) {
		// Only bother filtering known `stdlib` namespaces to avoid things like `beep/lib` and `beep/lib/foo` from being filtered...
		if (
			// If we are the last package, we can skip filtering as no other package comes after to compare to:
			i < N-1 &&

			// Check if the package is a known namespace:
			indexOf( namespaces, pkgs[ i ] ) !== -1 &&

			// The package is a known namespace, but make sure it is not aliased and thus a "non-traditional" namespace:
			!hasOwnProp( aliases, pkgs[ i ] )
		) {
			// Note that we use `length+1` in order to capture a trailing slash (if present).
			tmp = pkgs[ i+1 ].substring( 0, pkgs[i].length+1 );

			// Note that comparing with the ending slash is key; otherwise, `@stdlib/math/base/special/erf` would be considered a namespace when followed by `@stdlib/math/base/special/erfc`.
			if ( ( pkgs[i]+'/' ) === tmp ) {
				debug( 'Excluding %s.', pkgs[ i ] );
			} else {
				out.push( pkgs[ i ] );
			}
		} else {
			out.push( pkgs[ i ] );
		}
	}
	return out;
} // end FUNCTION filter()


// EXPORTS //

module.exports = filter;
