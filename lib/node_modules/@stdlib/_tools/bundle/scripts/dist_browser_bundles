#!/usr/bin/env node

/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
* Script to generate distributable browser bundles.
*
* ## Usage
*
* ```bash
* $ DEBUG=bundle:dist-browser-bundles node --max_old_space_size=4096 --expose_gc /path/to/bundle/scripts/dist_browser_bundles
* ```
*
* ## Notes
*
* -   When running this script, you may need to increase Node.js memory limits. For example,
*
*     ```bash
*     $ node --max_old_space_size=4096 ./lib/node_modules/\@stdlib/_tools/bundle/scripts/dist_browser_bundles
*     ```
*
* -   To allow for manual garbage collection, expose garbage collection using the `--expose_gc` command-line flag
*
*     ```bash
*     $ node --expose_gc ./lib/node_modules/\@stdlib/_tools/bundle/scripts/dist_browser_bundles
*     ```
*
* @private
*/
'use strict';

// MODULES //

var join = require( 'path' ).join;
var resolve = require( 'path' ).resolve;
var logger = require( 'debug' );
var collapse = require( 'bundle-collapser/plugin' ); // eslint-disable-line no-unused-vars // TODO: consider removing if not going to use as a plugin
var packFlat = require( 'browser-pack-flat/plugin' );
var uglifyify = require( 'uglifyify' );
var uglify = require( 'uglify-es' );
var pkgNames = require( '@stdlib/_tools/pkgs/browser-compatible' ).sync;
var instanceOf = require( '@stdlib/assert/instance-of' );
var bundle = require( '@stdlib/_tools/bundle/pkg-list' );
var writeFile = require( '@stdlib/fs/write-file' );


// VARIABLES //

var debug = logger( 'bundle:dist-browser-bundles' );
var LICENSE_HEADER = '/* @license Apache-2.0 AND BSL-1.0 */\n';


// MAIN //

/**
* Filters an array of package names by including those package names having a provided substring.
*
* @private
* @param {StringArray} arr - list of package names
* @param {string} pattern - pattern used to filter package names
* @returns {(EmptyArray|StringArray)} filter package list
*/
function include( arr, pattern ) {
	var out;
	var i;
	out = [];
	for ( i = 0; i < arr.length; i++ ) {
		if ( arr[ i ].indexOf( pattern ) >= 0 ) {
			out.push( arr[ i ] );
		}
	}
	return out;
}

/**
* Filters an array of package names by excluding package names having a provided substring.
*
* @private
* @param {StringArray} arr - list of package names
* @param {string} pattern - pattern used to filter package names
* @returns {(EmptyArray|StringArray)} filter package list
*/
function exclude( arr, pattern ) {
	var out;
	var i;
	out = [];
	for ( i = 0; i < arr.length; i++ ) {
		if ( arr[ i ].indexOf( pattern ) === -1 ) {
			out.push( arr[ i ] );
		}
	}
	return out;
}

// Define package resolution options:
var fopts = {
	'pattern': '**/package.json',
	'ignore': [
		'**/_**/**' // ignore "private" packages
	]
};

// Resolve packages:
var names = pkgNames( fopts );
if ( instanceOf( names, Error ) ) {
	throw names;
}

// Define the list of standalone UMD bundles:
var bundles = [
	{
		'name': 'stdlib-flat',
		'standalone': 'stdlib', // UMD
		'namespace': 'flat',
		'raw': true,
		'minified': true,
		'exclude': [
			'@stdlib/datasets',
			'@stdlib/namespace',
			'@stdlib/repl'
		]
	},
	{
		'name': 'stdlib-tree',
		'standalone': 'stdlib',
		'namespace': 'tree',
		'raw': true,
		'minified': true,
		'exclude': [
			'@stdlib/datasets',
			'@stdlib/namespace',
			'@stdlib/repl',
			'@stdlib/tools' // TODO: revisit, as tools could have desired packages
		]
	},
	{
		'name': 'stdlib-datasets-tree',
		'standalone': 'stdlib_datasets',
		'namespace': 'tree', // we want the namespace, so cannot use `flat` (REPL has `datasets` alias for `@stdlib/datasets`)
		'raw': false,
		'minified': true,
		'include': [
			'@stdlib/datasets'
		]
	},
	{
		'name': 'stdlib-repl',
		'standalone': 'stdlib_repl',
		'namespace': 'tree', // we want the namespace, so cannot use `flat` (only want `@stdlib/repl` namespace)
		'raw': false,
		'minified': true,
		'include': [
			'@stdlib/repl'
		],
		'exclude': [
			// WARNING: this list is fragile, as we must manually update the list of what to exclude as the namespace changes.
			'@stdlib/repl/code-blocks',
			'@stdlib/repl/help',
			'@stdlib/repl/server'
		]
	},
	{
		'name': 'stdlib-repl-help',
		'standalone': 'stdlib_repl_help',
		'namespace': 'tree', // we want the "namespace", so cannot use `flat`
		'raw': false,
		'minified': true,
		'include': [
			'@stdlib/repl/help'
		],
		'exclude': []
	}
];

// Define the output directory:
var dir = resolve( __dirname, '..', '..', '..', '..', '..', '..', 'dist' ); // WARNING: fragile, as this may need to be updated if script is moved

// Define options for `uglifyify`:
var uopts = {
	'global': true
};

// Generate bundles...
debug( 'Generating %d bundles...', bundles.length );
var idx = -1;
next();

/**
* Generates the next bundle.
*
* @private
*/
function next() {
	var isLarge;
	var minify;
	var bopts;
	var pkgs;
	var b;
	var i;

	idx += 1;

	b = bundles[ idx ];
	debug( 'Bundle: %s', b.name );

	// Determine the list of packages to include in the output bundle...
	debug( 'Resolving bundle package list...' );
	pkgs = names;
	if ( b.include ) {
		for ( i = 0; i < b.include.length; i++ ) {
			pkgs = include( pkgs, b.include[ i ] );
		}
	}
	if ( b.exclude ) {
		for ( i = 0; i < b.exclude.length; i++ ) {
			pkgs = exclude( pkgs, b.exclude[ i ] );
		}
	}
	debug( 'Number of packages to bundle: %d.', pkgs.length );
	debug( 'Included packages: %s.', pkgs.join( ', ' ) );

	// Determine whether the output bundle will be large enough to cause possible issues when minifying...
	for ( i = 0; i < pkgs.length; i++ ) {
		if (
			pkgs[ i ].indexOf( '@stdlib/datasets' ) >= 0 ||
			pkgs[ i ].indexOf( '@stdlib/repl' ) >= 0
		) {
			isLarge = true;
			break;
		}
	}
	// Define bundle options...
	bopts = {
		'standalone': b.standalone,
		'namespace': b.namespace
	};
	if ( isLarge ) {
		if ( b.minified ) {
			bopts.transforms = [
				[ uglifyify, uopts ] // minify modules individually
			];
		}
		// bopts.plugins = [
		// 	collapse    // convert bundle paths to IDs
		// ];
		minify = false; // can encounter memory issues with uglify for bundles which, e.g., include large datasets
	} else {
		bopts.plugins = [
			packFlat    // bundle within a single scope (i.e., remove module wrappers)
		];
		minify = b.minified;
	}
	debug( 'Bundle options: %s', JSON.stringify( bopts ) );

	// Generate a bundle:
	debug( 'Generating bundle...' );
	bundle( pkgs, bopts, clbk( b.name, b.raw, minify ) );
}

/**
* Callback invoked after generating a bundle.
*
* @private
* @param {Error} [error] - error object
* @throws {Error} unexpected error
* @returns {void}
*/
function done( error ) {
	if ( error ) {
		throw error;
	}
	if ( idx === bundles.length-1 ) {
		return debug( 'Finished generating bundles.' );
	}
	if ( global.gc ) {
		debug( 'Running garbage collection...' );
		global.gc();
		debug( 'Finished running garbage collection.' );
	}
	next();
}

/**
* Returns a callback to be invoked upon generating a bundle.
*
* @private
* @param {string} name - bundle name
* @param {boolean} raw - boolean indicating whether to write a raw bundle to file
* @param {boolean} minify - boolean indicating whether to minify a bundle
* @returns {Callback} callback to be invoked upon generating a bundle
*/
function clbk( name, raw, minify ) {
	var b;
	return onBundle;

	/**
	* Callback invoked upon generating a bundle.
	*
	* @private
	* @param {(Error|null)} error - error object
	* @param {(string|Buffer)} [bundle] - output bundle
	* @returns {void}
	*/
	function onBundle( error, bundle ) {
		if ( error ) {
			debug( 'Encountered an error when generating bundle: %s', error.message );
			return done( error );
		}
		debug( 'Finished creating bundle: %s', name );
		b = bundle; // parent scope

		if ( raw ) {
			return writeBundle( bundle, false );
		}
		if ( minify ) {
			return minifyBundle( bundle );
		}
		// NOTE: we assume that: if we are supposed to neither write a "raw" bundle to file nor minify a generated bundle, then the generated bundle was minified during generation.
		writeBundle( bundle, true );
	}

	/**
	* Minifies a bundle and writes the bundle to file.
	*
	* @private
	* @param {(string|Buffer)} bundle - bundle to minify
	*/
	function minifyBundle( bundle ) {
		debug( 'Minifying...' );
		bundle = uglify.minify( bundle.toString() );
		debug( 'Finished minifying bundle: %s', name );
		debug( 'Minification errors: %s', ( bundle.error ) ? bundle.error : '(none)' );
		writeBundle( LICENSE_HEADER+bundle.code, true );
	}

	/**
	* Writes a bundle to file.
	*
	* @private
	* @param {(string|Buffer)} bundle - bundle to write to file
	* @param {boolean} isMinified - boolean indicating whether a bundle is minified
	* @returns {void}
	*/
	function writeBundle( bundle, isMinified ) {
		var fpath;
		if ( isMinified ) {
			fpath = join( dir, name+'.min.js' );
			debug( 'Writing minified bundle to file: %s', fpath );
			return writeFile( fpath, bundle, onWriteMinify );
		}
		fpath = join( dir, name+'.js' );
		debug( 'Writing bundle to file: %s', fpath );
		writeFile( fpath, bundle, onWrite );
	}

	/**
	* Callback invoked upon writing an un-minified bundle to file.
	*
	* @private
	* @param {Error} [error] - error object
	* @returns {void}
	*/
	function onWrite( error ) {
		if ( error ) {
			debug( 'Encountered an error when writing bundle to file: %s', error.message );
			return done( error );
		}
		debug( 'Finished writing bundle `%s` to file.', name );
		if ( minify ) {
			return minifyBundle( b );
		}
		done();
	}

	/**
	* Callback invoked upon writing a minified bundle to file.
	*
	* @private
	* @param {Error} [error] - error object
	* @returns {void}
	*/
	function onWriteMinify( error ) {
		if ( error ) {
			debug( 'Encountered an error when writing bundle to file: %s', error.message );
			return done( error );
		}
		debug( 'Finished writing minified bundle `%s` to file.', name );
		done();
	}
}
