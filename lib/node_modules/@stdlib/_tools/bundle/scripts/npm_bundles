#!/usr/bin/env node

/**
* Script to generate npm bundles.
*
* ## Notes
*
* -   When running this script, you may need to increase Node.js memory limits. For example,
*
*     ```bash
*     $ node --max_old_space_size=4096 ./lib/node_modules/\@stdlib/_tools/bundle/scripts/npm_bundles
*     ```
*
*/
'use strict';

var debug = require( 'debug' )( 'bundle:npm-bundles' );
var join = require( 'path' ).join;
var resolve = require( 'path' ).resolve;
var writeFile = require( 'fs' ).writeFile;
var collapse = require( 'bundle-collapser/plugin' );
var packFlat = require( 'browser-pack-flat/plugin' );
var uglifyify = require( 'uglifyify' );
var uglify = require( 'uglify-es' );
var pkgNames = require( '@stdlib/_tools/pkgs/names' ).sync;
var instanceOf = require( '@stdlib/assert/instance-of' );
var bundle = require( '@stdlib/_tools/bundle/pkg-list' );

/**
* Filters an array of package names by including those package names having a provided substring.
*
* @private
* @param {StringArray} arr - list of package names
* @param {string} pattern - pattern used to filter package names
* @returns {(EmptyArray|StringArray)} filter package list
*/
function include( arr, pattern ) {
	var out;
	var i;
	out = [];
	for ( i = 0; i < arr.length; i++ ) {
		if ( arr[ i ].indexOf( pattern ) >= 0 ) {
			out.push( arr[ i ] );
		}
	}
	return out;
}

/**
* Filters an array of package names by excluding package names having a provided substring.
*
* @private
* @param {StringArray} arr - list of package names
* @param {string} pattern - pattern used to filter package names
* @returns {(EmptyArray|StringArray)} filter package list
*/
function exclude( arr, pattern ) {
	var out;
	var i;
	out = [];
	for ( i = 0; i < arr.length; i++ ) {
		if ( arr[ i ].indexOf( pattern ) === -1 ) {
			out.push( arr[ i ] );
		}
	}
	return out;
}

// Define package resolution options:
var fopts = {
	'pattern': '**/package.json',
	'ignore': [
		'**/_**/**' // ignore "private" packages
	]
};

// Resolve packages:
var names = pkgNames( fopts );
if ( instanceOf( names, Error ) ) {
	throw names;
}

// Define the list of standalone UMD bundles:
var bundles = [
	{
		'filename': 'stdlib-flat.js',
		'standalone': 'stdlib', // UMD
		'datasets': false,
		'namespace': 'flat'
	},
	{
		'filename': 'stdlib-flat.min.js',
		'standalone': 'stdlib',
		'datasets': false,
		'namespace': 'flat'
	},
	{
		'filename': 'stdlib-tree.js',
		'standalone': 'stdlib',
		'datasets': false,
		'namespace': 'tree'
	},
	{
		'filename': 'stdlib-tree.min.js',
		'standalone': 'stdlib',
		'datasets': false,
		'namespace': 'tree'
	},
	{
		'filename': 'stdlib-datasets.min.js',
		'standalone': '@stdlib/datasets',
		'datasets': true,
		'namespace': 'flat'
	}
];

// Define the output directory:
var dir = resolve( __dirname, '..', '..', '..', '..', '..', '..', 'dist' ); // WARNING: fragile, as this may need to be updated if script is moved

// Define options for `uglifyify`:
var uopts = {
	'global': true
};

// Define a regular expression for testing whether a bundle should be minified:
var RE_MINIFY = /\.min\.js$/;

// Generate bundles...
debug( 'Generating %d bundles...', bundles.length );
var idx = -1;
next();

/**
* Generates the next bundle.
*
* @private
*/
function next() {
	var minify;
	var bopts;
	var pkgs;
	var b;

	idx += 1;

	b = bundles[ idx ];
	debug( 'Bundle: %s', b.filename );

	// Determine the list of packages to include in the output bundle...
	debug( 'Determining packages to include...' );
	if ( b.datasets ) {
		pkgs = include( names, '@stdlib/datasets' );
	} else {
		pkgs = exclude( names, '@stdlib/datasets' );
	}
	debug( 'Number of packages to include: %d.', pkgs.length );

	// Define bundle options...
	bopts = {
		'standalone': b.standalone,
		'namespace': b.namespace
	};
	if ( b.datasets ) {
		if ( RE_MINIFY.test( b.filename ) ) {
			bopts.transforms = [
				[ uglifyify, uopts ] // minify modules individually
			];
		}
		bopts.plugins = [
			collapse    // convert bundle paths to IDs
		];
		minify = false; // can encounter memory issues with uglify for large datasets
	} else {
		bopts.plugins = [
			packFlat    // bundle within a single scope (i.e., remove module wrappers)
		];
		minify = RE_MINIFY.test( b.filename );
	}
	debug( 'Bundle options: %s', JSON.stringify( bopts ) );

	// Generate a bundle:
	debug( 'Generating bundle...' );
	bundle( pkgs, bopts, clbk( b.filename, minify ) );
}

/**
* Callback invoked after generating a bundle.
*
* @private
* @param {Error} [error] - error object
* @returns {void}
*/
function done( error ) {
	if ( error ) {
		throw error;
	}
	if ( idx === bundles.length-1 ) {
		return debug( 'Finished generating bundles.' );
	}
	next();
}

/**
* Returns a callback to be invoked upon generating a bundle.
*
* @private
* @param {string} filename - output filename basename
* @param {boolean} bool - boolean indicating whether to minify a bundle
* @returns {Callback} callback to be invoked upon generating a bundle
*/
function clbk( filename, bool ) {
	return onBundle;

	/**
	* Callback invoked upon generating a bundle.
	*
	* @private
	* @param {(Error|null)} error - error object
	* @param {(string|Buffer)} [bundle] - output bundle
	* @throws {Error} unexpected error
	* @returns {void}
	*/
	function onBundle( error, bundle ) {
		var fpath;
		if ( error ) {
			debug( 'Encountered an error when generating bundle: %s', error.message );
			return done( error );
		}
		debug( 'Finished creating bundle: %s', filename );

		if ( bool ) {
			debug( 'Minifying...' );
			bundle = uglify.minify( bundle.toString() );
			debug( 'Finished minifying bundle: %s', filename );
			debug( 'Minification errors: %s', ( bundle.error ) ? bundle.error : '(none)' );
			bundle = bundle.code;
		}
		fpath = join( dir, filename );
		debug( 'Writing bundle to file: %s', fpath );
		writeFile( fpath, bundle, onWrite );
	}

	/**
	* Callback invoked upon writing a bundle to file.
	*
	* @private
	* @param {Error} [error] - error object
	* @throws {Error} unexpected error
	* @returns {void}
	*/
	function onWrite( error ) {
		if ( error ) {
			debug( 'Encountered an error when writing bundle to file: %s', error.message );
			return done( error );
		}
		debug( 'Finished writing bundle %s to file.', filename );
		done();
	}
}
