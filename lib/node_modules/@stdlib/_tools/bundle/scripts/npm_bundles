#!/usr/bin/env node

/**
* Script to generate npm bundles.
*
* ## Usages
*
* ```bash
* $ DEBUG=bundle:npm-bundles node --max_old_space_size=4096 --expose_gc /path/to/bundle/scripts/npm_bundles
* ```
*
* ## Notes
*
* -   When running this script, you may need to increase Node.js memory limits. For example,
*
*     ```bash
*     $ node --max_old_space_size=4096 ./lib/node_modules/\@stdlib/_tools/bundle/scripts/npm_bundles
*     ```
*
* -   To allow for manual garbage collection, expose garbage collection using the `--expose_gc` command-line flag
*
*     ```bash
*     $ node --expose_gc ./lib/node_modules/\@stdlib/_tools/bundle/scripts/npm_bundles
*     ```
*
* @private
*/
'use strict';

var debug = require( 'debug' )( 'bundle:npm-bundles' );
var join = require( 'path' ).join;
var resolve = require( 'path' ).resolve;
var writeFile = require( 'fs' ).writeFile;
var collapse = require( 'bundle-collapser/plugin' );
var packFlat = require( 'browser-pack-flat/plugin' );
var uglifyify = require( 'uglifyify' );
var uglify = require( 'uglify-es' );
var pkgNames = require( '@stdlib/_tools/pkgs/names' ).sync;
var instanceOf = require( '@stdlib/assert/instance-of' );
var bundle = require( '@stdlib/_tools/bundle/pkg-list' );

/**
* Filters an array of package names by including those package names having a provided substring.
*
* @private
* @param {StringArray} arr - list of package names
* @param {string} pattern - pattern used to filter package names
* @returns {(EmptyArray|StringArray)} filter package list
*/
function include( arr, pattern ) {
	var out;
	var i;
	out = [];
	for ( i = 0; i < arr.length; i++ ) {
		if ( arr[ i ].indexOf( pattern ) >= 0 ) {
			out.push( arr[ i ] );
		}
	}
	return out;
}

/**
* Filters an array of package names by excluding package names having a provided substring.
*
* @private
* @param {StringArray} arr - list of package names
* @param {string} pattern - pattern used to filter package names
* @returns {(EmptyArray|StringArray)} filter package list
*/
function exclude( arr, pattern ) {
	var out;
	var i;
	out = [];
	for ( i = 0; i < arr.length; i++ ) {
		if ( arr[ i ].indexOf( pattern ) === -1 ) {
			out.push( arr[ i ] );
		}
	}
	return out;
}

// Define package resolution options:
var fopts = {
	'pattern': '**/package.json',
	'ignore': [
		'**/_**/**' // ignore "private" packages
	]
};

// Resolve packages:
var names = pkgNames( fopts );
if ( instanceOf( names, Error ) ) {
	throw names;
}

// Define the list of standalone UMD bundles:
var bundles = [
	{
		'name': 'stdlib-flat',
		'standalone': 'stdlib', // UMD
		'namespace': 'flat',
		'raw': true,
		'minified': true,
		'exclude': [
			'@stdlib/datasets',
			'@stdlib/namespace',
			'@stdlib/repl'
		]
	},
	{
		'name': 'stdlib-tree',
		'standalone': 'stdlib',
		'namespace': 'tree',
		'raw': true,
		'minified': true,
		'exclude': [
			'@stdlib/datasets',
			'@stdlib/namespace',
			'@stdlib/repl'
		]
	},
	{
		'name': 'stdlib-datasets-tree',
		'standalone': 'stdlib_datasets',
		'namespace': 'tree', // we want the namespace, so cannot use `flat` (REPL has `datasets` alias for `@stdlib/datasets`)
		'raw': false,
		'minified': true,
		'include': [
			'@stdlib/datasets'
		]
	},
	{
		'name': 'stdlib-repl',
		'standalone': 'stdlib_repl',
		'namespace': 'tree', // we want the namespace, so cannot use `flat` (only want `@stdlib/repl` namespace)
		'raw': false,
		'minified': true,
		'include': [
			'@stdlib/repl'
		],
		'exclude': [
			// WARNING: this list is fragile, as we must manually update the list of what to exclude as the namespace changes.
			'@stdlib/repl/code-blocks',
			'@stdlib/repl/help',
			'@stdlib/repl/server'
		]
	}
];

// Define the output directory:
var dir = resolve( __dirname, '..', '..', '..', '..', '..', '..', 'dist' ); // WARNING: fragile, as this may need to be updated if script is moved

// Define options for `uglifyify`:
var uopts = {
	'global': true
};

// Generate bundles...
debug( 'Generating %d bundles...', bundles.length );
var idx = -1;
next();

/**
* Generates the next bundle.
*
* @private
*/
function next() {
	var isLarge;
	var minify;
	var bopts;
	var pkgs;
	var b;
	var i;

	idx += 1;

	b = bundles[ idx ];
	debug( 'Bundle: %s', b.name );

	// Determine the list of packages to include in the output bundle...
	debug( 'Resolving bundle package list...' );
	pkgs = names;
	if ( b.include ) {
		for ( i = 0; i < b.include.length; i++ ) {
			pkgs = include( pkgs, b.include[ i ] );
		}
	}
	if ( b.exclude ) {
		for ( i = 0; i < b.exclude.length; i++ ) {
			pkgs = exclude( pkgs, b.exclude[ i ] );
		}
	}
	debug( 'Number of packages to bundle: %d.', pkgs.length );
	debug( 'Included packages: %s.', pkgs.join( ', ' ) );

	// Determine whether the output bundle will be large enough to cause possible issues when minifying...
	for ( i = 0; i < pkgs.length; i++ ) {
		if (
			pkgs[ i ].indexOf( '@stdlib/datasets' ) >= 0 ||
			pkgs[ i ].indexOf( '@stdlib/repl' ) >= 0
		) {
			isLarge = true;
			break;
		}
	}
	// Define bundle options...
	bopts = {
		'standalone': b.standalone,
		'namespace': b.namespace
	};
	if ( isLarge ) {
		if ( b.minified ) {
			bopts.transforms = [
				[ uglifyify, uopts ] // minify modules individually
			];
		}
		bopts.plugins = [
			collapse    // convert bundle paths to IDs
		];
		minify = false; // can encounter memory issues with uglify for bundles which, e.g., include large datasets
	} else {
		bopts.plugins = [
			packFlat    // bundle within a single scope (i.e., remove module wrappers)
		];
		minify = b.minified;
	}
	debug( 'Bundle options: %s', JSON.stringify( bopts ) );

	// Generate a bundle:
	debug( 'Generating bundle...' );
	bundle( pkgs, bopts, clbk( b.name, b.raw, minify ) );
}

/**
* Callback invoked after generating a bundle.
*
* @private
* @param {Error} [error] - error object
* @throws {Error} unexpected error
* @returns {void}
*/
function done( error ) {
	if ( error ) {
		throw error;
	}
	if ( idx === bundles.length-1 ) {
		return debug( 'Finished generating bundles.' );
	}
	if ( global.gc ) {
		debug( 'Running garbage collection...' );
		global.gc();
		debug( 'Finished running garbage collection.' );
	}
	next();
}

/**
* Returns a callback to be invoked upon generating a bundle.
*
* @private
* @param {string} name - bundle name
* @param {boolean} raw - boolean indicating whether to save a raw bundle
* @param {boolean} minify - boolean indicating whether to minify a bundle
* @returns {Callback} callback to be invoked upon generating a bundle
*/
function clbk( name, raw, minify ) {
	var b;
	return onBundle;

	/**
	* Callback invoked upon generating a bundle.
	*
	* @private
	* @param {(Error|null)} error - error object
	* @param {(string|Buffer)} [bundle] - output bundle
	* @returns {void}
	*/
	function onBundle( error, bundle ) {
		var fpath;
		if ( error ) {
			debug( 'Encountered an error when generating bundle: %s', error.message );
			return done( error );
		}
		debug( 'Finished creating bundle: %s', name );
		b = bundle; // parent scope

		fpath = join( dir, name+'.js' );
		debug( 'Writing bundle to file: %s', fpath );
		writeFile( fpath, b, onWrite );
	}

	/**
	* Callback invoked upon writing a bundle to file.
	*
	* @private
	* @param {Error} [error] - error object
	* @returns {void}
	*/
	function onWrite( error ) {
		var bundle;
		var fpath;
		if ( error ) {
			debug( 'Encountered an error when writing bundle to file: %s', error.message );
			return done( error );
		}
		debug( 'Finished writing bundle `%s` to file.', name );
		if ( !minify ) {
			return done();
		}
		debug( 'Minifying...' );
		bundle = uglify.minify( b.toString() );
		debug( 'Finished minifying bundle: %s', name );
		debug( 'Minification errors: %s', ( bundle.error ) ? bundle.error : '(none)' );
		bundle = bundle.code;

		fpath = join( dir, name+'.min.js' );
		debug( 'Writing minified bundle to file: %s', fpath );
		writeFile( fpath, bundle, onWriteMinify );
	}

	/**
	* Callback invoked upon writing a minified bundle to file.
	*
	* @private
	* @param {Error} [error] - error object
	* @returns {void}
	*/
	function onWriteMinify( error ) {
		if ( error ) {
			debug( 'Encountered an error when writing bundle to file: %s', error.message );
			return done( error );
		}
		debug( 'Finished writing minified bundle `%s` to file.', name );
		done();
	}
}
