'use strict';

// MODULES //

var isPositiveInteger = require( '@stdlib/utils/is-positive-integer' );
var randu = require( '@stdlib/math/base/random/randu' );
var avgMatrix = require( './avg_matrix.js' );


// COLLAPSED GIBBS //

/**
* Fit model using collapsed Gibbs sampling.
*
* @param {PositiveInteger} iter - number of sampling iterations
* @param {PositiveInteger} burnin - number of estimates to be thrown away at beginning
* @param {PositiveInteger} thin - number of discarded in-between iterations
*/
function fit( iter, burnin, thin ) {
	/* jshint validthis: true */ // TODO: eslint
	var currentTheta;
	var currentPhi;
	var newTopic;
	var kalpha;
	var wbeta;
	var topic;
	var prob;
	var word;
	var nt;
	var d;
	var i;
	var j;
	var u;
	var w;

	if ( !isPositiveInteger( iter ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a positive integer. Value: `' + iter + '`.' );
	}
	if ( !isPositiveInteger( burnin ) ) {
		throw new TypeError( 'invalid input argument. Second argument must be a positive integer. Value: `' + burnin + '`.' );
	}
	if ( !isPositiveInteger( thin ) ) {
		throw new TypeError( 'invalid input argument. Third argument must be a positive integer. Value: `' + thin + '`.' );
	}

	wbeta = this.W * this.beta;
	kalpha = this.K * this.alpha;

	for ( i = 0; i < iter; i++ ) {
		for ( d = 0; d < this.D; d++ ) {
			for ( w = 0; w < this.ndSum[ d ]; w++ ) {
				word = this.w[ d ][ w ];
				topic = this.z[ d ][ w ];

				this.nw.set( word, topic, this.nw.get( word, topic ) - 1 );
				this.nd.set( d, topic, this.nd.get( d, topic ) - 1 );
				this.ndSum[ d ] -= 1;
				this.nwSum[ topic ] -= 1;

				prob = new Array( this.K );
				for ( j = 0; j < this.K; j++ ) {
					prob[ j ] = ( this.nw.get( word, j ) + this.beta ) /
						( this.nwSum[ j ] + wbeta ) *
						( this.nd.get( d, j ) + this.alpha ) /
						( this.ndSum[ d ] + kalpha );
				}
				for ( j = 1; j < this.K; j++ ) {
					prob[ j ] = prob[ j ] + prob[ j - 1 ];
				}
				u = prob[ this.K - 1 ] * randu();
				newTopic = 0;
				for ( nt = 0; nt < this.K; nt++ ) {
					if ( prob[ nt ] > u ) {
						newTopic = nt;
						break;
					}
				}
				// Assign new z_i to counts...
				this.nw.set( word, newTopic, this.nw.get( word, newTopic ) + 1 );
				this.nd.set( d, newTopic, this.nd.get( d, newTopic ) + 1 );
				this.nwSum[ newTopic ] += 1;
				this.ndSum[ d ] += 1;

				this.z[ d ][ w ] = newTopic;
			}
		}

		if ( i % thin === 0 && i > burnin ) {
			currentPhi = this.getPhis();
			currentTheta = this.getThetas();

			this.phiList.push( currentPhi );
			this.thetaList.push( currentTheta );

			if ( this.phiList.length === 1 ) {
				this.avgPhi = currentPhi;
			} else {
				this.avgPhi = avgMatrix( this.avgPhi, currentPhi, this.phiList.length );
			}
			if ( this.thetaList.length === 1 ) {
				this.avgTheta = currentTheta;
			} else {
				this.avgTheta = avgMatrix( this.avgTheta, currentTheta, this.thetaList.length );
			}
		}
	}
} // end FUNCTION fit()


// EXPORTS //

module.exports = fit;
