/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#include "stdlib/strided_binary.h"
#include "stdlib/ndarray/base/bytes_per_element.h"
#include "stdlib/ndarray/dtypes.h"
#include <node_api.h>
#include <stdint.h>
#include <stdbool.h>
#include <assert.h>

/**
* Add-on namespace.
*/
namespace addon_strided_add {

	/**
	* Adds two doubles.
	*
	* @private
	* @param x  first double
	* @param y  second double
	* @return   sum
	*/
	double add( double x, double y ) {
		return x + y;
	}

	/**
	* Returns a typed array data type.
	*
	* @private
	* @param vtype  typed array type
	* @return       data type
	*/
	enum STDLIB_NDARRAY_DTYPE typed_array_data_type( napi_typedarray_type vtype ) {
		if ( vtype == napi_float64_array ) {
			return STDLIB_NDARRAY_FLOAT64;
		}
		if ( vtype == napi_float32_array ) {
			return STDLIB_NDARRAY_FLOAT32;
		}
		if ( vtype == napi_int32_array ) {
			return STDLIB_NDARRAY_INT32;
		}
		if ( vtype == napi_uint32_array ) {
			return STDLIB_NDARRAY_UINT32;
		}
		if ( vtype == napi_int16_array ) {
			return STDLIB_NDARRAY_INT16;
		}
		if ( vtype == napi_uint16_array ) {
			return STDLIB_NDARRAY_UINT16;
		}
		if ( vtype == napi_int8_array ) {
			return STDLIB_NDARRAY_INT8;
		}
		if ( vtype == napi_uint8_array ) {
			return STDLIB_NDARRAY_UINT8;
		}
		if ( vtype == napi_uint8_clamped_array ) {
			return STDLIB_NDARRAY_UINT8;
		}
		if ( vtype == napi_bigint64_array ) {
			return STDLIB_NDARRAY_INT64;
		}
		return STDLIB_NDARRAY_UINT64; // vtype == napi_biguint64_array
	}

	/**
	* Validates, extracts, and transforms arguments provided to the main entry point for a Node.js add-on to native C types.
	*
	* ## Notes
	*
	* -   The function assumes the following argument order:
	*
	*     ```text
	*     [ N, ia1, is1, ia2, is2, ..., oa1, os1, oa2, os2, ... ]
	*     ```
	*
	*     where
	*
	*     -   `N` is the number of elements over which to iterate
	*     -   `ia#` is an input strided array
	*     -   `is#` is a corresponding input strided array stride (in units of elements)
	*     -   `oa#` is an output strided array
	*     -   `os#` is a corresponding output strided array stride (in units of elements)
	*
	* -   We **assume** (due to use of bit flags for keeping track of scalar arguments) no more than `64` input strided array arguments, which seems a reasonable assumption, as strided array functions which operate over `65` or more input strided arrays are **exceedingly** unlikely (most strided array functions operate on 3 or fewer input strided arrays).
	*
	* @private
	* @param env      environment
	* @param info     arguments
	* @param nargs    total number of expected arguments
	* @param nin      number of input strided array arguments
	* @param nout     number of output strided array arguments
	* @param arrays   destination array containing pointers to both input and output strided byte arrays
	* @param shape    destination array containing the array shape (dimensions)
	* @param strides  destination array containing array strides (in bytes) for each strided array
	* @param types    destination array containing strided array argument data types
	* @throws         must provide expected number of input arguments
	* @throws         stride arguments must be numbers
	* @throws         input strided array arguments must be either typed arrays or scalars
	* @throws         output strided array arguments must be typed arrays
	* @throws         must provide at least one input strided array
	* @return         number of scalar strided "array" arguments
	*/
	int64_t stdlib_napi_addon_strided_array_function_arguments( const napi_env env, const napi_callback_info info, const int64_t nargs, const int64_t nin, const int64_t nout, uint8_t *arrays[], int64_t *shape, int64_t *strides, enum STDLIB_NDARRAY_DTYPE *types ) {
		napi_status status;
		int64_t i;
		int64_t j;

		// Compute the index of the first output strided array argument:
		int64_t iout = ( nin*2 ) + 1;

		// Initialize variables used to track scalar input arguments:
		int64_t nsargs = 0;
		int64_t sargs = 0;

		// Get callback arguments:
		size_t argc = 7;
		napi_value argv[ 7 ];
		status = napi_get_cb_info( env, info, &argc, argv, nullptr, nullptr );
		assert( status == napi_ok );

		if ( (int64_t)argc != nargs ) {
			napi_throw_error( env, nullptr, "invalid invocation. Incorrect number of arguments." );
			return -1;
		}

		// The first argument is always the number of elements over which to iterate...
		napi_valuetype vtype0;
		status = napi_typeof( env, argv[ 0 ], &vtype0 );
		assert( status == napi_ok );
		if ( vtype0 != napi_number ) {
			napi_throw_type_error( env, nullptr, "invalid argument. First argument must be a number." );
			return -1;
		}

		// Retrieve the number of elements:
		int64_t N;
		status = napi_get_value_int64( env, argv[ 0 ], &N );
		assert( status == napi_ok );

		shape[ 0 ] = N;

		// Stride arguments for both input and output strided arrays are every other argument beginning from the third argument...
		for ( i = 2; i < nargs; i += 2 ) {
			napi_valuetype vtype;
			status = napi_typeof( env, argv[ i ], &vtype );
			assert( status == napi_ok );
			if ( vtype != napi_number ) {
				napi_throw_type_error( env, nullptr, "invalid argument. Stride argument must be a number." );
				return -1;
			}

			int64_t stride;
			status = napi_get_value_int64( env, argv[ i ], &stride );
			assert( status == napi_ok );

			j = ( i-2 ) / 2;
			strides[ j ] = stride;
		}

		// Input strided array arguments are every other argument beginning from the second argument...
		for ( i = 1; i < iout; i += 2 ) {
			j = ( i-1 ) / 2;

			bool res;
			status = napi_is_typedarray( env, argv[ i ], &res );
			assert( status == napi_ok );
			if ( res == true ) {
				napi_typedarray_type vtype;
				size_t len;
				void *TypedArray;
				status = napi_get_typedarray_info( env, argv[ i ], &vtype, &len, &TypedArray, nullptr, nullptr );
				assert( status == napi_ok );
				if ( (N-1)*llabs(strides[j]) > (int64_t)len ) {
					napi_throw_range_error( env, nullptr, "invalid argument. Input array argument has insufficient elements based on the associated stride and the number of indexed elements." );
					return -1;
				}

				arrays[ j ] = (uint8_t *)TypedArray;
				types[ j ] = typed_array_data_type( vtype );
				strides[ j ] *= stdlib_ndarray_bytes_per_element( types[ j ] );
			} else {
				double v;
				status = napi_get_value_double( env, argv[ i ], &v );
				if ( status != napi_ok ) {
					napi_throw_type_error( env, nullptr, "invalid argument. Input strided array argument must be a typed array or scalar." );
					return -1;
				}
				sargs |= (1<<j);
				nsargs += 1;
			}
		}

		// Output strided array arguments are every other argument beginning from the argument following the last input strided array stride argument...
		for ( i = iout; i < nargs; i += 2 ) {
			j = ( i-1 ) / 2;

			bool res;
			status = napi_is_typedarray( env, argv[ i ], &res );
			assert( status == napi_ok );
			if ( res == true ) {
				napi_typedarray_type vtype;
				size_t len;
				void *TypedArray;
				status = napi_get_typedarray_info( env, argv[ i ], &vtype, &len, &TypedArray, nullptr, nullptr );
				assert( status == napi_ok );
				if ( (N-1)*llabs(strides[j]) > (int64_t)len ) {
					napi_throw_range_error( env, nullptr, "invalid argument. Output array argument has insufficient elements based on the associated stride and the number of indexed elements." );
					return -1;
				}

				arrays[ j ] = (uint8_t *)TypedArray;
				types[ j ] = typed_array_data_type( vtype );
				strides[ j ] *= stdlib_ndarray_bytes_per_element( types[ j ] );
			} else {
				napi_throw_type_error( env, nullptr, "invalid argument. Output strided array arguments must be typed arrays." );
				return -1;
			}
		}

		// Check if we have been provided only scalar input arguments...
		if ( nin > 0 && nsargs == nin ) {
			napi_throw_type_error( env, nullptr, "invalid arguments. Must provide at least one input strided array argument." );
			return -1;
		}
		return nsargs;
	}

	/**
	* Adds each element in `X` to a corresponding element in `Y` and assigns the result to an element in `Z`.
	*
	* ## Notes
	*
	* -   When called from JavaScript, the function expects the following arguments:
	*
	*     -   `N`: number of indexed elements
	*     -   `X`: input array (or scalar constant)
	*     -   `strideX`: `X` stride length
	*     -   `Y`: input array (or scalar constant)
	*     -   `strideY`: `Y` stride length
	*     -   `Z`: destination array
	*     -   `strideZ`: `Z` stride length
	*/
	napi_value node_add( napi_env env, napi_callback_info info ) {
		enum STDLIB_NDARRAY_DTYPE types[ 3 ];
		uint8_t *arrays[ 3 ];
		int64_t strides[ 3 ];
		int64_t shape[ 1 ];
		int64_t nsargs;
		int64_t nargs;
		int64_t nout;
		int64_t nin;

		// Total number of input arguments:
		nargs = 7;

		// Number of input and output strided array arguments:
		nin = 2;
		nout = 1;

		// Process the provided arguments:
		nsargs = stdlib_napi_addon_strided_array_function_arguments( env, info, nargs, nin, nout, arrays, shape, strides, types );
		if ( nsargs < 0 ) {
			return nullptr;
		}

		// Broadcasting of scalar arguments...
		if ( nsargs > 0 ) {
			// FIXME
			// Create an array having the closest "compatible" type...
			// arrays[ 0 ] = broadcast( static_cast<double>( info[ 1 ]->NumberValue() ), types[ 0 ] );
		}

		// Perform addition (NOTE: this currently assumes Float64Array input and output strided array arguments!!!):
		stdlib_strided_dd_d( arrays, shape, strides, (void *)add );

		return nullptr;
	}

	napi_value Init( napi_env env, napi_value exports ) {
		napi_status status;
		napi_value fcn;
		status = napi_create_function( env, "exports", NAPI_AUTO_LENGTH, node_add, NULL, &fcn );
		assert( status == napi_ok );
		return fcn;
	}

	NAPI_MODULE( NODE_GYP_MODULE_NAME, Init )
} // end namespace addon_strided_add
