/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
* Add each element in `X` to a corresponding element in `Y` and assigns the result to an element in `Z`.
*/
#include <stdint.h>
#include <nan.h>
#include "stdlib/ndarray/base/bytes_per_element.h"
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/strided_binary.h"

/**
* Add-on namespace.
*/
namespace addon_strided_add {

	using Nan::FunctionCallbackInfo;
	using Nan::TypedArrayContents;
	using Nan::ThrowTypeError;
	using Nan::ThrowError;
	using v8::Local;
	using v8::Value;

	/**
	* Adds two doubles.
	*
	* @private
	* @param x  first double
	* @param y  second double
	* @return   sum
	*/
	double add( double x, double y ) {
		return x + y;
	}

	/**
	* Returns a typed array data type.
	*
	* @private
	* @param x  typed array
	* @return   data type
	*/
	enum STDLIB_NDARRAY_DTYPE typed_array_data_type( Local<Value> x ) {
		if ( x->IsFloat64Array() ) {
			return STDLIB_NDARRAY_FLOAT64;
		}
		if ( x->IsFloat32Array() ) {
			return STDLIB_NDARRAY_FLOAT32;
		}
		if ( x->IsInt32Array() ) {
			return STDLIB_NDARRAY_INT32;
		}
		if ( x->IsUint32Array() ) {
			return STDLIB_NDARRAY_UINT32;
		}
		if ( x->IsInt16Array() ) {
			return STDLIB_NDARRAY_INT16;
		}
		if ( x->IsUint16Array() ) {
			return STDLIB_NDARRAY_UINT16;
		}
		if ( x->IsInt8Array() ) {
			return STDLIB_NDARRAY_INT8;
		}
		if ( x->IsUint8Array() ) {
			return STDLIB_NDARRAY_UINT8;
		}
		return STDLIB_NDARRAY_UINT8; // Uint8ClampedArray
	}

	/**
	* Adds each element in `X` to a corresponding element in `Y` and assigns the result to an element in `Z`.
	*
	* When called from JavaScript, the function expects the following arguments:
	*
	* * __n__: number of elements.
	* * __X__: input typed array.
	* * __sx__: `X` stride length.
	* * __Y__: input typed array.
	* * __sy__: `Y` typed array stride length.
	* * __Z__: destination typed array.
	* * __sz__: destination typed array stride length.
	*
	* @param info   arguments
	*/
	void node_add( const FunctionCallbackInfo<Value>& info ) {
		enum STDLIB_NDARRAY_DTYPE types[ 3 ];
		uint8_t *arrays[ 3 ];
		int64_t strides[ 3 ];
		int64_t shape[ 1 ];
		uint8_t scalarX;
		uint8_t scalarY;

		scalarX = 0;
		scalarY = 0;

		if ( info.Length() != 7 ) {
			ThrowError( "invalid invocation. Must provide 7 arguments." );
			return;
		}
		if ( !info[ 0 ]->IsNumber() ) {
			ThrowTypeError( "invalid input argument. First argument must be a number." );
			return;
		}
		if ( !info[ 2 ]->IsNumber() ) {
			ThrowTypeError( "invalid input argument. Third argument must be a number." );
			return;
		}
		if ( !info[ 4 ]->IsNumber() ) {
			ThrowTypeError( "invalid input argument. Fifth argument must be a number." );
			return;
		}
		if ( !info[ 6 ]->IsNumber() ) {
			ThrowTypeError( "invalid input argument. Seventh argument must be a number." );
			return;
		}
		// Retrieve the number of elements:
		shape[ 0 ] = static_cast<int64_t>( info[ 0 ]->IntegerValue() );

		// Retrieve the strides:
		strides[ 0 ] = static_cast<int64_t>( info[ 2 ]->IntegerValue() );
		strides[ 1 ] = static_cast<int64_t>( info[ 4 ]->IntegerValue() );
		strides[ 2 ] = static_cast<int64_t>( info[ 6 ]->IntegerValue() );

#if defined(V8_MAJOR_VERSION) && ( V8_MAJOR_VERSION > 4 || ( V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3 ) )

		// Validate input arguments:
		if ( info[ 1 ]->IsArrayBufferView() ) {
			types[ 0 ] = typed_array_data_type( info[ 1 ] );
			TypedArrayContents<uint8_t> X( info[ 1 ] );
			strides[ 0 ] *= stdlib_ndarray_bytes_per_element( types[ 0 ] );
			arrays[ 0 ] = *X;
		} else if ( info[ 1 ]->IsNumber() ) {
			scalarX = 1;
		} else {
			ThrowTypeError( "invalid input argument. Second argument must be a typed array or scalar." );
			return;
		}
		if ( info[ 3 ]->IsArrayBufferView() ) {
			types[ 1 ] = typed_array_data_type( info[ 3 ] );
			TypedArrayContents<uint8_t> Y( info[ 3 ] );
			strides[ 1 ] *= stdlib_ndarray_bytes_per_element( types[ 1 ] );
			arrays[ 1 ] = *Y;
		} else if ( info[ 3 ]->IsNumber() ) {
			scalarY = 1;
		} else {
			ThrowTypeError( "invalid input argument. Fourth argument must be a typed array or scalar." );
			return;
		}

		// Validate the output argument:
		if ( !info[ 5 ]->IsArrayBufferView() ) {
			ThrowTypeError( "invalid input argument. Sixth argument must be a typed array." );
			return;
		} else {
			types[ 2 ] = typed_array_data_type( info[ 5 ] );
			TypedArrayContents<uint8_t> Z( info[ 5 ] );
			strides[ 2 ] *= stdlib_ndarray_bytes_per_element( types[ 2 ] );
			arrays[ 2 ] = *Z;
		}

#else

		// TODO: add support for older Node versions

		// Validate input arguments:
		if ( info[ 1 ]->IsNumber() ) {
			scalarX = 1;
		} else if ( info[ 1 ]->IsObject() && !info[ 1 ]->IsNull() ) {
			// Assume type array:
			TypedArrayContents<uint8_t> X( info[ 1 ] );

			types[ 0 ] = STDLIB_NDARRAY_FLOAT64; // TODO: determine data type
			strides[ 0 ] *= 8; // TODO: compute based on data type

			arrays[ 0 ] = *X;
		} else {
			ThrowTypeError( "invalid input argument. Second argument must be a typed array or scalar." );
		}
		if ( info[ 3 ]->IsNumber() ) {
			scalarY = 1;
		} else if ( info[ 3 ]->IsObject() && !info[ 3 ]->IsNull() ) {
			// Assume type array:
			TypedArrayContents<uint8_t> Y( info[ 3 ] );

			types[ 1 ] = STDLIB_NDARRAY_FLOAT64; // TODO: determine data type
			strides[ 1 ] *= 8; // TODO: compute based on data type

			arrays[ 1 ] = *Y;
		} else {
			ThrowTypeError( "invalid input argument. Fourth argument must be a typed array or scalar." );
		}

		// Validate output argument:
		if ( info[ 5 ]->IsObject() && !info[ 5 ]->IsNull() ) {
			// Assume type array:
			TypedArrayContents<uint8_t> Z( info[ 5 ] );

			types[ 2 ] = STDLIB_NDARRAY_FLOAT64; // TODO: determine data type
			strides[ 2 ] *= 8; // TODO: compute based on data type

			arrays[ 2 ] = *Z;
		} else {
			ThrowTypeError( "invalid input argument. Sixth argument must be a typed array." );
		}

#endif

		// Broadcasting...
		if ( scalarX == 1 ) {
			if ( scalarY == 1 ) {
				ThrowError( "invalid input arguments. At least one of the second and fourth arguments must be a typed array." );
				return;
			}
			// Create an array having the closest "compatible" type...
			arrays[ 0 ] = broadcast( static_cast<double>( info[ 1 ]->NumberValue() ), types[ 0 ] );
		}
		if ( scalarY == 1 ) {
			// Create an array having the closest "compatible" type...
			arrays[ 1 ] = broadcast( static_cast<double>( info[ 3 ]->NumberValue() ), types[ 1 ] );
		}

		// Perform addition:
		stdlib_strided_dd_d( arrays, shape, strides, (void *)add );
	}

	NAN_MODULE_INIT( Init ) {
		Nan::Export( target, "add", node_add );
	}

	NODE_MODULE( addon, Init )
} // end namespace addon_strided_add
