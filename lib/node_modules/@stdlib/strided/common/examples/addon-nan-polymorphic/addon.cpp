/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
* Add each element in `X` to a corresponding element in `Y` and assigns the result to an element in `Z`.
*/
#include <stdint.h>
#include <nan.h>
#include "stdlib/ndarray/base/bytes_per_element.h"
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/strided_binary.h"

/**
* Add-on namespace.
*/
namespace addon_strided_add {

	using Nan::FunctionCallbackInfo;
	using Nan::TypedArrayContents;
	using Nan::ThrowTypeError;
	using Nan::ThrowError;
	using v8::Local;
	using v8::Value;

	/**
	* Adds two doubles.
	*
	* @private
	* @param x  first double
	* @param y  second double
	* @return   sum
	*/
	double add( double x, double y ) {
		return x + y;
	}

	/**
	* Returns a typed array data type.
	*
	* @private
	* @param x  typed array
	* @return   data type
	*/
	enum STDLIB_NDARRAY_DTYPE typed_array_data_type( Local<Value> x ) {
		if ( x->IsFloat64Array() ) {
			return STDLIB_NDARRAY_FLOAT64;
		}
		if ( x->IsFloat32Array() ) {
			return STDLIB_NDARRAY_FLOAT32;
		}
		if ( x->IsInt32Array() ) {
			return STDLIB_NDARRAY_INT32;
		}
		if ( x->IsUint32Array() ) {
			return STDLIB_NDARRAY_UINT32;
		}
		if ( x->IsInt16Array() ) {
			return STDLIB_NDARRAY_INT16;
		}
		if ( x->IsUint16Array() ) {
			return STDLIB_NDARRAY_UINT16;
		}
		if ( x->IsInt8Array() ) {
			return STDLIB_NDARRAY_INT8;
		}
		if ( x->IsUint8Array() ) {
			return STDLIB_NDARRAY_UINT8;
		}
		return STDLIB_NDARRAY_UINT8; // Uint8ClampedArray
	}

	/**
	* Adds each element in `X` to a corresponding element in `Y` and assigns the result to an element in `Z`.
	*
	* When called from JavaScript, the function expects the following arguments:
	*
	* * __n__: number of elements.
	* * __X__: input typed array.
	* * __sx__: `X` stride length.
	* * __Y__: input typed array.
	* * __sy__: `Y` typed array stride length.
	* * __Z__: destination typed array.
	* * __sz__: destination typed array stride length.
	*
	* @param info   arguments
	*/
	void node_add( const FunctionCallbackInfo<Value>& info ) {
		enum STDLIB_NDARRAY_DTYPE types[ 3 ];
		uint8_t *arrays[ 3 ];
		int64_t strides[ 3 ];
		int64_t shape[ 1 ];
		uint8_t scalarX;
		uint8_t scalarY;
		int64_t nargs;
		int64_t nout;
		int64_t nin;
		int64_t i;
		int64_t j;
		int64_t n;

		nargs = 7;

		// Number of input and output strided array arguments:
		nin = 2;
		nout = 1;

		// Compute the index of the first output strided array argument:
		n = ( nin*2 ) + 1;

		if ( info.Length() != nargs ) {
			ThrowError( "invalid invocation. Incorrect number of arguments." );
			return;
		}

		// The first argument is always the number of elements over which to iterate...
		if ( !info[ 0 ]->IsNumber() ) {
			ThrowTypeError( "invalid input argument. First argument must be a number." );
			return;
		} else {
			shape[ 0 ] = static_cast<int64_t>( info[ 0 ]->IntegerValue() );
		}

		// Stride arguments for both input and output strided arrays are every other argument beginning from the third argument...
		for ( i = 2; i < nargs; i += 2 ) {
			if ( !info[ i ]->IsNumber() ) {
				ThrowTypeError( "invalid input argument. Stride argument must be a number." );
				return;
			}
			j = ( i-2 ) / 2;
			strides[ j ] = static_cast<int64_t>( info[ i ]->IntegerValue() );
		}

#if defined(V8_MAJOR_VERSION) && ( V8_MAJOR_VERSION > 4 || ( V8_MAJOR_VERSION == 4 && defined(V8_MINOR_VERSION) && V8_MINOR_VERSION >= 3 ) )

		// Input strided array arguments are every other argument beginning from the second argument...
		for ( i = 1; i < n; i += 2 ) {
			if ( info[ i ]->IsArrayBufferView() ) {
				j = ( i-1 ) / 2;
				TypedArrayContents<uint8_t> TypedArray( info[ i ] );
				arrays[ j ] = *TypedArray;
				types[ j ] = typed_array_data_type( info[ i ] );
				strides[ j ] *= stdlib_ndarray_bytes_per_element( types[ j ] );
			} else if ( info[ i ]->IsNumber() ) {
				scalarX = 1; // TODO
			} else {
				ThrowTypeError( "invalid input argument. Input strided array argument must be a typed array or scalar." );
				return;
			}
		}

		// Output strided array arguments are every other argument beginning from the argument following the last input strided array stride argument...
		for ( i = n; i < nargs; i++ ) {
			if ( !info[ i ]->IsArrayBufferView() ) {
				ThrowTypeError( "invalid input argument. Output strided array argument must be a typed array." );
				return;
			} else {
				j = ( i-1 ) / 2;
				TypedArrayContents<uint8_t> TypedArray( info[ i ] );
				arrays[ j ] = *TypedArray;
				types[ j ] = typed_array_data_type( info[ i ] );
				strides[ j ] *= stdlib_ndarray_bytes_per_element( types[ j ] );
			}
		}

#else

		// TODO: add support for older Node versions (type verification and strides; see https://github.com/nodejs/node/blob/v0.10.39-release/src/v8_typed_array.cc and https://github.com/nodejs/nan/blob/master/nan_typedarray_contents.h)

		// Input strided array arguments are every other argument beginning from the second argument...
		for ( i = 1; i < n; i += 2 ) {
			if ( info[ i ]->IsNumber() ) {
				scalarX = 1; // TODO
			} else if ( info[ i ]->IsObject() && !info[ i ]->IsNull() ) {
				j = ( i-1 ) / 2;

				// Assume a typed array:
				TypedArrayContents<uint8_t> TypedArray( info[ i ] );
				arrays[ j ] = *TypedArray;

				types[ j ] = STDLIB_NDARRAY_FLOAT64; // TODO: determine data type
				strides[ j ] *= 8; // TODO: compute based on data type (or glean directly from the typed array instance)
			} else {
				ThrowTypeError( "invalid input argument. Input strided array argument must be a typed array or scalar." );
				return;
			}
		}

		// Output strided array arguments are every other argument beginning from the argument following the last input strided array stride argument...
		for ( i = n; i < nargs; i++ ) {
			if ( info[ i ]->IsObject() && !info[ i ]->IsNull() ) {
				j = ( i-1 ) / 2;

				// Assume a typed array:
				TypedArrayContents<uint8_t> TypedArray( info[ i ] );
				arrays[ j ] = *TypedArray;

				types[ j ] = STDLIB_NDARRAY_FLOAT64; // TODO: determine data type
				strides[ j ] *= 8; // TODO: compute based on data type (or glean directly from typed array instance)
			} else {
				ThrowTypeError( "invalid input argument. Output strided array argument must be a typed array." );
				return;
			}
		}

#endif

		// Broadcasting...
		if ( scalarX == 1 ) {
			if ( scalarY == 1 ) {
				ThrowError( "invalid input arguments. At least one of the second and fourth arguments must be a typed array." );
				return;
			}
			// Create an array having the closest "compatible" type...
			arrays[ 0 ] = broadcast( static_cast<double>( info[ 1 ]->NumberValue() ), types[ 0 ] );
		}
		if ( scalarY == 1 ) {
			// Create an array having the closest "compatible" type...
			arrays[ 1 ] = broadcast( static_cast<double>( info[ 3 ]->NumberValue() ), types[ 1 ] );
		}

		// Perform addition:
		stdlib_strided_dd_d( arrays, shape, strides, (void *)add );
	}

	NAN_MODULE_INIT( Init ) {
		Nan::Export( target, "add", node_add );
	}

	NODE_MODULE( addon, Init )
} // end namespace addon_strided_add
