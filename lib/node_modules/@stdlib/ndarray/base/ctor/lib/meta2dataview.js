/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var IS_LITTLE_ENDIAN = require( '@stdlib/assert/is-little-endian' );
var ArrayBuffer = require( '@stdlib/array/buffer' );
var DataView = require( '@stdlib/array/dataview' );
var BigInt = require( '@stdlib/bigint/ctor' );
var dtypes = require( '@stdlib/ndarray/dtypes' ).enum;
var orders = require( '@stdlib/ndarray/orders' ).enum;
var modes = require( '@stdlib/ndarray/index-modes' ).enum;


// VARIABLES //

var DTYPES = dtypes();
var ORDERS = orders();
var MODES = modes();


// FUNCTIONS //

/**
* Serializes ndarray meta data to a `DataView`.
*
* ## Notes
*
* -   This function takes into account subclasses which may support index modes.
*
* -   This function defaults to returning cached serialized meta data. To force serialization, set the private `__meta_dataview__` property to `null`.
*
* -   Meta data format:
*
*     ```text
*     ArrayBuffer[
*         <dtype>[int16],
*         <ndims>[int64],
*         <shape>[ndims*int64],
*         <strides>[ndims*int64],
*         <offset>[int64],
*         <order>[int8],
*         <mode>[int8],
*         <nsubmodes>[int64],
*         <submodes>[nsubmodes*int8]
*     ]
*     ```
*
*     where `strides` and `offset` are in units of bytes.
*
* -   Buffer length:
*
*     ```text
*     2 + 8 + (ndims*8) + (ndims*8) + 8 + 1 + 1 + 8 + (nsubmodes*1) = 28 + (ndims*16) + nsubmodes
*     ```
*
*     For example, consider a three-dimensional ndarray with one subscript index mode (submode):
*
*     ```text
*     28 + (3*16) + 1 = 77 bytes
*     ```
*
* -   Views:
*
*     -   dtype: `Int16Array( buf, 0, 1 )`
*     -   ndims: `Int64Array( buf, 2, 1 )`
*     -   shape: `Int64Array( buf, 10, ndims )`
*     -   strides: `Int64Array( buf, 10+(ndims*8), ndims )`
*     -   offset: `Int64Array( buf, 10+(ndims*16), 1 )`
*     -   order: `Int8Array( buf, 18+(ndims*16), 1 )`
*     -   mode: `Int8Array( buf, 19+(ndims*16), 1 )`
*     -   nsubmodes: `Int64Array( buf, 20+(ndims*16), 1 )`
*     -   submodes: `Int8Array( buf, 28+(ndims*16), nsubmodes )`
*
* @private
* @returns {DataView} serialized meta data
*/
function meta2dataview() {
	/* eslint-disable no-invalid-this */
	var nbytes;
	var len;
	var dt;
	var sh;
	var st;
	var sm;
	var v;
	var m;
	var o;
	var s;
	var N;
	var M;
	var i;

	// TODO: add backward compatibility support for environments which do not support BigInt. To do so, we'd need to take an integer-valued float64 and reduce it into 8 bytes in host byte order (endianness) for an int64. As max integer value should be 2^53, the most significant byte should be all zeros, except for possibly the signbit.

	m = this._mode || 'throw';
	sm = this._submode || [ m ];
	N = this._ndims;
	M = sm.length;

	len = 28 + (N*16) + M;

	// Check if we've already serialized ndarray meta data and can reuse an already allocated array buffer...
	v = this.__meta_dataview__;
	if ( v && v.byteLength === len ) {
		return v;
	}
	v = new DataView( new ArrayBuffer( len ) );

	sh = this._shape;
	st = this._strides;
	dt = this._dtype;
	nbytes = this._bytesPerElement;

	// Data type: (byteoffset: 0; bytelength: 2)
	o = 0;
	v.setInt16( o, DTYPES[ dt ], IS_LITTLE_ENDIAN );

	// Number of dimensions: (byteoffset: 2; bytelength: 8)
	o += 2;
	v.setBigInt64( o, BigInt( N ), IS_LITTLE_ENDIAN );

	// Shape and strides: (byteoffset: 10 and 10+(ndims*8), respectively; bytelength: ndims*8)
	s = N * 8;
	o += 8;
	for ( i = 0; i < N; i++ ) {
		o += i * 8;
		v.setBigInt64( o, BigInt( sh[ i ] ), IS_LITTLE_ENDIAN );
		v.setBigInt64( o+s, BigInt( st[ i ]*nbytes ), IS_LITTLE_ENDIAN );
	}
	// Offset:
	o += s + 8;
	v.setBigInt64( o, BigInt( this._offset*nbytes ), IS_LITTLE_ENDIAN );

	// Order:
	o += 8;
	v.setInt8( o, ORDERS[ this._order ] );

	// Mode:
	o += 1;
	v.setInt8( o, MODES[ m ] );

	// Number of submodes:
	o += 1;
	v.setBigInt64( o, BigInt( M ), IS_LITTLE_ENDIAN );

	// Submodes:
	o += 8;
	for ( i = 0; i < M; i++ ) {
		o += i;
		v.setInt8( o, MODES[ sm[i] ] );
	}
	// Cache the serialized meta data:
	this.__meta_dataview__ = v;

	return v;

	/* eslint-enable no-invalid-this */
}


// EXPORTS //

module.exports = meta2dataview;
