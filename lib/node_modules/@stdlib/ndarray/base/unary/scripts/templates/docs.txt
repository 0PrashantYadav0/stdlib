#### stdlib_ndarray_{{SIGNATURE}}( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to an input ndarray and assigns results to elements in an output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_2D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_2D}} };

// Define the number of dimensions:
int64_t ndims = 2;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_2D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_2D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_2D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_0d( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a zero-dimensional input ndarray and assigns results to elements in a zero-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_0D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_0D}} };

// Define the number of dimensions:
int64_t ndims = 0;

// Define the array shapes:
int64_t shape[] = {};

// Define the strides:
int64_t sx[] = { 0 };
int64_t sy[] = { 0 };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_0d( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_0d( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_1d( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a one-dimensional input ndarray and assigns results to elements in a one-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_1D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_1D}} };

// Define the number of dimensions:
int64_t ndims = 1;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_1D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_BYTES_PER_ELEMENT}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_BYTES_PER_ELEMENT}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_1d( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_1d( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_2d( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a two-dimensional input ndarray and assigns results to elements in a two-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_2D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_2D}} };

// Define the number of dimensions:
int64_t ndims = 2;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_2D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_2D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_2D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_2d( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_2d( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_2d_blocked( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a two-dimensional input ndarray and assigns results to elements in a two-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_2D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_2D}} };

// Define the number of dimensions:
int64_t ndims = 2;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_2D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_2D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_2D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_2d_blocked( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_2d_blocked( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_3d( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a three-dimensional input ndarray and assigns results to elements in a three-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_3D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_3D}} };

// Define the number of dimensions:
int64_t ndims = 3;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_3D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_3D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_3D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_3d( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_3d( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_3d_blocked( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a three-dimensional input ndarray and assigns results to elements in a three-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_3D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_3D}} };

// Define the number of dimensions:
int64_t ndims = 3;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_3D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_3D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_3D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_3d_blocked( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_3d_blocked( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_4d( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a four-dimensional input ndarray and assigns results to elements in a four-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_4D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_4D}} };

// Define the number of dimensions:
int64_t ndims = 4;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_4D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_4D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_4D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_4d( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_4d( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_4d_blocked( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a four-dimensional input ndarray and assigns results to elements in a four-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_4D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_4D}} };

// Define the number of dimensions:
int64_t ndims = 4;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_4D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_4D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_4D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_4d_blocked( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_4d_blocked( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_5d( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a five-dimensional input ndarray and assigns results to elements in a five-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_5D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_5D}} };

// Define the number of dimensions:
int64_t ndims = 5;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_5D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_5D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_5D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_5d( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_5d( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_5d_blocked( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a five-dimensional input ndarray and assigns results to elements in a five-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_5D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_5D}} };

// Define the number of dimensions:
int64_t ndims = 5;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_5D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_5D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_5D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_5d_blocked( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_5d_blocked( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_6d( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a six-dimensional input ndarray and assigns results to elements in a six-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_6D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_6D}} };

// Define the number of dimensions:
int64_t ndims = 6;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_6D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_6D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_6D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_6d( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_6d( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_6d_blocked( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a six-dimensional input ndarray and assigns results to elements in a six-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_6D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_6D}} };

// Define the number of dimensions:
int64_t ndims = 6;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_6D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_6D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_6D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_6d_blocked( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_6d_blocked( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_7d( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a seven-dimensional input ndarray and assigns results to elements in a seven-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_7D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_7D}} };

// Define the number of dimensions:
int64_t ndims = 7;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_7D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_7D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_7D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_7d( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_7d( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_7d_blocked( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a seven-dimensional input ndarray and assigns results to elements in a seven-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_7D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_7D}} };

// Define the number of dimensions:
int64_t ndims = 7;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_7D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_7D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_7D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_7d_blocked( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_7d_blocked( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_8d( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to an eight-dimensional input ndarray and assigns results to elements in an eight-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_8D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_8D}} };

// Define the number of dimensions:
int64_t ndims = 8;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_8D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_8D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_8D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_8d( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_8d( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_8d_blocked( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to an eight-dimensional input ndarray and assigns results to elements in an eight-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_8D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_8D}} };

// Define the number of dimensions:
int64_t ndims = 8;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_8D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_8D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_8D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_8d_blocked( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_8d_blocked( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_9d( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a nine-dimensional input ndarray and assigns results to elements in a nine-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_9D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_9D}} };

// Define the number of dimensions:
int64_t ndims = 9;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_9D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_9D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_9D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_9d( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_9d( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_9d_blocked( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a nine-dimensional input ndarray and assigns results to elements in a nine-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_9D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_9D}} };

// Define the number of dimensions:
int64_t ndims = 9;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_9D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_9D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_9D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_9d_blocked( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_9d_blocked( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_10d( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a ten-dimensional input ndarray and assigns results to elements in a ten-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_10D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_10D}} };

// Define the number of dimensions:
int64_t ndims = 10;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_10D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_10D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_10D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_10d( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_10d( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_10d_blocked( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to a ten-dimensional input ndarray and assigns results to elements in a ten-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_10D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_10D}} };

// Define the number of dimensions:
int64_t ndims = 10;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_10D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_10D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_10D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_10d_blocked( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_10d_blocked( struct ndarray *arrays[], void *fcn );
```

#### stdlib_ndarray_{{SIGNATURE}}_nd( \*arrays[], \*shape, \*strides, \*fcn )

Applies a unary callback to an n-dimensional input ndarray and assigns results to elements in an n-dimensional output ndarray.

```c
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"{{EXAMPLE_INCLUDES}}
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

// Define the ndarray data types:
enum STDLIB_NDARRAY_DTYPE xdtype = STDLIB_NDARRAY_{{INPUT_NDARRAY_1_DTYPE_UPPER}};
enum STDLIB_NDARRAY_DTYPE ydtype = STDLIB_NDARRAY_{{OUTPUT_NDARRAY_DTYPE_UPPER}};

// Create underlying byte arrays:
uint8_t xbuf[] = { {{INPUT_NDARRAY_1_BYTES_3D}} };
uint8_t ybuf[] = { {{OUTPUT_NDARRAY_BYTES_3D}} };

// Define the number of dimensions:
int64_t ndims = 3;

// Define the array shapes:
int64_t shape[] = { {{NDARRAY_SHAPE_3D}} };

// Define the strides:
int64_t sx[] = { {{INPUT_NDARRAY_1_STRIDES_3D}} };
int64_t sy[] = { {{OUTPUT_NDARRAY_STRIDES_3D}} };

// Define the offsets:
int64_t ox = 0;
int64_t oy = 0;

// Define the array order:
enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;

// Specify the index mode:
enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

// Specify the subscript index modes:
int8_t submodes[] = { imode };
int64_t nsubmodes = 1;

// Create an input ndarray:
struct ndarray *x = stdlib_ndarray_allocate( xdtype, xbuf, ndims, shape, sx, ox, order, imode, nsubmodes, submodes );
if ( x == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an output ndarray:
struct ndarray *y = stdlib_ndarray_allocate( ydtype, ybuf, ndims, shape, sy, oy, order, imode, nsubmodes, submodes );
if ( y == NULL ) {
    fprintf( stderr, "Error allocating memory.\n" );
    exit( EXIT_FAILURE );
}

// Create an array containing the ndarrays:
struct ndarray *arrays[] = { x, y };

// Define a callback:
{{CALLBACK_RETURN_DTYPE}} fcn( const {{CALLBACK_PARAM_1_DTYPE}} x ) {
    {{CALLBACK_BODY}}
}

// Apply the callback:
int8_t status = stdlib_ndarray_{{SIGNATURE}}_nd( arrays, (void *)fcn );
if ( status != 0 ) {
    fprintf( stderr, "Error during computation.\n" );
    exit( EXIT_FAILURE );
}

// ...

// Free allocated memory:
stdlib_ndarray_free( x );
stdlib_ndarray_free( y );
```

The function accepts the following arguments:

-   **arrays**: `[inout] struct ndarray**` array whose first element is a pointer to an input ndarray and whose second element is a pointer to an output ndarray.
-   **fcn**: `[in] void*` a `{{CALLBACK_RETURN_DTYPE}} (*f)({{CALLBACK_PARAM_1_DTYPE}})` function to apply provided as a `void` pointer.

```c
int8_t stdlib_ndarray_{{SIGNATURE}}_nd( struct ndarray *arrays[], void *fcn );
```
