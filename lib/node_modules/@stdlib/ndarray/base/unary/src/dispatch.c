/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#include "stdlib/ndarray/base/unary/dispatch_object.h"
#include "stdlib/ndarray/base/unary/typedefs.h"
#include "stdlib/ndarray/base/unary/internal/is_same_shape.h"
#include "stdlib/ndarray/base/iteration_order.h"
#include "stdlib/ndarray/base/singleton_dimensions.h"
#include "stdlib/ndarray/ctor.h"
#include <stdint.h>
#include <stddef.h>

/**
* Applies a unary callback to an n-dimensional input ndarray having `ndims-1` singleton dimensions and assigns results to elements in an output ndarray having the same shape.
*
* ## Notes
*
* -   If able to successfully apply a unary callback, the function returns `0`; otherwise, the function returns an error code.
*
* @private
* @param f     unary ndarray function
* @param x1    input ndarray
* @param x2    output ndarray
* @param fcn   callback
* @return      status code
*/
static int8_t stdlib_ndarray_unary_1d_squeeze( const ndarrayUnaryFcn f, struct ndarray *x1, struct ndarray *x2, void *fcn ) {
	int64_t *shape = stdlib_ndarray_shape( x1 );
	int64_t ndims = stdlib_ndarray_ndims( x1 );

	// Get the index of the non-singleton dimension...
	int64_t i;
	for ( i = 0; i < ndims; i++ ) {
		if ( shape[ i ] != 1 ) {
			break;
		}
	}
	int64_t sh[] = { shape[ i ] };
	int64_t sx1[] = { stdlib_ndarray_strides( x1 )[ i ] };

	// Shallow copy and reshape the arrays...
	struct ndarray *x1c = stdlib_ndarray_allocate(
		stdlib_ndarray_dtype( x1 ),
		stdlib_ndarray_data( x1 ),
		ndims,
		sh,
		sx1,
		stdlib_ndarray_offset( x1 ),
		stdlib_ndarray_order( x1 ),
		stdlib_ndarray_index_mode( x1 ),
		stdlib_ndarray_nsubmodes( x1 ),
		stdlib_ndarray_submodes( x1 )
	);
	if ( x1c == NULL ) {
		return -1;
	}
	int64_t sx2[] = { stdlib_ndarray_strides( x2 )[ i ] };
	struct ndarray *x2c = stdlib_ndarray_allocate(
		stdlib_ndarray_dtype( x2 ),
		stdlib_ndarray_data( x2 ),
		ndims,
		sh,
		sx2,
		stdlib_ndarray_offset( x2 ),
		stdlib_ndarray_order( x2 ),
		stdlib_ndarray_index_mode( x2 ),
		stdlib_ndarray_nsubmodes( x2 ),
		stdlib_ndarray_submodes( x2 )
	);
	if ( x2c == NULL ) {
		stdlib_ndarray_free( x1c );
		return -1;
	}
	// Apply the callback:
	int8_t status = f( x1c, x2c, fcn );

	// Free allocated memory:
	stdlib_ndarray_free( x1c );
	stdlib_ndarray_free( x2c );

	return status;
}

/**
* Dispatches to a unary ndarray function according to the dimensionality of provided ndarray arguments.
*
* ## Notes
*
* -   If able to successfully dispatch, the function returns `0`; otherwise, the function returns an error code.
*
* @param obj    object comprised of dispatch tables containing unary ndarray functions
* @param x1     input ndarray
* @param y2     output ndarray
* @param fcn    callback
* @return       status code
*
* @example
* #include "stdlib/ndarray/base/unary/dispatch.h"
* #include "stdlib/ndarray/base/unary/dispatch_object.h"
* #include "stdlib/ndarray/base/unary/typedefs.h"
* #include "stdlib/ndarray/base/unary/b_b.h"
* #include "stdlib/ndarray/ctor.h"
* #include <stdint.h>
* #include <stdlib.h>
* #include <stdio.h>
*
* // Define a list of unary ndarray functions:
* ndarrayUnaryFcn functions[] = {
*     stdlib_ndarray_b_b_0d,
*     stdlib_ndarray_b_b_1d,
*     stdlib_ndarray_b_b_2d,
*     stdlib_ndarray_b_b_3d,
*     stdlib_ndarray_b_b_4d,
*     stdlib_ndarray_b_b_5d,
*     stdlib_ndarray_b_b_6d,
*     stdlib_ndarray_b_b_7d,
*     stdlib_ndarray_b_b_8d,
*     stdlib_ndarray_b_b_9d,
*     stdlib_ndarray_b_b_10d
*     stdlib_ndarray_b_b_nd
* };
*
* // Define a list of unary ndarray functions using loop blocking...
* ndarrayUnaryFcn blocked_functions[] = {
*     stdlib_ndarray_b_b_2d_blocked,
*     stdlib_ndarray_b_b_3d_blocked,
*     stdlib_ndarray_b_b_4d_blocked,
*     stdlib_ndarray_b_b_5d_blocked,
*     stdlib_ndarray_b_b_6d_blocked,
*     stdlib_ndarray_b_b_7d_blocked,
*     stdlib_ndarray_b_b_8d_blocked,
*     stdlib_ndarray_b_b_9d_blocked,
*     stdlib_ndarray_b_b_10d_blocked
* };
*
* // Create a unary function dispatch object:
* struct ndarrayUnaryDispatchObject obj = {
*     // Array containing unary ndarray functions:
*     unary,
*
*     // Number of unary ndarray functions:
*     11,
*
*     // Array containing unary ndarray functions using loop blocking:
*     blocked_unary,
*
*     // Number of unary ndarray functions using loop blocking:
*     8
* }
*
* // ...
*
* // Create ndarrays...
* struct ndarray *x = stdlib_ndarray_allocate( ... );
* if ( x == NULL ) {
*     fprintf( stderr, "Error allocating memory.\n" );
*     exit( EXIT_FAILURE );
* }
*
* struct ndarray *y = stdlib_ndarray_allocate( ... );
* if ( y == NULL ) {
*     fprintf( stderr, "Error allocating memory.\n" );
*     exit( EXIT_FAILURE );
* }
*
* // ...
*
* // Define a callback:
* uint8_t scale( const uint8_t x ) {
*     return x + 10;
* }
*
* // Apply the callback:
* int8_t status = stdlib_ndarray_b_b( x, y, (void *)scale );
* if ( status != 0 ) {
*     fprintf( stderr, "Error during computation.\n" );
*     exit( EXIT_FAILURE );
* }
*/
int8_t stdlib_ndarray_unary_dispatch( const struct ndarrayUnaryDispatchObject *obj, struct ndarray *x1, struct ndarray *x2, void *fcn ) {
	// Verify that the input and output arrays have the same dimensions...
	if ( stdlib_ndarray_base_unary_internal_is_same_shape( x1, x2 ) == 0 ) {
		return -1; // TODO: consider standardized error codes
	}
	int64_t ndims = stdlib_ndarray_ndims( x1 );

	// Determine whether we can avoid nested loops and either avoid iteration altogether or just use strided array iteration...
	if ( ndims < 2 ) {
		obj->functions[ ndims ]( x1, x2, fcn );
		return 0;
	}
	// Determine whether the ndarrays have only **one** non-singleton dimension (e.g., ndims=4, shape=[10,1,1,1]) so that we can treat the ndarrays as being equivalent to one-dimensional strided arrays...
	if ( stdlib_ndarray_singleton_dimensions( ndims, stdlib_ndarray_shape( x1 ) ) == ndims-1 ) {
		int8_t status = stdlib_ndarray_unary_1d_squeeze( obj->functions[ 1 ], x1, x2, fcn );
		if ( status == 0 ) {
			return 0;
		}
	}
	// TODO: check if can ignore shape and strides and treat as linear arrays

	// Determine whether we can avoid blocked iteration...
	if ( stdlib_ndarray_order( x1 ) == stdlib_ndarray_order( x2 ) ) {
		int8_t io1 = stdlib_ndarray_iteration_order( ndims, stdlib_ndarray_strides( x1 ) );
		int8_t io2 = stdlib_ndarray_iteration_order( ndims, stdlib_ndarray_strides( x2 ) );

		// So long as iteration for each respective array always moves in the same direction (i.e., no mixed sign strides), we can leverage cache-optimal (i.e., normal) nested loops without resorting to blocked iteration...
		if ( io1 != 0 && io2 != 0 && ndims < obj->nfunctions ) {
			obj->functions[ ndims ]( x1, x2, fcn );
			return 0;
		}
		// Fall-through to blocked iteration...
	}
	// Determine whether we can perform blocked iteration...
	if ( ndims <= obj->nblockedfunctions ) {
		obj->blocked_functions[ ndims-2 ]( x1, x2, fcn );
		return 0;
	}
	// Fall-through to linear view iteration without regard for how data is stored in memory (i.e., take the slow path)...
	obj->functions[ obj->nfunctions-1 ]( x1, x2, fcn );

	return 0;
}
