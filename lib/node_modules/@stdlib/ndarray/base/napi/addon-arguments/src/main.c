/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#include "stdlib/ndarray/base/napi/addon_arguments.h"
#include "stdlib/ndarray/base/bytes_per_element.h"
#include "stdlib/ndarray/ctor.h"
#include "stdlib/math/base/assert/is_finite.h"
#include "stdlib/math/base/special/floor.h"
#include <node_api.h>
#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
* Validates, extracts, and transforms (to native C types) an ndarray data type.
*
* @private
* @param env      environment under which the function is invoked
* @param value    N-API value
* @param dtype    pointer for storing an ndarray data type
* @param err      pointer for storing a JavaScript error
* @return         status code indicating success or failure (returns `napi_ok` if success)
*/
static napi_status stdlib_ndarray_napi_get_dtype( const napi_env env, const napi_value value, enum STDLIB_NDARRAY_DTYPE *dtype, napi_value *err ) {
	// Check for a "dtype" property:
	bool res;
	napi_status status = napi_has_named_property( env, value, "dtype", &res );
	assert( status == napi_ok );
	if ( res == false ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "invalid argument. Provided argument must be an ndarray-like object having a `dtype` property.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_type_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Retrieve the "dtype" property value:
	napi_value v;
	status = napi_get_named_property( env, value, "dtype", &v );
	assert( status == napi_ok );

	// Check that the property value is a number:
	napi_valuetype vtype;
	status = napi_typeof( env, v, &vtype );
	assert( status == napi_ok );
	if ( vtype != napi_number ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "invalid argument. Provided argument must be an ndarray-like object having a `dtype` property whose value is an integer enumeration constant.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_type_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Get the dtype enumeration constant as a native C type:
	double dt;
	status = napi_get_value_double( env, v, &dt );
	assert( status == napi_ok );

	// Check that the value is integer-valued:
	if ( !stdlib_base_is_finite( dt ) || stdlib_base_floor( dt ) != dt ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "invalid argument. Provided argument must be an ndarray-like object having a `dtype` property whose value is an integer enumeration constant.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_type_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Cast the dtype value to a recognized ndarray dtype:
	*dtype = (enum STDLIB_NDARRAY_DTYPE)dt;

	return napi_ok;
}

/**
* Validates, extracts, and transforms (to native C types) an ndarray data buffer.
*
* @private
* @param env      environment under which the function is invoked
* @param value    N-API value
* @param data     pointer for storing a pointer to an ndarray data buffer
* @param err      pointer for storing a JavaScript error
* @return         status code indicating success or failure (returns `napi_ok` if success)
*/
static napi_status stdlib_ndarray_napi_get_data( const napi_env env, const napi_value value, uint8_t *data[], napi_value *err ) {
	// Check for a "data" property:
	bool res;
	napi_status status = napi_has_named_property( env, value, "data", &res );
	assert( status == napi_ok );
	if ( res == false ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "invalid argument. Provided argument must be an ndarray-like object having a `data` property.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_type_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Retrieve the "data" property value:
	napi_value v;
	status = napi_get_named_property( env, value, "data", &v );
	assert( status == napi_ok );

	// Check that the property value is a typed array:
	status = napi_is_typedarray( env, v, &res );
	assert( status == napi_ok );
	if ( res == false ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "invalid argument. Provided argument must be an ndarray-like object having a `data` property whose value is a typed array.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_type_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Get the typed array data:
	void *TypedArray;
	status = napi_get_typedarray_info( env, v, NULL, NULL, &TypedArray, NULL, NULL );
	assert( status == napi_ok );

	// Cast the typed array data to a byte array:
	*data = (uint8_t *)TypedArray;

	return napi_ok;
}

/**
* Validates, extracts, and transforms (to native C types) an ndarray shape and number of dimensions.
*
* @private
* @param env      environment under which the function is invoked
* @param value    N-API value
* @param ndims    pointer for storing the number of dimensions
* @param shape    pointer for storing a pointer to an ndarray shape array
* @param err      pointer for storing a JavaScript error
* @return         status code indicating success or failure (returns `napi_ok` if success)
*/
static napi_status stdlib_ndarray_napi_get_shape( const napi_env env, const napi_value value, int64_t *ndims, int64_t *shape[], napi_value *err ) {
	// Check for a "shape" property:
	bool res;
	napi_status status = napi_has_named_property( env, value, "shape", &res );
	assert( status == napi_ok );
	if ( res == false ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "invalid argument. Provided argument must be an ndarray-like object having a `shape` property.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_type_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Retrieve the "shape" property value:
	napi_value v;
	status = napi_get_named_property( env, value, "shape", &v );
	assert( status == napi_ok );

	// Check that the property value is a typed array:
	status = napi_is_typedarray( env, v, &res );
	assert( status == napi_ok );
	if ( res == false ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "invalid argument. Provided argument must be an ndarray-like object having a `shape` property whose value is a Float64Array.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_type_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Get the typed array data:
	napi_typedarray_type vtype;
	void *TypedArray;
	size_t len;
	status = napi_get_typedarray_info( env, v, &vtype, &len, &TypedArray, NULL, NULL );
	assert( status == napi_ok );

	// Check that the typed array is a Float64Array:
	if ( vtype != napi_float64_array ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "invalid argument. Provided argument must be an ndarray-like object having a `shape` property whose value is a Float64Array.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_type_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Allocate memory for storing dimensions:
	int64_t *sh = (int64_t *)malloc( len*sizeof(int64_t) );
	if ( sh == NULL ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "runtime exception. Unable to allocate memory when processing an ndarray shape.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_MEMORY_ALLOCATION_FAILED", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Cast the typed array to a native C array:
	double *dims = (double *)TypedArray;

	// Validate dimensions...
	for ( size_t i = 0; i < len; i++ ) {
		double d = dims[ i ];

		// Ensure that each dimension is integer-valued and nonnegative...
		if ( !stdlib_base_is_finite( d ) || stdlib_base_floor( d ) != d || d < 0 ) {
			napi_value msg;
			status = napi_create_string_utf8( env, "invalid argument. Each dimension in an ndarray shape must be a nonnegative integer.", NAPI_AUTO_LENGTH, &msg );
			assert( status == napi_ok );

			napi_value code;
			status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
			assert( status == napi_ok );

			napi_value error;
			status = napi_create_type_error( env, code, msg, &error );
			assert( status == napi_ok );

			*err = error;
			return napi_ok;
		}
		// Store the dimension:
		sh[ i ] = (int64_t)d;
	}
	// Store the number of dimensions:
	*ndims = (int64_t)len;

	// Store the shape array:
	*shape = sh;

	return napi_ok;
}

/**
* Validates, extracts, and transforms (to native C types) ndarray strides.
*
* @private
* @param env      environment under which the function is invoked
* @param value    N-API value
* @param ndims    number of dimensions
* @param strides  pointer for storing a pointer to an ndarray strides array
* @param err      pointer for storing a JavaScript error
* @return         status code indicating success or failure (returns `napi_ok` if success)
*/
static napi_status stdlib_ndarray_napi_get_strides( const napi_env env, const napi_value value, int64_t ndims, int64_t *strides[], napi_value *err ) {
	// Check for a "strides" property:
	bool res;
	napi_status status = napi_has_named_property( env, value, "strides", &res );
	assert( status == napi_ok );
	if ( res == false ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "invalid argument. Provided argument must be an ndarray-like object having a `strides` property.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_type_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Retrieve the "strides" property value:
	napi_value v;
	status = napi_get_named_property( env, value, "strides", &v );
	assert( status == napi_ok );

	// Check that the property value is a typed array:
	status = napi_is_typedarray( env, v, &res );
	assert( status == napi_ok );
	if ( res == false ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "invalid argument. Provided argument must be an ndarray-like object having a `strides` property whose value is a Float64Array.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_type_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Get the typed array data:
	napi_typedarray_type vtype;
	void *TypedArray;
	size_t len;
	status = napi_get_typedarray_info( env, v, &vtype, &len, &TypedArray, NULL, NULL );
	assert( status == napi_ok );

	// Check that the typed array is a Float64Array:
	if ( vtype != napi_float64_array ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "invalid argument. Provided argument must be an ndarray-like object having a `strides` property whose value is a Float64Array.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_type_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Validate the number of strides...
	if ( ndims > 0 ) {
		if ( (int64_t)len != ndims ) {
			napi_value msg;
			status = napi_create_string_utf8( env, "invalid argument. Number of strides must match the number of dimensions.", NAPI_AUTO_LENGTH, &msg );
			assert( status == napi_ok );

			napi_value code;
			status = napi_create_string_utf8( env, "ERR_MEMORY_ALLOCATION_FAILED", NAPI_AUTO_LENGTH, &code );
			assert( status == napi_ok );

			napi_value error;
			status = napi_create_range_error( env, code, msg, &error );
			assert( status == napi_ok );

			*err = error;
			return napi_ok;
		}
	} else if ( len != 1 ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "invalid argument. Zero-dimensional ndarrays must have only one stride.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_MEMORY_ALLOCATION_FAILED", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_range_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Allocate memory for storing strides:
	int64_t *st = (int64_t *)malloc( len*sizeof(int64_t) );
	if ( st == NULL ) {
		napi_value msg;
		status = napi_create_string_utf8( env, "runtime exception. Unable to allocate memory when processing an ndarray strides.", NAPI_AUTO_LENGTH, &msg );
		assert( status == napi_ok );

		napi_value code;
		status = napi_create_string_utf8( env, "ERR_MEMORY_ALLOCATION_FAILED", NAPI_AUTO_LENGTH, &code );
		assert( status == napi_ok );

		napi_value error;
		status = napi_create_error( env, code, msg, &error );
		assert( status == napi_ok );

		*err = error;
		return napi_ok;
	}
	// Cast the typed array to a native C array:
	double *dst = (double *)TypedArray;

	// Validate dimensions...
	for ( size_t i = 0; i < len; i++ ) {
		double s = dst[ i ];

		// Ensure that the each stride is integer-valued...
		if ( ndims == 0 && s != 0.0 ) {
			napi_value msg;
			status = napi_create_string_utf8( env, "invalid argument. Zero-dimensional ndarrays must have a single stride equal to zero.", NAPI_AUTO_LENGTH, &msg );
			assert( status == napi_ok );

			napi_value code;
			status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
			assert( status == napi_ok );

			napi_value error;
			status = napi_create_range_error( env, code, msg, &error );
			assert( status == napi_ok );

			*err = error;
			return napi_ok;
		}
		if ( !stdlib_base_is_finite( s ) || stdlib_base_floor( s ) != s ) {
			napi_value msg;
			status = napi_create_string_utf8( env, "invalid argument. Each stride in an ndarray strides array must be integer-valued.", NAPI_AUTO_LENGTH, &msg );
			assert( status == napi_ok );

			napi_value code;
			status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
			assert( status == napi_ok );

			napi_value error;
			status = napi_create_type_error( env, code, msg, &error );
			assert( status == napi_ok );

			*err = error;
			return napi_ok;
		}
		// Store the stride:
		st[ i ] = (int64_t)s;
	}
	// Store the strides array:
	*strides = st;

	return napi_ok;
}

/**
* Validates, extracts, and transforms (to native C types) function arguments provided to an ndarray N-API add-on interface.
*
* ## Notes
*
* -   The function assumes the following argument order:
*
*     ```text
*     [ ia1, ia2, ..., oa1, oa2, ... ]
*     ```
*
*     where
*
*     -   `ia#` is an input ndarray
*     -   `oa#` is an output ndarray
*
* -   The function may return one of the following JavaScript errors:
*
*     -   `TypeError`: input array argument must be an ndarray
*     -   `TypeError`: output array argument must be an ndarray
*
* @param env      environment under which the function is invoked
* @param argv     ndarray function arguments
* @param nargs    total number of expected arguments
* @param nin      number of input ndarray arguments
* @param arrays   destination array for storing pointers to both input and output ndarrays
* @param err      pointer for storing a JavaScript error
* @return         status code indicating success or failure (returns `napi_ok` if success)
*
* @example
* #include "stdlib/ndarray/base/napi/addon_arguments.h"
* #include "stdlib/ndarray/ctor.h"
* #include <node_api.h>
* #include <stdint.h>
* #include <assert.h>
*
* // Add-on function...
* napi_value addon( napi_env env, napi_callback_info info ) {
*     napi_status status;
*
*     // ...
*
*     int64_t nargs = 3;
*     int64_t nin = 2;
*
*     // Get callback arguments:
*     size_t argc = 3;
*     napi_value argv[ 3 ];
*     status = napi_get_cb_info( env, info, &argc, argv, nullptr, nullptr );
*     assert( status == napi_ok );
*
*     // ...
*
*     // Process the provided arguments:
*     struct ndarray *arrays[ 3 ];
*
*     napi_value err;
*     status = stdlib_ndarray_napi_addon_arguments( env, argv, nargs, nin, arrays, &err );
*     assert( status == napi_ok );
*
*     // ...
*
* }
*/
napi_status stdlib_ndarray_napi_addon_arguments( const napi_env env, const napi_value *argv, const int64_t nargs, const int64_t nin, struct ndarray *arrays[], napi_value *err ) {
	// enum STDLIB_NDARRAY_INDEX_MODE *submodes;
	// enum STDLIB_NDARRAY_INDEX_MODE imode;
	// enum STDLIB_NDARRAY_ORDER order;
	napi_status status;
	// int64_t nsubmodes;
	// int64_t offset;

	// Reset the output error:
	*err = NULL;

	// Process input and output ndarray arguments...
	for ( int64_t i = 0; i < nargs; i++ ) {
		napi_value arg = argv[ i ];

		// Check that we were provided an object:
		napi_valuetype vtype;
		status = napi_typeof( env, arg, &vtype );
		assert( status == napi_ok );
		if ( vtype != napi_object ) {
			napi_value msg;
			status = napi_create_string_utf8( env, "invalid argument. Provided argument must be an ndarray-like object.", NAPI_AUTO_LENGTH, &msg );
			assert( status == napi_ok );

			napi_value code;
			status = napi_create_string_utf8( env, "ERR_NDARRAY_INVALID_ARGUMENT", NAPI_AUTO_LENGTH, &code );
			assert( status == napi_ok );

			napi_value error;
			status = napi_create_type_error( env, code, msg, &error );
			assert( status == napi_ok );

			*err = error;
			return napi_ok;
		}
		// Retrieve the ndarray data type:
		enum STDLIB_NDARRAY_DTYPE dtype;
		status = stdlib_ndarray_napi_get_dtype( env, arg, &dtype, err );
		assert( status == napi_ok );
		if ( *err != NULL ) {
			return napi_ok;
		}
		// Retrieve the ndarray data buffer:
		uint8_t *data;
		status = stdlib_ndarray_napi_get_data( env, arg, &data, err );
		assert( status == napi_ok );
		if ( *err != NULL ) {
			return napi_ok;
		}
		// Retrieve the ndarray shape and number of dimensions:
		int64_t *shape;
		int64_t ndims;
		status = stdlib_ndarray_napi_get_shape( env, arg, &ndims, &shape, err );
		assert( status == napi_ok );
		if ( *err != NULL ) {
			return napi_ok;
		}
		// Retrieve the ndarray strides:
		int64_t *strides;
		status = stdlib_ndarray_napi_get_strides( env, arg, ndims, &strides, err );
		assert( status == napi_ok );
		if ( *err != NULL ) {
			return napi_ok;
		}
		// Retrieve the ndarray index offset (in bytes):
		// int64_t offset;
		// status = stdlib_ndarray_napi_get_offset( env, arg, &offset, err );
		// assert( status == napi_ok );
		// if ( *err != NULL ) {
		// 	return napi_ok;
		// }

		// TODO: allocate a new ndarray

		// Set output data...
		// arrays[ j ] = TODO;

		// FIXME
		free( shape );
		free( strides );
	}
	return napi_ok;
}


// TODO: things we need to free... (1) shapes, (2) strides, (3) ndarray structs, (4) submodes, (5) dtype
