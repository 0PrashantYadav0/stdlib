/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#include "stdlib/ndarray/base/napi/addon_arguments.h"
#include "stdlib/ndarray/ctor.h"
#include <node_api.h>
#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
* Validates, extracts, and transforms (to native C types) function arguments provided to an ndarray N-API add-on interface.
*
* ## Notes
*
* -   The function assumes the following argument order:
*
*     ```text
*     [ ia1, ia2, ..., oa1, oa2, ... ]
*     ```
*
*     where
*
*     -   `ia#` is an input ndarray
*     -   `oa#` is an output ndarray
*
* @param env      environment under which the function is invoked
* @param argv     ndarray function arguments
* @param nargs    total number of ndarrays
* @param nin      number of input ndarrays
* @param arrays   destination array for storing pointers to both input and output ndarrays
* @param err      pointer for storing a JavaScript error
* @return         status code indicating success or failure (returns `napi_ok` if success)
*
* @example
* #include "stdlib/ndarray/base/napi/addon_arguments.h"
* #include "stdlib/ndarray/ctor.h"
* #include <node_api.h>
* #include <stdint.h>
* #include <assert.h>
*
* // Add-on function...
* napi_value addon( napi_env env, napi_callback_info info ) {
*     napi_status status;
*
*     // ...
*
*     int64_t nargs = 6;
*     int64_t nin = 2;
*
*     // Get callback arguments:
*     size_t argc = 6;
*     napi_value argv[ 6 ];
*     status = napi_get_cb_info( env, info, &argc, argv, nullptr, nullptr );
*     assert( status == napi_ok );
*
*     // ...
*
*     // Process the provided arguments:
*     struct ndarray *arrays[ 3 ];
*
*     napi_value err;
*     status = stdlib_ndarray_napi_addon_arguments( env, argv, nargs, nin, arrays, &err );
*     assert( status == napi_ok );
*
*     // ...
*
* }
*/
napi_status stdlib_ndarray_napi_addon_arguments( const napi_env env, const napi_value *argv, const int64_t nargs, const int64_t nin, struct ndarray *arrays[], napi_value *err ) {
	napi_status status;

	// Reset the output error:
	*err = NULL;

	// For each ndarray, we expect 2 arguments: the data buffer and the array meta data...
	for ( int64_t i = 0; i < nargs; i += 2 ) {
		// Retrieve the ndarray data buffer:
		uint8_t *data;
		size_t dlen;
		status = napi_get_typedarray_info( env, argv[ i ], NULL, &dlen, (void *)&data, NULL, NULL );
		assert( status == napi_ok );

		// Retrieve the ndarray meta data:
		uint8_t *meta;
		size_t byteoffset;
		size_t mlen;
		status = napi_get_dataview_info( env, argv[ i+1 ], &mlen, (void *)&meta, NULL, &byteoffset );
		assert( status == napi_ok );

		// Retrieve ndarray properties...
		uint8_t *ptr = meta + byteoffset;
		int16_t dtype = *(int16_t *)ptr;
		ptr += 2;
		int64_t ndims = *(int64_t *)ptr;
		ptr += 8;
		int64_t *shape = (int64_t *)ptr;
		ptr += ndims * 8;
		int64_t *strides = (int64_t *)ptr;
		ptr += ndims * 8;
		int64_t offset = *(int64_t *)ptr;
		ptr += 8;
		int8_t order = *(int8_t *)ptr;
		ptr += 1;
		int8_t imode = *(int8_t *)ptr;
		ptr += 1;
		int64_t nsubmodes = *(int64_t *)ptr;
		ptr += 8;
		int8_t *submodes = (int8_t *)ptr;

		// TODO: we should probably sanity check that the provided data buffer (typed array) is compatible with the shape specified in the meta data...

		// TODO: allocate a new ndarray

		// Set output data...
		// arrays[ j ] = TODO;
	}
	return napi_ok;
}


// TODO: things we need to free... (3) ndarray structs, (4) submode

/*

What if we:

1.  Copy properties to a vanilla object
2.  For those properties with enums, copy the enumeration constant
3.  In C, allocate a fixed length array for up to, say, 10 dimensions for shape, strides, etc
4.  If more than 10 dimensions, dynamically allocate memory
5.  Copy over JS values to the respective arrays
6.  Allocate ndarrays
7.  Free any allocated memory (can check if we need to free shape, strides, etc, by checking the number of dimensions)

	-	this is a bit tricky, if we're handling array-like objects for shape and strides, as we need to know the exact type in C
		-	if not `Array`, then would need to copy
		-	somewhat of an argument for copying meta data to single ArrayBuffer

What if we:

1.  Copy meta data to a single arraybuffer
	-	meta data should be significantly less space, so copy should be comparatively cheap to copying the underlying data buffer
	-	but writing meta data may be somewhat expensive, if ArrayBuffer methods are expensive
	-	one issue is that, for enums, the enumeration constant size is compiler-dependent, so cannot assume that int32 maps to enum size
	-	we'd also need to address endianness

What if we:

1.  Provide ndarray properties as separate arguments
	-	this leads to a very verbose API which is a bit brittle, especially for more than 2 ndarray arguments, as adding a property which needs to be passed down then shifts the argument indices of everything by one
	-	not particularly user friendly

Questions:

1.  how would we pass an ndarray to WebAssembly?
	-	presumably, we'd want to store meta data in an ArrayBuffer somehow

*/
