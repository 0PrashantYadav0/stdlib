/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-underscore-dangle, no-undef */

'use strict';

// MODULES //

var IS_LITTLE_ENDIAN = require( '@stdlib/assert/is-little-endian' );
var ArrayBuffer = require( '@stdlib/array/buffer' );
var bytesPerElement = require( '@stdlib/ndarray/base/bytes-per-element' );
var dtypes = require( '@stdlib/ndarray/dtypes' ).enum;
var orders = require( '@stdlib/ndarray/orders' ).enum;
var modes = require( '@stdlib/ndarray/index-modes' ).enum;
var addon = require( './../src/addon.node' );


// VARIABLES //

var DTYPES = dtypes();
var ORDERS = orders();
var MODES = modes();


// FUNCTIONS //

/**
* Serializes ndarray meta data.
*
* ## Notes
*
* -   Meta data format:
*
*     ```text
*     ArrayBuffer[
*         <dtype>[int16],
*         <ndims>[int64],
*         <shape>[ndims*int64],
*         <strides>[ndims*int64],
*         <offset>[int64],
*         <order>[int8],
*         <mode>[int8],
*         <nsubmodes>[int64],
*         <submodes>[nsubmodes*int8]
*     ]
*     ```
*
*     where `strides` and `offset` are in units of bytes.
*
* -   Buffer length:
*
*     ```text
*     2 + 8 + (ndims*8) + (ndims*8) + 8 + 1 + 1 + 8 + (nsubmodes*1) = 28 + (ndims*16) + nsubmodes
*     ```
*
*     For example, consider a three-dimensional ndarray with one submode:
*
*     ```text
*     28 + (3*16) + 1 = 77 bytes
*     ```
*
* -   Views:
*
*     -   dtype: `Int16Array( buf, 0, 2 )`
*     -   ndims: `Int64Array( buf, 2, 1 )`
*     -   shape: `Int64Array( buf, 10, ndims )`
*     -   strides: `Int64Array( buf, 10+(ndims*8), ndims )`
*     -   offset: `Int64Array( buf, 10+(ndims*16), 1 )`
*     -   order: `Int8Array( buf, 18+(ndims*16), 1 )`
*     -   mode: `Int8Array( buf, 19+(ndims*16), 1 )`
*     -   nsubmodes: `Int64Array( buf, 20+(ndims*16), 1 )`
*     -   submodes: `Int8Array( buf, 28+(ndims*16), nsubmodes )`
*
* @private
* @param {ndarray} x - input array
* @returns {DataView} serialized meta data
*/
function serialize( x ) {
	var nbytes;
	var buf;
	var len;
	var dt;
	var sh;
	var st;
	var sm;
	var v;
	var m;
	var o;
	var s;
	var N;
	var M;
	var i;

	dt = x._dtype || x.dtype;
	sh = x._shape || x.shape;
	st = x._strides || x.strides;
	m = x._mode || 'throw';
	sm = x._submode || [ 'throw' ];
	M = sm.length;
	N = sh.length;

	nbytes = bytesPerElement( dt );

	len = 28 + (N*16) + M;
	buf = new ArrayBuffer( len );

	// eslint-disable-next-line stdlib/require-globals
	v = new DataView( buf ); // FIXME: use stdlib package

	// Data type: (byteoffset: 0; bytelength: 2)
	o = 0;
	v.setInt16( o, DTYPES[ dt ], IS_LITTLE_ENDIAN );

	// Number of dimensions: (byteoffset: 2; bytelength: 8)
	o += 2;
	v.setBigInt64( o, BigInt( N ), IS_LITTLE_ENDIAN );

	// Shape and strides: (byteoffset: 10 and 10+(ndims*8), respectively; bytelength: ndims*8)
	s = N * 8;
	o += 8;
	for ( i = 0; i < N; i++ ) {
		o += i * 8;
		v.setBigInt64( o, BigInt( sh[ i ] ), IS_LITTLE_ENDIAN );
		v.setBigInt64( o+s, BigInt( st[ i ]*nbytes ), IS_LITTLE_ENDIAN );
	}
	// Offset:
	o += 8;
	v.setBigInt64( o, BigInt( x.offset*nbytes ), IS_LITTLE_ENDIAN );

	// Order:
	o += 8;
	v.setInt8( o, ORDERS[ x._order || x.order ] );

	// Mode:
	o += 1;
	v.setInt8( o, MODES[ m ] );

	// Number of submodes:
	o += 1;
	v.setBigInt64( o, BigInt( M ), IS_LITTLE_ENDIAN );

	// Submodes:
	o += 8;
	for ( i = 0; i < M; i++ ) {
		o += i;
		v.setInt8( o, MODES[ sm[i] ] );
	}
	return v;
}


// MAIN //

/**
* Wrapper function exposing the C API to JavaScript.
*
* @private
* @param {ndarray} x - input array
* @param {ndarray} y - destination array
* @returns {ndarray} `y`
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
* var ndarray = require( '@stdlib/ndarray/ctor' );
*
* var xbuf = new Float64Array( 10 );
* var ybuf = new Float64Array( xbuf.length );
*
* var x = ndarray( 'float64', xbuf, [ 10 ], [ 1 ], 0, 'row-major' );
* var y = ndarray( 'float64', ybuf, [ 10 ], [ 1 ], 0, 'row-major' );
*
* wrapper( x, y );
*/
function wrapper( x, y ) {
	addon( x._buffer || x.data, serialize( x ), y._buffer || y.data, serialize( y ) ); // eslint-disable-line max-len
	return y;
}


// EXPORTS //

module.exports = wrapper;
