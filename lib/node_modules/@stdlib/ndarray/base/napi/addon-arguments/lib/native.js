/**
* @license Apache-2.0
*
* Copyright (c) 2021 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-underscore-dangle, function-paren-newline, function-call-argument-newline, no-undef */

'use strict';

// MODULES //

var Int8Array = require( '@stdlib/array/int8' );
var ArrayBuffer = require( '@stdlib/array/buffer' );
var dtypes = require( '@stdlib/ndarray/dtypes' ).enum;
var orders = require( '@stdlib/ndarray/orders' ).enum;
var modes = require( '@stdlib/ndarray/index-modes' ).enum;
var IS_LITTLE_ENDIAN = require( '@stdlib/assert/is-little-endian' );
var addon = require( './../src/addon.node' );


// VARIABLES //

var DTYPES = dtypes();
var ORDERS = orders();
var MODES = modes();
var THROW = MODES[ 'throw' ];


// FUNCTIONS //

/**
* Copies a list of integers to a `BigInt64Array`.
*
* @private
* @param {IntegerArray} arr - input array
* @returns {BigInt64Array} output array
*/
function arr2int64( arr ) {
	var out;
	var i;

	out = new BigInt64Array( arr.length );
	for ( i = 0; i < arr.length; i++ ) {
		out[ i ] = BigInt( arr[ i ] );
	}
	return out;
}

/**
* Converts a list of index modes to an equivalent list of corresponding enumeration constants.
*
* @private
* @param {StringArray} list - list of index modes
* @returns {IntegerArray} list of corresponding index mode enumeration constants
*/
function submodes( list ) {
	var out;
	var i;

	out = new Int8Array( list.length );
	for ( i = 0; i < list.length; i++ ) {
		out[ i ] = MODES[ list[i] ];
	}
	return out;
}

/**
* Serializes ndarray meta data.
*
* ## Notes
*
* -   Meta data format:
*
*     ```text
*     ArrayBuffer[
*         <dtype>[int16],
*         <ndims>[int64],
*         <shape>[ndims*int64],
*         <strides>[ndims*int64],
*         <offset>[int64],
*         <order>[int8],
*         <mode>[int8],
*         <nsubmodes>[int64],
*         <submodes>[nsubmodes*int8]
*     ]
*     ```
*
* -   Buffer length:
*
*     ```text
*     2 + 8 + (ndims*8) + (ndims*8) + 8 + 1 + 1 + 8 + (nsubmodes*1) = 28 + (ndims*16) + nsubmodes
*     ```
*
*     For example, consider a three-dimensional ndarray with one submode:
*
*     ```text
*     28 + (3*16) + 1 = 77 bytes
*     ```
*
* -   Views:
*
*     -   dtype: `Int16Array( buf, 0, 2 )`
*     -   ndims: `Int64Array( buf, 2, 1 )`
*     -   shape: `Int64Array( buf, 10, ndims )`
*     -   strides: `Int64Array( buf, 10+(ndims*8), ndims )`
*     -   offset: `Int64Array( buf, 10+(ndims*16), 1 )`
*     -   order: `Int8Array( buf, 18+(ndims*16), 1 )`
*     -   mode: `Int8Array( buf, 19+(ndims*16), 1 )`
*     -   nsubmodes: `Int64Array( buf, 20+(ndims*16), 1 )`
*     -   submodes: `Int8Array( buf, 28+(ndims*16), nsubmodes )`
*
* @private
* @param {ndarray} x - input array
* @returns {ArrayBuffer} serialized meta data
*/
function serialize( x ) {
	var buf;
	var len;
	var sh;
	var st;
	var sm;
	var v;
	var m;
	var o;
	var s;
	var N;
	var M;
	var i;

	sh = x._shape || x.shape;
	st = x._strides || x.strides;
	m = x._mode || 'throw';
	sm = x._submode || [ 'throw' ];
	M = sm.length;
	N = sh.length;

	len = 28 + (N*16) + M;
	buf = new ArrayBuffer( len );
	v = new DataView( buf ); // FIXME: use stdlib package

	// Data type: (byteoffset: 0; bytelength: 2)
	o = 0;
	v.setInt16( o, DTYPES[ x._dtype || x.dtype ], IS_LITTLE_ENDIAN );

	// Number of dimensions: (byteoffset: 2; bytelength: 8)
	o += 2;
	v.setBigInt64( o, BigInt( N ), IS_LITTLE_ENDIAN );

	// Shape and strides: (byteoffset: 10 and 10+(ndims*8), respectively; bytelength: ndims*8)
	s = N * 8;
	o += 8;
	for ( i = 0; i < N; i++ ) {
		o += i * 8;
		v.setBigInt64( o, BigInt( sh[ i ] ), IS_LITTLE_ENDIAN );
		v.setBigInt64( o+s, BigInt( st[ i ] ), IS_LITTLE_ENDIAN );
	}
	// Offset:
	o += 8;
	v.setBigInt64( o, BigInt( x.offset ), IS_LITTLE_ENDIAN );

	// Order:
	o += 8;
	v.setInt8( o, ORDERS[ x._order || x.order ] );

	// Mode:
	o += 1;
	v.setInt8( o, MODES[ m ] );

	// Number of submodes:
	o += 1;
	v.setBigInt64( o, BigInt( M ), IS_LITTLE_ENDIAN );

	// Submodes:
	o += 8;
	for ( i = 0; i < M; i++ ) {
		o += i;
		v.setInt8( o, MODES[ sm[i] ] );
	}
	return buf;
}


// MAIN //

/**
* Wrapper function exposing the C API to JavaScript.
*
* @private
* @param {ndarray} x - input array
* @param {ndarray} y - destination array
* @returns {ndarray} `y`
*
* @example
* var Float64Array = require( '@stdlib/array/float64' );
* var ndarray = require( '@stdlib/ndarray/ctor' );
*
* var xbuf = new Float64Array( 10 );
* var ybuf = new Float64Array( xbuf.length );
*
* var x = ndarray( 'float64', xbuf, [ 10 ], [ 1 ], 0, 'row-major' );
* var y = ndarray( 'float64', ybuf, [ 10 ], [ 1 ], 0, 'row-major' );
*
* wrapper( x, y );
*/
function wrapper( x, y ) {
	var xsh;
	var ysh;
	var xst;
	var yst;
	var xsm;
	var ysm;
	var xm;
	var ym;

	// "Official" ndarray instances can be configured to have different bounds-checking behavior; however, retrieving this configuration is only possible via private properties...
	xm = ( x._mode ) ? MODES[ x._mode ] : THROW;
	if ( x._submode ) {
		xsm = submodes( x._submode );
	} else {
		xsm = new Int8Array( 1 );
		xsm[ 0 ] = xm;
	}
	ym = ( y._mode ) ? MODES[ y._mode ] : THROW;
	if ( y._submode ) {
		ysm = submodes( y._submode );
	} else {
		ysm = new Int8Array( 1 );
		ysm[ 0 ] = ym;
	}
	xsh = arr2int64( x._shape || x.shape );
	if ( xsh[ 0 ] !== xsh[ 0 ] ) {
		// Why do we do this? Because V8 may defer creating a backing ArrayBuffer until first element access.
		throw new Error( 'something went wrong' );
	}
	ysh = arr2int64( y._shape || y.shape );
	if ( ysh[ 0 ] !== ysh[ 0 ] ) {
		// Why do we do this? Because V8 may defer creating a backing ArrayBuffer until first element access.
		throw new Error( 'something went wrong' );
	}
	xst = arr2int64( x._strides || x.strides );
	if ( xst[ 0 ] !== xst[ 0 ] ) {
		// Why do we do this? Because V8 may defer creating a backing ArrayBuffer until first element access.
		throw new Error( 'something went wrong' );
	}
	yst = arr2int64( y._strides || y.strides );
	if ( yst[ 0 ] !== yst[ 0 ] ) {
		// Why do we do this? Because V8 may defer creating a backing ArrayBuffer until first element access.
		throw new Error( 'something went wrong' );
	}
	addon(
		DTYPES[ x._dtype || x.dtype ],
		x._buffer || x.data,
		xsh,
		xst,
		x.offset,
		ORDERS[ x._order || x.order ],
		xm,
		xsm,

		DTYPES[ y._dtype || y.dtype ],
		y._buffer || y.data,
		xsh,
		xst,
		y.offset,
		ORDERS[ y._order || y.order ],
		ym,
		ysm
	);
	return y;
}


// EXPORTS //

module.exports = wrapper;
