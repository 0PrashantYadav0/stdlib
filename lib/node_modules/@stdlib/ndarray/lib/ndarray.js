'use strict';

// MODULES //

var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var isObject = require( '@stdlib/assert/is-plain-object' );
var shape2strides = require( '@stdlib/ndarray/base/shape2strides' );
var strides2offset = require( '@stdlib/ndarray/base/strides2offset' );
var strides2order = require( '@stdlib/ndarray/base/strides2order' );
var numel = require( '@stdlib/ndarray/base/numel' );
var ctor = require( '@stdlib/ndarray/memoized-ctor' );
var isDataType = require( '@stdlib/ndarray/base/assert/is-data-type' );
var isOrder = require( '@stdlib/ndarray/base/assert/is-order' );
var getType = require( '@stdlib/ndarray/base/buffer-dtype' );
var createBuffer = require( '@stdlib/ndarray/base/buffer' );
var isArrayLikeObject = require( './is_array_like_object.js' );
var defaults = require( './defaults.json' );
var castBuffer = require( './cast_buffer.js' );


// MAIN //

/**
* Returns a multidimensional array.
*
* @param {Options} options - function options
* @param {(ArrayLikeObject|TypedArrayLike|Buffer)} [options.buffer] - underlying data buffer
* @param {string} [options.dtype="float64"] - underlying storage data type (if the input data is not of the same type, this option specifies the data type to which to cast the input data)
* @param {string} [options.order="row-major"] - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
* @param {NonNegativeIntegerArray} [options.shape] - array shape
* @param {IntegerArray} [options.strides] - index strides which specify how to access data along corresponding array dimensions
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @param {string} [options.mode="throw"] - specifies how to handle indices which exceed array dimensions
* @param {StringArray} [options.submode=["throw"]] - specifies how to handle subscripts which exceed array dimensions on a per dimension basis
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @throws {Error} must provide either a `shape` or `buffer` option
* @throws {Error} number of strides must match number of dimensions
* @throws {RangeError} buffer must be compatible with specified meta data
* @returns {ndarray} ndarray instance
*
* @example
* TODO
*/
function ndarray( options ) {
	var strides;
	var offset;
	var buffer;
	var order;
	var dtype;
	var shape;
	var ndims;
	var opts;
	var len;

	opts = {};
	if ( !isObject( options ) ) {
		throw new TypeError( 'invalid input argument. Options argument must be an object. Value: `' + options + '`.' );
	}
	if ( hasOwnProp( options, 'dtype' ) ) {
		dtype = options.dtype;
		if ( !isDataType( dtype ) ) {
			throw new TypeError( 'invalid option. `dtype` option must be a recognized data type. Option: `' + dtype + '`.' );
		}
	} else {
		dtype = defaults.dtype;
	}
	if ( hasOwnProp( options, 'order' ) ) {
		order = options.order;
		if ( !isOrder( order ) ) {
			throw new TypeError( 'invalid option. `order` option must be a recognized order. Option: `' + order + '`.' );
		}
	}
	if ( hasOwnProp( options, 'codegen' ) ) {
		opts.codegen = options.codegen;
	} else {
		opts.codegen = defaults.codegen;
	}
	if ( hasOwnProp( options, 'mode' ) ) {
		opts.mode = options.mode;
	} else {
		opts.mode = defaults.mode;
	}
	if ( hasOwnProp( options, 'submode' ) ) {
		opts.submode = options.submode;
	} else {
		opts.submode = [ opts.mode ];
	}
	if ( hasOwnProp( options, 'buffer' ) ) {
		buffer = options.buffer;
		if ( !isArrayLikeObject( buffer ) ) { // weak test
			throw new TypeError( 'invalid option. `buffer` option must be an array-like object, typed-array-like, or a Buffer. Option: `' + buffer + '`.' );
		}
	}
	// If not provided a shape, infer from a provided data buffer...
	if ( hasOwnProp( options, 'shape' ) ) {
		shape = options.shape;
		if ( !isArrayLikeObject( shape ) ) { // weak test
			throw new TypeError( 'invalid option. `shape` option must be an array-like object containing nonnegative integers. Option: `' + shape + '`.' );
		}
		ndims = shape.length;
		len = numel( shape );
	} else if ( buffer ) {
		ndims = 1;
		len = buffer.length;
		shape = [ len ]; // assume a 1-dimensional array (vector)
	} else {
		throw new Error( 'invalid input argument. Must provide either a `shape` or `buffer` option. Value: `' + JSON.stringify( options ) + '`.' );
	}
	// If not provided strides, compute them...
	if ( hasOwnProp( options, 'strides' ) ) {
		strides = options.strides;
		if ( !isArrayLikeObject( strides ) ) { // weak test
			throw new TypeError( 'invalid option. `strides` option must be an array-like object containing integers. Option: `' + strides + '`.' );
		}
		// If not provided an order, infer the order from the `strides` array...
		order = order || strides2order( strides );
	} else {
		order = order || defaults.order;
		strides = shape2strides( shape, order );
	}
	// Determine the index "offset":
	offset = strides2offset( shape, strides );

	// TODO: if provided an order differing from that inferred from strides, need to convert to that order. See https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.array.html#numpy.array.

	// TODO: support a `copy` option?

	// If not provided a data buffer, create it; otherwise, see if we need to cast a provided buffer to another data type...
	if ( buffer && getType( buffer ) !== dtype ) {
		if ( buffer.length < len ) {
			throw new RangeError( 'invalid input arguments. Array shape is incompatible with provided buffer. To accommodate the requested shape, provide a bigger buffer.' );
		}
		buffer = castBuffer( buffer, len, dtype );
	} else if ( buffer === void 0 ) {
		buffer = createBuffer( dtype, len );
	}
	// Return a new ndarray:
	return ctor( dtype, ndims, opts )( buffer, shape, strides, offset, order );
} // end FUNCTION ndarray()


// EXPORTS //

module.exports = ndarray;
