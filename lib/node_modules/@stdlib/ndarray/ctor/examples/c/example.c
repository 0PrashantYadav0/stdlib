/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include "stdlib/ndarray/base/bytes_per_element.h"
#include "stdlib/ndarray/base/dtype_char.h"
#include "stdlib/ndarray/dtypes.h"
#include "stdlib/ndarray/index_modes.h"
#include "stdlib/ndarray/orders.h"
#include "stdlib/ndarray/ctor.h"

int main() {
	// Manually create an ndarray (WARNING: this is for illustration purposes only, as the fields of an ndarray are subject to change; for ABI compatibility, use utility functions for accessing ndarray data)...
	struct ndarray *x = malloc( sizeof( struct ndarray ) );
	if ( x == NULL ) {
		printf( "Error allocating memory.\n" );
		exit( 1 );
	}

	// Specify the underlying data type:
	enum STDLIB_NDARRAY_DTYPE dtype = STDLIB_NDARRAY_FLOAT64;
	x->dtype = dtype;

	// Create an underlying byte array:
	uint8_t buffer[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	x->data = buffer;

	// Explicitly specify the number of bytes per element:
	x->BYTES_PER_ELEMENT = STDLIB_NDARRAY_FLOAT64_BYTES_PER_ELEMENT;

	// Specify the array shape:
	int64_t shape[] = { 3 }; // vector consisting of 3 doubles
	x->shape = shape;

	// Specify the array strides:
	int64_t strides[] = { x->BYTES_PER_ELEMENT };
	x->strides = strides;

	// Specify the byte offset:
	x->offset = 0;

	// Specify the array order (note: this does not matter for a 1-dimensional array):
	enum STDLIB_NDARRAY_ORDER order = STDLIB_NDARRAY_ROW_MAJOR;
	x->order = order;

	// Specify the index mode:
	enum STDLIB_NDARRAY_INDEX_MODE imode = STDLIB_NDARRAY_INDEX_ERROR;

	// Specify the subscript index modes:
	enum STDLIB_NDARRAY_INDEX_MODE submodes[] = { imode };
	x->submodes = submodes;
	x->nsubmodes = 1;

	// Explicitly specify the number of array dimensions:
	x->ndims = 1; // vector

	// Explicitly specify the number of array elements (doubles):
	x->length = x->shape[ 0 ];

	// Explicitly specify the number of bytes:
	x->byteLength = (x->length) * (x->BYTES_PER_ELEMENT);

	// Explicitly set the array flags:
	x->flags = stdlib_ndarray_flags( x );

	printf( "dtype = %u\n", stdlib_ndarray_dtype( x ) );
	printf( "length = %lld\n", stdlib_ndarray_length( x ) );
	printf( "byteLength = %lld\n", stdlib_ndarray_bytelength( x ) );
	printf( "ltr = %u\n", stdlib_ndarray_dtype_char( stdlib_ndarray_dtype( x ) ) );

	// Free the allocated memory:
	free( x );

	// Use the function interface to create an ndarray (NOTE: for future ABI compatibility, using the following function interface should be preferred)...
	struct ndarray *x2 = stdlib_ndarray_constructor( dtype, buffer, 1, shape, strides, 0, order, imode, 1, submodes );
	if ( x2 == NULL ) {
		printf( "Error allocating memory.\n" );
		exit( 1 );
	}

	printf( "dtype = %u\n", stdlib_ndarray_dtype( x2 ) );
	printf( "length = %lld\n", stdlib_ndarray_length( x2 ) );
	printf( "byteLength = %lld\n", stdlib_ndarray_bytelength( x2 ) );
	printf( "ltr = %u\n", stdlib_ndarray_dtype_char( stdlib_ndarray_dtype( x2 ) ) );

	// Free the allocated memory:
	free( x2 );
}
