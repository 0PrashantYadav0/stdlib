'use strict';

// MODULES //

var tape = require( 'tape' );
var TransformStream = require( '@stdlib/streams/utils/transform' );
var randu = require( '@stdlib/math/base/random/randu' );
var isnan = require( '@stdlib/math/base/utils/is-nan' );
var isRegExp = require( '@stdlib/utils/is-regexp' );
var hypot = require( '@stdlib/math/base/special/hypot' );
var Benchmark = require( './../lib/benchmark-class' );
var Runner = require( './../lib/runner' );


// VARIABLES //

var RE_RESULTS = /!!RESULTS: ([0-9.]+),([0-9.]+),([0-9.]+)$/;
var RE_HEADERS = /!!HEADERS: iterations,elapsed,rate$/;
var TAP_HEADER = 'TAP version 13';


// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.strictEqual( typeof Runner, 'function', 'main export is a function' );
	t.end();
});

tape( 'the function is a constructor', function test( t ) {
	var runner = new Runner();
	t.strictEqual( runner instanceof Runner, true, 'returns an instance' );
	t.end();
});

tape( 'the constructor does not require the `new` keyword', function test( t ) {
	var createRunner;
	var runner;

	createRunner = Runner;
	runner = createRunner();

	t.strictEqual( runner instanceof Runner, true, 'returns an instance' );
	t.end();
});

tape( 'a runner instance has a `count` property', function test( t ) {
	var runner = new Runner();
	t.strictEqual( typeof runner.count, 'number', 'has property' );
	t.end();
});

tape( 'a runner instance has a `fail` property', function test( t ) {
	var runner = new Runner();
	t.strictEqual( typeof runner.fail, 'number', 'has property' );
	t.end();
});

tape( 'a runner instance has a `pass` property', function test( t ) {
	var runner = new Runner();
	t.strictEqual( typeof runner.pass, 'number', 'has property' );
	t.end();
});

tape( 'a runner instance has a `skipped` property', function test( t ) {
	var runner = new Runner();
	t.strictEqual( typeof runner.skipped, 'number', 'has property' );
	t.end();
});

tape( 'a runner instance has a `push` method to add a new benchmark', function test( t ) {
	var runner = new Runner();
	t.strictEqual( typeof runner.push, 'function', 'has method' );
	t.end();
});

tape( 'a runner instance has a `createStream` method to create a results stream', function test( t ) {
	var runner = new Runner();
	t.strictEqual( typeof runner.createStream, 'function', 'has method' );
	t.end();
});

tape( 'a runner instance has a `run` method to run benchmarks', function test( t ) {
	var runner = new Runner();
	t.strictEqual( typeof runner.run, 'function', 'has method' );
	t.end();
});

tape( 'a runner instance has a `clear` method to clear any pending benchmarks', function test( t ) {
	var runner = new Runner();
	t.strictEqual( typeof runner.clear, 'function', 'has method' );
	t.end();
});

tape( 'a runner instance has a `close` method to close a runner', function test( t ) {
	var runner = new Runner();
	t.strictEqual( typeof runner.close, 'function', 'has method' );
	t.end();
});

tape( 'a runner instance has an `exit` method to forcefully close a runner', function test( t ) {
	var runner = new Runner();
	t.strictEqual( typeof runner.exit, 'function', 'has method' );
	t.end();
});

tape( 'the `createStream` method throws if provided an `options` argument which is not an object', function test( t ) {
	var runner;
	var values;
	var i;

	values = [
		'5',
		5,
		NaN,
		null,
		undefined,
		true,
		false,
		[],
		function noop() {}
	];

	runner = new Runner();

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[ i ] ), TypeError, 'throws an error when provided '+values[ i ] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			runner.createStream( value );
		};
	}
});

tape( 'the `createStream` method throws if provided an invalid option', function test( t ) {
	var runner;
	var values;
	var i;

	values = [
		'5',
		5,
		NaN,
		null,
		undefined,
		true,
		false,
		[],
		{}
	];

	runner = new Runner();

	for ( i = 0; i < values.length; i++ ) {
		t.throws( badValue( values[ i ] ), TypeError, 'throws an error when provided '+values[ i ] );
	}
	t.end();

	function badValue( value ) {
		return function badValue() {
			runner.createStream({
				'transform': value
			});
		};
	}
});

tape( 'the `createStream` method returns a transform stream', function test( t ) {
	var runner;
	var stream;

	runner = new Runner();
	stream = runner.createStream();

	t.strictEqual( stream instanceof TransformStream, true, 'returns a transform stream' );
	t.end();
});

tape( 'if not an `objectMode` stream, the stream returned from the `createStream` method writes the TAP header as the first line', function test( t ) {
	var runner;
	var stream;
	var str;

	runner = new Runner();
	str = '';

	stream = runner.createStream({
		'objectMode': false
	});

	stream.on( 'data', onData );
	stream.on( 'close', onClose );
	stream.end();
	stream.destroy();

	function onData( data ) {
		str += data.toString();
	}

	function onClose() {
		t.strictEqual( str, TAP_HEADER+'\n' );
		t.end();
	}
});

tape( 'if an `objectMode` stream, the stream returned from the `createStream` method streams objects (sync)', function test( t ) {
	var runner;
	var stream;
	var bmark;
	var opts;
	var i;

	runner = new Runner();

	stream = runner.createStream({
		'objectMode': true
	});

	stream.on( 'data', onData );
	stream.on( 'close', onClose );

	opts = {
		'iterations': 1,
		'skip': false,
		'timeout': 60000
	};
	bmark = new Benchmark( 'beep', opts, benchmark );
	runner.push( bmark );

	i = -1;

	runner.on( 'done', onDone );
	runner.run();

	function benchmark( b ) {
		var i;
		b.tic();
		for ( i = 0; i < b.iterations; i++ ) {
			b.equal( 3.14, 3.14, 'should be equal' );
		}
		b.toc();
		b.end();
	}

	function onData( data ) {
		var expected;
		i += 1;
		t.strictEqual( typeof data, 'object', 'streams an object' );
		if ( i === 0 ) {
			expected = {
				'type': 'benchmark',
				'name': 'beep',
				'id': 0
			};
			t.deepEqual( data, expected, 'streams expected value '+i );
		} else if ( i === 1 ) {
			expected = {
				'id': 0,
				'ok': true,
				'name': 'should be equal',
				'operator': 'equal',
				'actual': 3.14,
				'expected': 3.14,
				'benchmark': 0,
				'type': 'assert',
				'skip': void 0,
				'todo': void 0
			};
			t.deepEqual( data, expected, 'streams expected value '+i );
		} else if ( i === 2 ) {
			t.strictEqual( data.benchmark, 0, 'has expected benchmark id' );
			t.strictEqual( data.type, 'comment', 'has expected datum type' );
			t.strictEqual( RE_HEADERS.test( data.name ), true, 'has expected header line' );
		} else if ( i === 3 ) {
			t.strictEqual( data.benchmark, 0, 'has expected benchmark id' );
			t.strictEqual( data.type, 'comment', 'has expected datum type' );
			t.strictEqual( RE_RESULTS.test( data.name ), true, 'has expected results line format' );
		} else if ( i === 4 ) {
			expected = {
				'benchmark': 0,
				'type': 'end'
			};
			t.deepEqual( data, expected, 'streams expected value '+i );
		} else {
			t.ok( false, 'too many streamed values' );
		}
	}

	function onDone() {
		stream.destroy();
	}

	function onClose() {
		t.end();
	}
});

tape( 'if an `objectMode` stream, the stream returned from the `createStream` method streams objects (async)', function test( t ) {
	var runner;
	var stream;
	var bmark;
	var opts;
	var i;

	runner = new Runner();

	stream = runner.createStream({
		'objectMode': true
	});

	stream.on( 'data', onData );
	stream.on( 'close', onClose );

	opts = {
		'iterations': 1,
		'skip': false,
		'timeout': 60000
	};
	bmark = new Benchmark( 'beep', opts, benchmark );
	runner.push( bmark );

	i = -1;

	runner.on( 'done', onDone );
	runner.run();

	function benchmark( b ) {
		var i;

		i = 0;
		b.tic();

		setTimeout( next, 0 );

		function next() {
			i += 1;
			if ( i <= b.iterations ) {
				b.equal( 3.14, 3.14, 'should be equal' );
				return setTimeout( next, 0 );
			}
			b.toc();
			b.end();
		}
	}

	function onData( data ) {
		var expected;
		i += 1;
		t.strictEqual( typeof data, 'object', 'streams an object' );
		if ( i === 0 ) {
			expected = {
				'type': 'benchmark',
				'name': 'beep',
				'id': 0
			};
			t.deepEqual( data, expected, 'streams expected value '+i );
		} else if ( i === 1 ) {
			expected = {
				'id': 0,
				'ok': true,
				'name': 'should be equal',
				'operator': 'equal',
				'actual': 3.14,
				'expected': 3.14,
				'benchmark': 0,
				'type': 'assert',
				'skip': void 0,
				'todo': void 0
			};
			t.deepEqual( data, expected, 'streams expected value '+i );
		} else if ( i === 2 ) {
			t.strictEqual( data.benchmark, 0, 'has expected benchmark id' );
			t.strictEqual( data.type, 'comment', 'has expected datum type' );
			t.strictEqual( RE_HEADERS.test( data.name ), true, 'has expected header line' );
		} else if ( i === 3 ) {
			t.strictEqual( data.benchmark, 0, 'has expected benchmark id' );
			t.strictEqual( data.type, 'comment', 'has expected datum type' );
			t.strictEqual( RE_RESULTS.test( data.name ), true, 'has expected results line format' );
		} else if ( i === 4 ) {
			expected = {
				'benchmark': 0,
				'type': 'end'
			};
			t.deepEqual( data, expected, 'streams expected value '+i );
		} else {
			t.ok( false, 'too many streamed values' );
		}
	}

	function onDone() {
		stream.destroy();
	}

	function onClose() {
		t.end();
	}
});

tape( 'if an `objectMode` stream, the stream returned from the `createStream` method guards against calling `run` more than once when benchmarks are already running (sync)', function test( t ) {
	var runner;
	var stream;
	var bmark;
	var opts;
	var i;

	runner = new Runner();

	stream = runner.createStream({
		'objectMode': true
	});

	stream.on( 'data', onData );
	stream.on( 'close', onClose );

	opts = {
		'iterations': 1,
		'skip': false,
		'timeout': 60000
	};
	bmark = new Benchmark( 'beep', opts, benchmark );
	runner.push( bmark );

	i = -1;

	runner.on( 'done', onDone );
	runner.run();
	runner.run();
	runner.run();
	runner.run();
	runner.run();

	function benchmark( b ) {
		var i;
		b.tic();
		for ( i = 0; i < b.iterations; i++ ) {
			b.equal( 3.14, 3.14, 'should be equal' );
		}
		b.toc();
		b.end();
	}

	function onData( data ) {
		var expected;
		i += 1;
		t.strictEqual( typeof data, 'object', 'streams an object' );
		if ( i === 0 ) {
			expected = {
				'type': 'benchmark',
				'name': 'beep',
				'id': 0
			};
			t.deepEqual( data, expected, 'streams expected value '+i );
		} else if ( i === 1 ) {
			expected = {
				'id': 0,
				'ok': true,
				'name': 'should be equal',
				'operator': 'equal',
				'actual': 3.14,
				'expected': 3.14,
				'benchmark': 0,
				'type': 'assert',
				'skip': void 0,
				'todo': void 0
			};
			t.deepEqual( data, expected, 'streams expected value '+i );
		} else if ( i === 2 ) {
			t.strictEqual( data.benchmark, 0, 'has expected benchmark id' );
			t.strictEqual( data.type, 'comment', 'has expected datum type' );
			t.strictEqual( RE_HEADERS.test( data.name ), true, 'has expected header line' );
		} else if ( i === 3 ) {
			t.strictEqual( data.benchmark, 0, 'has expected benchmark id' );
			t.strictEqual( data.type, 'comment', 'has expected datum type' );
			t.strictEqual( RE_RESULTS.test( data.name ), true, 'has expected results line format' );
		} else if ( i === 4 ) {
			expected = {
				'benchmark': 0,
				'type': 'end'
			};
			t.deepEqual( data, expected, 'streams expected value '+i );
		} else {
			t.ok( false, 'too many streamed values' );
		}
	}

	function onDone() {
		stream.destroy();
	}

	function onClose() {
		t.end();
	}
});

tape( 'if an `objectMode` stream, the stream returned from the `createStream` method guards against calling `run` more than once when benchmarks are already running (async)', function test( t ) {
	var runner;
	var stream;
	var bmark;
	var opts;
	var i;

	runner = new Runner();

	stream = runner.createStream({
		'objectMode': true
	});

	stream.on( 'data', onData );
	stream.on( 'close', onClose );

	opts = {
		'iterations': 1,
		'skip': false,
		'timeout': 60000
	};
	bmark = new Benchmark( 'beep', opts, benchmark );
	runner.push( bmark );

	i = -1;

	runner.on( 'done', onDone );
	runner.run();
	runner.run();
	runner.run();
	runner.run();
	runner.run();

	function benchmark( b ) {
		var i;

		i = 0;
		b.tic();

		setTimeout( next, 0 );

		function next() {
			i += 1;
			if ( i <= b.iterations ) {
				b.equal( 3.14, 3.14, 'should be equal' );
				return setTimeout( next, 0 );
			}
			b.toc();
			b.end();
		}
	}

	function onData( data ) {
		var expected;
		i += 1;
		t.strictEqual( typeof data, 'object', 'streams an object' );
		if ( i === 0 ) {
			expected = {
				'type': 'benchmark',
				'name': 'beep',
				'id': 0
			};
			t.deepEqual( data, expected, 'streams expected value '+i );
		} else if ( i === 1 ) {
			expected = {
				'id': 0,
				'ok': true,
				'name': 'should be equal',
				'operator': 'equal',
				'actual': 3.14,
				'expected': 3.14,
				'benchmark': 0,
				'type': 'assert',
				'skip': void 0,
				'todo': void 0
			};
			t.deepEqual( data, expected, 'streams expected value '+i );
		} else if ( i === 2 ) {
			t.strictEqual( data.benchmark, 0, 'has expected benchmark id' );
			t.strictEqual( data.type, 'comment', 'has expected datum type' );
			t.strictEqual( RE_HEADERS.test( data.name ), true, 'has expected header line' );
		} else if ( i === 3 ) {
			t.strictEqual( data.benchmark, 0, 'has expected benchmark id' );
			t.strictEqual( data.type, 'comment', 'has expected datum type' );
			t.strictEqual( RE_RESULTS.test( data.name ), true, 'has expected results line format' );
		} else if ( i === 4 ) {
			expected = {
				'benchmark': 0,
				'type': 'end'
			};
			t.deepEqual( data, expected, 'streams expected value '+i );
		} else {
			t.ok( false, 'too many streamed values' );
		}
	}

	function onDone() {
		stream.destroy();
	}

	function onClose() {
		t.end();
	}
});

tape( 'if not an `objectMode` stream, the stream returned from the `createStream` method streams Buffer objects', function test( t ) {
	var expected;
	var runner;
	var stream;
	var bmark;
	var opts;
	var str;

	expected = [
		TAP_HEADER,
		'# Math.hypot',
		RE_HEADERS,
		RE_RESULTS,
		'ok 1 benchmark success!',
		'# hypot',
		RE_HEADERS,
		RE_RESULTS,
		'ok 2 benchmark success!',
		''
	];

	runner = new Runner();
	str = '';

	stream = runner.createStream({
		'objectMode': false
	});

	stream.on( 'data', onData );
	stream.on( 'close', onClose );

	opts = {
		'iterations': 10,
		'skip': false,
		'timeout': 60000
	};
	bmark = new Benchmark( 'Math.hypot', opts, benchmark1 );
	runner.push( bmark );

	bmark = new Benchmark( 'hypot', opts, benchmark2 );
	runner.push( bmark );

	runner.on( 'done', onDone );
	runner.run();

	function benchmark1( b ) {
		var x;
		var y;
		var h;
		var i;

		b.tic();
		for ( i = 0; i < b.iterations; i++ ) {
			x = (randu()*100.0) - 50.0;
			y = (randu()*100.0) - 50.0;
			h = Math.hypot( x, y );
			if ( h < 0.0 || h > 200.0 ) {
				b.fail( 'something went wrong!' );
			}
		}
		b.toc();

		if ( isnan( h ) ) {
			b.fail( 'something went wrong!' );
		} else {
			b.pass( 'benchmark success!' );
		}
		b.end();
	}

	function benchmark2( b ) {
		var x;
		var y;
		var h;
		var i;

		b.tic();
		for ( i = 0; i < b.iterations; i++ ) {
			x = (randu()*100.0) - 50.0;
			y = (randu()*100.0) - 50.0;
			h = hypot( x, y );
			if ( h < 0.0 || h > 200.0 ) {
				b.fail( 'something went wrong!' );
			}
		}
		b.toc();

		if ( isnan( h ) ) {
			b.fail( 'something went wrong!' );
		} else {
			b.pass( 'benchmark success!' );
		}
		b.end();
	}

	function onData( data ) {
		str += data.toString();
	}

	function onDone() {
		var i;

		str = str.split( '\n' );
		for ( i = 0; i < str.length; i++ ) {
			if ( isRegExp( expected[ i ] ) ) {
				t.strictEqual( expected[ i ].test( str[ i ] ), true, 'streams expected line '+i+': '+expected[ i ] );
			} else {
				t.strictEqual( str[ i ], expected[ i ], 'streams expected line '+i+': '+expected[ i ].toString() );
			}
		}
		stream.destroy();
	}

	function onClose() {
		t.end();
	}
});
