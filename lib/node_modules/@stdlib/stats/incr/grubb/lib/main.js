/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var incrminmax = require( '@stdlib/stats/incr/minmax' );
var incrmeanstdev = require( '@stdlib/stats/incr/meanstdev' );
var copy = require( '@stdlib/utils/copy' );
var setReadOnly = require( '@stdlib/utils/define-read-only-property' );
var setReadOnlyAccessor = require( '@stdlib/utils/define-read-only-accessor' );
var max = require( '@stdlib/math/base/special/max' );
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var tQuantile = require( '@stdlib/stats/base/dists/t/quantile' );
var validate = require( './validate.js' );
var defaults = require( './defaults.json' );
var print = require( './print.js' ); // eslint-disable-line stdlib/no-redeclare


// MAIN //

/**
* Returns an accumulator function which incrementally performs Grubb's test for detecting outliers.
*
* @param {Options} [options] - function options
* @param {number} [options.alpha=0.05] - significance level
* @param {string} [options.alternative='two-sided'] - alternative hypothesis ('two-sided', 'min', 'max')
* @param {NonNegativeInteger} [options.init=100] - number of data points used to compute initial statistics
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {Function} accumulator function
*
* @example
* var randn = require( '@stdlib/random/base/randn' );
*
* var accumulator;
* var opts;
* var bool;
* var i;
*
* opts = {
*     'init': 100
* };
*
* accumulator = incrgrubb( opts );
*
* for ( i = 0; i < 200; i++ ) {
*     bool = accumulator( randn );
* }
*/
function incrgrubb() {
	var meanstdev;
	var results;
	var minmax;
	var opts;
	var err;
	var mm;
	var ms;
	var gc;
	var df;
	var N;
	var G;

	opts = copy( defaults );
	if ( arguments.length ) {
		err = validate( opts, arguments[ 0 ] );
		if ( err ) {
			throw err;
		}
	}
	// Initialize the results object:
	results = {};
	setReadOnlyAccessor( results, 'rejected', getRejected );
	setReadOnly( results, 'alpha', opts.alpha );
	setReadOnlyAccessor( results, 'criticalValue', getCriticalValue );
	setReadOnlyAccessor( results, 'statistic', getStatistic );
	setReadOnlyAccessor( results, 'df', getDOF );
	setReadOnlyAccessor( results, 'mean', getMean );
	setReadOnlyAccessor( results, 'sd', getStDev );
	setReadOnlyAccessor( results, 'min', getMin );
	setReadOnlyAccessor( results, 'max', getMax );
	setReadOnly( results, 'alt', opts.alternative );
	setReadOnly( results, 'method', 'Grubb\'s Test' );
	setReadOnly( results, 'print', print );

	N = 0;

	// Initialize statistics accumulators:
	mm = [ 0.0, 0.0 ];
	minmax = incrminmax( mm );

	ms = [ 0.0, 0.0 ];
	meanstdev = incrmeanstdev( ms );

	return accumulator;

	/**
	* If provided a value, the accumulator function returns updated Grubb's test results. If not provided a value, the accumulator function returns the current Grubb's test results.
	*
	* @private
	* @param {number} [x] - new value
	* @returns {(Object|null)} test results or null
	*/
	function accumulator( x ) {
		var sig;
		var md;
		var tc;
		if ( arguments.length === 0 ) {
			if ( N < opts.init ) {
				return null;
			}
			return results;
		}
		N += 1;

		// Update model statistics:
		meanstdev( x );
		minmax( x );

		if ( N < opts.init ) {
			return null;
		}
		// Compute the degrees of freedom:
		df = N - 2;

		// Compute the test statistic and significance level...
		if ( opts.alternative === 'min' ) {
			G = ( ms[0]-mm[0] ) / ms[ 1 ];
			sig = opts.alpha / N;
		} else if ( opts.alternative === 'max' ) {
			G = ( mm[1]-ms[0] ) / ms[ 1 ];
			sig = opts.alpha / N;
		} else { // two-sided
			md = max( ms[0]-mm[0], mm[1]-ms[0] ); // maximum absolute deviation
			G = md / ms[ 1 ];
			sig = opts.alpha / (2*N);
		}
		// Compute the critical values:
		tc = tQuantile( 1.0-sig, df );
		gc = (N-1)*tc / sqrt( N*(df+(tc*tc)) );

		return results;
	}

	/**
	* Returns a `boolean` indicating whether the null hypothesis should be rejected.
	*
	* @private
	* @returns {boolean} boolean indicating whether the null hypothesis should be rejected
	*/
	function getRejected() {
		return ( G > gc );
	}

	/**
	* Returns the critical value.
	*
	* @private
	* @returns {number} critical value
	*/
	function getCriticalValue() {
		return gc;
	}

	/**
	* Returns the test statistic.
	*
	* @private
	* @returns {number} test statistic
	*/
	function getStatistic() {
		return G;
	}

	/**
	* Returns the degrees of freedom (DOF).
	*
	* @private
	* @returns {PositiveInteger} degrees of freedom
	*/
	function getDOF() {
		return df;
	}

	/**
	* Returns the sample mean.
	*
	* @private
	* @returns {number} sample mean
	*/
	function getMean() {
		return ms[ 0 ];
	}

	/**
	* Returns the corrected sample standard deviation.
	*
	* @private
	* @returns {number} corrected sample standard deviation
	*/
	function getStDev() {
		return ms[ 1 ];
	}

	/**
	* Returns the sample minimum.
	*
	* @private
	* @returns {number} sample minimum
	*/
	function getMin() {
		return mm[ 0 ];
	}

	/**
	* Returns the sample maximum.
	*
	* @private
	* @returns {number} sample maximum
	*/
	function getMax() {
		return mm[ 1 ];
	}
}


// EXPORTS //

module.exports = incrgrubb;
