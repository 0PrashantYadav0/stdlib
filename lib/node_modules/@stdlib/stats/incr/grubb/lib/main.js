/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var isNumber = require( '@stdlib/assert/is-number' ).isPrimitive;
var isPositiveNumber = require( '@stdlib/assert/is-positive-number' ).isPrimitive;
var incrminmax = require( '@stdlib/stats/incr/minmax' );
var incrmeanstdev = require( '@stdlib/stats/incr/meanstdev' );
var copy = require( '@stdlib/utils/copy' );
var max = require( '@stdlib/math/base/special/max' );
var sqrt = require( '@stdlib/math/base/special/sqrt' );
var tQuantile = require( '@stdlib/stats/base/dists/t/quantile' );
var validate = require( './validate.js' );
var defaults = require( './defaults.json' );
var print = require( './print.js' ); // eslint-disable-line stdlib/no-redeclare
var copyResults = require( './copy_results.js' );


// MAIN //

/**
* Returns an accumulator function which incrementally performs Grubb's test for detecting outliers.
*
* @param {number} [mean] - known mean
* @param {PositiveNumber} [stdev] - known standard deviation
* @param {Options} [options] - function options
* @param {number} [options.alpha=0.05] - significance level
* @param {string} [options.alternative='two-sided'] - alternative hypothesis ('two-sided', 'min', 'max')
* @param {NonNegativeInteger} [options.init=100] - number of data points used to compute initial statistics
* @throws {TypeError} first argument must be a number
* @throws {TypeError} second argument must be a number
* @throws {TypeError} options argument must be an object
* @throws {TypeError} must provide valid options
* @returns {Function} accumulator function
*
* @example
* var randn = require( '@stdlib/random/base/randn' );
*
* var accumulator;
* var opts;
* var bool;
* var i;
*
* opts = {
*     'init': 100
* };
*
* accumulator = incrgrubb( opts );
*
* for ( i = 0; i < 200; i++ ) {
*     bool = accumulator( randn );
* }
*/
function incrgrubb() {
	var meanstdev;
	var results;
	var minmax;
	var opts;
	var err;
	var mm;
	var ms;
	var N;
	var G;

	opts = copy( defaults );
	if ( arguments.length === 1 ) {
		err = validate( opts, arguments[ 0 ] );
		if ( err ) {
			throw err;
		}
	} else if ( arguments.length === 2 ) {
		if ( !isNumber( arguments[ 0 ] ) ) {
			throw new TypeError( 'invalid argument. First argument must be a number. Value: `' + arguments[ 0 ] + '`.' );
		}
		if ( !isPositiveNumber( arguments[ 1 ] ) ) {
			throw new TypeError( 'invalid argument. Second argument must be a number. Value: `' + arguments[ 1 ] + '`.' );
		}
		ms = [ arguments[ 0 ], arguments[ 1 ] ];
	} else if ( arguments.length > 2 ) {
		if ( !isNumber( arguments[ 0 ] ) ) {
			throw new TypeError( 'invalid argument. First argument must be a number. Value: `' + arguments[ 0 ] + '`.' );
		}
		if ( !isPositiveNumber( arguments[ 1 ] ) ) {
			throw new TypeError( 'invalid argument. Second argument must be a number. Value: `' + arguments[ 1 ] + '`.' );
		}
		err = validate( opts, arguments[ 2 ] );
		if ( err ) {
			throw err;
		}
		ms = [ arguments[ 0 ], arguments[ 1 ] ];
	}
	// Initialize the results object:
	results = {
		'rejected': false,
		'alpha': opts.alpha,
		'criticalValue': 0.0,
		'statistic': 0.0,
		'df': 0,
		'mean': 0.0,
		'sd': 0.0,
		'min': 0.0,
		'max': 0.0,
		'alt': opts.alternative,
		'method': 'Grubb\'s Test',
		'print': print
	};

	N = 0;
	mm = [ 0.0, 0.0 ];
	minmax = incrminmax( mm );
	if ( ms === void 0 ) {
		ms = [ 0.0, 0.0 ];
		meanstdev = incrmeanstdev( ms );
	} else {
		opts.init = 1;
	}
	return accumulator;

	/**
	* If provided a value, the accumulator function returns updated Grubb's test results. If not provided a value, the accumulator function returns the current Grubb's test results.
	*
	* @private
	* @param {number} [x] - new value
	* @returns {(Object|null)} test results or null
	*/
	function accumulator( x ) {
		var sig;
		var df;
		var md;
		var tc;
		var gc;
		if ( arguments.length === 0 ) {
			if ( N < opts.init ) {
				return null;
			}
			return copyResults( results );
		}
		N += 1;

		// Update model statistics:
		if ( meanstdev !== void 0 ) {
			meanstdev( x );
		}
		minmax( x );

		if ( N < opts.init ) {
			return null;
		}
		// Compute the degrees of freedom:
		df = N - 2;

		// Compute the test statistic and significance level...
		if ( opts.alternative === 'min' ) {
			G = ( ms[0]-mm[0] ) / ms[ 1 ];
			sig = opts.alpha / N;
		} else if ( opts.alternative === 'max' ) {
			G = ( mm[1]-ms[0] ) / ms[ 1 ];
			sig = opts.alpha / N;
		} else { // two-sided
			md = max( ms[0]-mm[0], mm[1]-ms[0] ); // maximum absolute deviation
			G = md / ms[ 1 ];
			sig = opts.alpha / (2*N);
		}
		// Compute the critical values:
		tc = tQuantile( 1.0-sig, df );
		gc = (N-1)*tc / sqrt( N*(df+(tc*tc)) );

		// Update results:
		results.rejected = ( G > gc );
		results.criticalValue = gc;
		results.statistic = G;
		results.df = df;
		results.mean = ms[ 0 ];
		results.sd = ms[ 1 ];
		results.min = mm[ 0 ];
		results.max = mm[ 1 ];

		return copyResults( results );
	}
}


// EXPORTS //

module.exports = incrgrubb;
