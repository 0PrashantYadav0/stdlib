/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var isPositiveInteger = require( '@stdlib/assert/is-positive-integer' ).isPrimitive;
var isNumber = require( '@stdlib/assert/is-number' ).isPrimitive;
var isnan = require( '@stdlib/math/base/assert/is-nan' );


// MAIN //

/**
* Returns an accumulator function which incrementally computes a moving unbiased sample covariance.
*
* ## Method
*
* -   Let \\(W\\) be a window of \\(N\\) elements over which we want to compute an unbiased sample covariance.
*
* -   We begin by defining the covariance \\( \operatorname{cov}_n(x,y) \\)
*
*     ```tex
*     \operatorname{cov}_n(x,y) &= \frac{C_n}{n}
*     ```
*
*     where \\(C_n\\) is the co-moment, which is defined as
*
*     ```tex
*     C_n = \sum_{i=1}^{n} ( x_i - \bar{x}_n ) ( y_i - \bar{y}_n )
*     ```
*
*     where \\(\bar{x}_n\\) and \\(\bar{y}_n\\) are the sample means for \\(x\\) and \\(y\\), respectively.
*
* -   The difference between the unbiased sample covariance in a window \\(W_i\\) and the unbiased sample covariance in a window \\(W_{i+1})\\) is given by
*
*     ```tex
*     \Delta \operatorname{cov} = \operatorname{cov}_i - \operatorname{cov}_{i+1}
*     ```
*
* -   If we multiply both sides by \\(N-1\\),
*
*     ```tex
*     (N-1)(\Delta \operatorname{cov}) = (N-1)\operatorname{cov}_i - (N-1)\operatorname{cov}
*     ```
*
* -   If we substitute the definition of the unbiased sample covariance having the form
*
*     ```tex
*     \begin{align*}
*     \operatorname{cov}_n(x,y) &= \frac{1}{N-1} \biggl( \sum_{i=1}^{N} (x_i - \bar{x}_n)(y_i - \bar{y}_n) \biggr) \\
*            &= \frac{1}{N-1} \biggl( \sum_{i=1}^{N} (x_i y_i - \bar{x}_n y_i - \bar{y}_n x_i + \bar{x}_n\bar{y}_n) \biggr) \\
*            &= \frac{1}{N-1} \biggl( \sum_{i=1}^{N} x_i y_i - \bar{x}_n \sum_{i=1}^{N} y_i - \bar{y}_n \sum_{i=1}^{N} x_i + \sum_{i=1}^{N} \bar{x}_n\bar{y}_n) \biggr) \\
*            &= \frac{1}{N-1} \biggl( \sum_{i=1}^{N} x_i y_i - \frac{N\bar{x}_n\sum_{i=1}^{N} y_i}{N} - \frac{N\bar{y}_n\sum_{i=1}^{N} x_i}{N} + N\bar{x}_n \bar{y}_n \biggr) \\
*            &= \frac{1}{N-1} \biggl( \sum_{i=1}^{N} x_i y_i - 2N\bar{x}_n\bar{y}_n + N\bar{x}_n\bar{y}_n \biggr) \\
*            &= \frac{1}{N-1} \biggl( \sum_{i=1}^{N} x_i y_i - N\bar{x}_n\bar{y}_n \biggr)
*     \end{align}
*     ```
*
*     we return
*
*     ```tex
*     (N-1)(\Delta \operatorname{cov}_n) = \biggl(\sum_{k=1}^N x_k y_k - N\bar{x}_{i+1}\bar{y}_{i+1} \biggr) - \biggl(\sum_{k=0}^{N-1} x_k y_k - N\bar{x}_{i}\bar{y}_{i} \biggr)
*     ```
*
* -   This can be further simplified by recognizing that subtracting the sums reduces to \\(x_N y_N - x_0 y_0\\); in which case,
*
*     ```tex
*     \begin{align*}
*     (N-1)(\Delta \operatorname{cov}_n) &= x_N y_N - x_0 y_0 - N\bar{x}_{i+1}\bar{y}_{i+1} + N\bar{x}_{i}\bar{y}_{i} \\
*     &= x_N y_N - x_0 y_0 - N(\bar{x}_{i+1}\bar{y}_{i+1} - \bar{x}_{i}\bar{y}_{i})
*     \end{align}
*     ```
*
* -   Recognizing that the difference of means can be expressed
*
*     ```tex
*     \begin{align*}
*     \bar{x}_{i+1} - \bar{x}_i &= \frac{1}{N} \biggl( \sum_{k=1}^N x_k - \sum_{k=0}^{N-1} x_k \biggr) &= \frac{x_N - x_0}{N} \\
*     \bar{y}_{i+1} - \bar{y}_i &= \frac{1}{N} \biggl( \sum_{k=1}^N y_k - \sum_{k=0}^{N-1} y_k \biggr) &= \frac{y_N - y_0}{N}
*     \end{align}
*     ```
*
*     reorganizing terms
*
*     ```tex
*     \begin{align*}
*     \bar{x}_{i+1} &= \bar{x}_i + \frac{x_N - x_0}{N} \\
*     \bar{y}_{i+1} &= \bar{y}_i + \frac{y_N - y_0}{N}
*     \end{align}
*     ```
*
*     and substituting into the equation above
*
*     ```tex
*     (N-1)(\Delta \operatorname{cov}_n) = x_N y_N - x_0 y_0 - N\biggl(\biggl(\bar{x}_i + \frac{x_N - x_0}{N}\biggr)\biggl(\bar{y}_i + \frac{y_N - y_0}{N}\biggr) - \bar{x}_{i}\bar{y}_{i}\biggr)
*     ```
*
* -   Rearranging terms gives us an update equation
*
*     ```tex
*     \begin{align*}
*     (N-1)(\Delta \operatorname{cov}_n) &= x_N y_N - x_0 y_0 - N\biggl( \frac{1}{N} \bar{x}_i(y_N - y_0) + \frac{1}{N}\bar{y}_i(x_N - x_0) + \frac{1}{N^2}(x_N - x_0)(y_N - y_0) \biggr) \\
*     &= x_N y_N - x_0 y_0 - \bar{x}_i(y_N - y_0) - (x_N - x_0)\biggl(\bar{y}_i + \frac{y_N - y_0}{N}\biggr) \\
*     &= x_N y_N - x_0 y_0 - \bar{x}_i(y_N - y_0) - \bar{y}_{i+1}(x_N - x_0)
*     \end{align}
*     ```
*
*     which can be equivalently expressed
*
*     ```tex
*     (N-1)(\Delta \operatorname{cov}_n) = x_N y_N - x_0 y_0 - \bar{x}_{i+1}(y_N - y_0) - \bar{y}_i(x_N - x_0)
*     ```
*
* @param {PositiveInteger} W - window size
* @param {number} [meanx] - mean value
* @param {number} [meany] - mean value
* @throws {TypeError} first argument must be a positive integer
* @throws {TypeError} second argument must be a number primitive
* @throws {TypeError} third argument must be a number primitive
* @returns {Function} accumulator function
*
* @example
* var accumulator = incrmcovariance( 3 );
*
* @example
* var accumulator = incrmcovariance( 3, -2.0, 10.0 );
*/
function incrmcovariance( W, meanx, meany ) {
	var buf;
	var mx;
	var my;
	var dx;
	var dy;
	var C;
	var N;
	var n;
	var i;
	if ( !isPositiveInteger( W ) ) {
		throw new TypeError( 'invalid input argument. First argument must be a positive integer. Value: `' + W + '`.' );
	}
	buf = new Array( 2*W ); // strided array
	n = W - 1;
	C = 0.0;
	i = -1;
	N = 0;
	if ( arguments.length > 1 ) {
		if ( !isNumber( meanx ) ) {
			throw new TypeError( 'invalid input argument. Second argument must be a number primitive. Value: `' + meanx + '`.' );
		}
		if ( !isNumber( meany ) ) {
			throw new TypeError( 'invalid input argument. Third argument must be a number primitive. Value: `' + meany + '`.' );
		}
		mx = meanx;
		my = meany;
		return accumulator2;
	}
	mx = 0.0;
	my = 0.0;
	return accumulator1;

	/**
	* If provided a value, the accumulator function returns an updated unbiased sample covariance. If not provided a value, the accumulator function returns the current unbiased sample covariance.
	*
	* @private
	* @param {number} [x] - input value
	* @param {number} [y] - input value
	* @returns {(number|null)} unbiased sample covariance or null
	*
	* @example
	* var v = accumulator1();
	* // returns null
	*
	* v = accumulator1( 2.0, 1.0 );
	* // returns 0.0
	*
	* v = accumulator1( -5.0, 3.14 );
	* // returns ~-7.49
	*
	* v = accumulator1( 3.0, -1.0 );
	* // returns TODO
	*
	* v = accumulator1( 5.0, -9.6 );
	* // returns TODO
	*
	* v = accumulator1();
	* // returns TODO
	*/
	function accumulator1( x, y ) {
		var v1;
		var v2;
		var k;
		var j;
		if ( arguments.length === 0 ) {
			if ( N === 0 ) {
				return null;
			}
			if ( N === 1 ) {
				return ( isnan( C ) ) ? NaN : 0.0;
			}
			if ( N < W ) {
				return C / (N-1);
			}
			return C / n;
		}
		// Update the strided array index for managing the circular buffer:
		i = 2 * ( ((i/2)+1) % W );

		// Case: an incoming value is NaN, the sliding co-moment is automatically NaN...
		if ( isnan( x ) || isnan( y ) ) {
			N = W; // explicitly set to avoid `N < W` branch
			C = NaN;
		}
		// Case: initial window...
		else if ( N < W ) {
			buf[ i ] = x; // update buffer
			buf[ i+1 ] = y;

			N += 1;
			dx = x - mx;
			mx += dx / N;
			my += ( y-my ) / N;
			C += dx * ( y-my ); // Note: repeated `y-my` is intentional, as `my` is updated when used here
			if ( N === 1 ) {
				return 0.0;
			}
			return C / (N-1);
		}
		// Case: N = W = 1
		else if ( N === 1 ) {
			return 0.0;
		}
		// Case: an outgoing value is NaN, and, thus, we need to compute the accumulated values...
		else if ( isnan( buf[ i ] ) || isnan( buf[ i+1 ] ) ) {
			N = 1;
			mx = x;
			my = y;
			C = 0.0;
			for ( k = 0; k < W; k++ ) {
				j = 2 * k; // convert to a strided array index
				if ( j !== i ) {
					v1 = buf[ j ];
					v2 = buf[ j+1 ];
					if ( isnan( v1 ) || isnan( v2 ) ) {
						N = W; // explicitly set to avoid `N < W` branch
						C = NaN;
						break; // co-moment is automatically NaN, so no need to continue
					}
					N += 1;
					dx = v1 - mx;
					mx += dx / N;
					my += ( v2-my ) / N;
					C += dx * ( v2-my ); // Note: repeated `y-my` is intentional, as `my` is updated when used here
				}
			}
		}
		// Case: neither the current co-moment nor the incoming values are NaN, so we need to update the accumulated values...
		else if ( isnan( C ) === false ) {
			v1 = buf[ i ];
			v2 = buf[ i+1 ];
			dx = x - v1;
			dy = y - v2;
			my += dy / W;
			C += (x*y) - (v1*v2) - (mx*dy) - (my*dx);
			mx += dx / W; // Note: updating `mx` here is intentional, as the update equation uses "old" `x` mean
		}
		// Case: the current co-moment is NaN, so nothing to do until the buffer no longer contains NaN values...
		buf[ i ] = x;
		buf[ i+1 ] = y;

		return C / n;
	}

	/**
	* If provided a value, the accumulator function returns an updated unbiased sample covariance. If not provided a value, the accumulator function returns the current unbiased sample covariance.
	*
	* @private
	* @param {number} [x] - input value
	* @param {number} [y] - input value
	* @returns {(number|null)} unbiased sample covariance or null
	*/
	function accumulator2( x, y ) {
		var k;
		var j;
		if ( arguments.length === 0 ) {
			if ( N === 0 ) {
				return null;
			}
			if ( N < W ) {
				return C / N;
			}
			return C / W;
		}
		// Update the strided array index for managing the circular buffer:
		i = 2 * ( ((i/2)+1) % W );

		// Case: an incoming value is NaN, the sliding co-moment is automatically NaN...
		if ( isnan( x ) || isnan( y ) ) {
			N = W; // explicitly set to avoid `N < W` branch
			C = NaN;
		}
		// Case: initial window...
		else if ( N < W ) {
			buf[ i ] = x; // update buffer
			buf[ i+1 ] = y;

			N += 1;
			C += ( x-mx ) * ( y-my );
			return C / N;
		}
		// Case: an outgoing value is NaN, and, thus, we need to compute the accumulated values...
		else if ( isnan( buf[ i ] ) || isnan( buf[ i+1 ] ) ) {
			C = 0.0;
			for ( k = 0; k < W; k++ ) {
				j = 2 * k; // convert to a strided array index
				if ( j !== i ) {
					if ( isnan( buf[ j ] ) || isnan( buf[ j+1 ] ) ) {
						N = W; // explicitly set to avoid `N < W` branch
						C = NaN;
						break; // co-moment is automatically NaN, so no need to continue
					}
					C += ( buf[j]-mx ) * ( buf[j+1]-my );
				}
			}
		}
		// Case: neither the current co-moment nor the incoming values are NaN, so we need to update the accumulated values...
		else if ( isnan( C ) === false ) {
			// Use textbook formula along with simplification arising from difference of sums:
			C += ( (x-mx)*(y-my) ) - ( (buf[i]-mx)*(buf[i+1]-my) );
		}
		// Case: the current co-moment is NaN, so nothing to do until the buffer no longer contains NaN values...
		buf[ i ] = x;
		buf[ i+1 ] = y;

		return C / W;
	}
}


// EXPORTS //

module.exports = incrmcovariance;
