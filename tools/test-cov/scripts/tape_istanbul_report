#!/usr/bin/env bash
#
# Script to generate an [Istanbul][1] code coverage report from [tape][2] tests.
#
# [1]: https://github.com/gotwarlost/istanbul
# [2]: https://github.com/substack/tape


# VARIABLES #

# Cache provided arguments:
args="$@"

# Root project directory:
root="$(dirname $0)/../../.."

# Base directory in which to search for tests:
dir="$PWD"

# Test folder name:
folder='test'

# Test filter:
filter='.*/.*'

# Test pattern:
pattern='test*.js'

# Global coverage variable:
global='__coverage__'

# Output directory for coverage reports:
output=""

# Define the command for `node`:
if [[ -z "$NODE" ]]; then
	cmd=node
else
	cmd="$NODE"
fi

# Define the tape test runner executable for Istanbul instrumented source code:
test_runner="${root}/tools/test-cov/tape-istanbul/bin/cli"

# Define the path to the `tap-spec` executable:
tap_reporter="${root}/node_modules/.bin/tap-spec"


# FUNCTIONS #

# Prints usage information.
usage() {
cat << EOF

Generate an Istanbul coverage report from tape tests.

Options:

  -h,    --help                Print this message.
         --dir dirpath         Base directory in which to search for tests.
         --folder name         Test folder name.
         --filter filter       Directory path filter.
         --pattern pattern     Filename pattern.
         --global variable     Global coverage variable name.
         --output dirpath      Coverage report output directory.

EOF
}

# Defines an error handler.
#
# $1 - error status
on_error() {
	echo 'ERROR: An error was encountered during execution.' >&2
	cleanup
	exit "$1"
}

# Runs clean-up tasks.
cleanup() {
	echo '' >&2
	return 0
}

# Creates a directory recursively.
#
# $1 - directory path
create_dir() {
	mkdir -p "$1"
	if [[ "$?" -ne 0 ]]; then
		echo "ERROR: unable to create directory: $1."
		return 1
	fi
	return 0
}

# Returns a list of instrumented source code test directories.
#
# $1 - base directory
# $2 - name
# $3 - filter
get_dirs() {
	# Determine the host kernel:
	local kernel=$(uname -s)

	# On Mac OSX, in order to use `|` and other regular expression operators, we need to use enhanced regular expression syntax (-E); see https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man7/re_format.7.html#//apple_ref/doc/man/7/re_format.
	local flag
	if [[ "${kernel}" = "Darwin" ]]; then
		flag='-E'
	fi

	# Find matching directories.
	dirs="$(find ${flag} $1 -type 'd' -name $2 -regex $3)"
	if [[ "$?" -ne 0 ]]; then
		echo 'ERROR: unable to find test directories.' >&2
		return 1
	fi
	echo "${dirs}"
	return 0
}

# "Slugifies" a string.
#
# $1 - string to slugify
get_slug() {
	echo "$1" | sed -e 's/[^[:alnum:]]/_/g' | tr -s '-' | tr A-Z a-z
}

# Generates a coverage report name.
#
# $1 - path
# $2 - output directory
get_report_name() {
	local slug="$(get_slug $1)"
	echo "$2/coverage_${slug}_$(date +'%Y%m%d_%H%M%S')_$RANDOM.json"

}

# Generates a coverage report.
generate_report() {
	echo 'Generating a coverage report...' >&2
	make test-istanbul-report
	if [[ "$?" -ne 0 ]]; then
		echo 'ERROR: unable to generate coverage report.' >&2
		return 1
	fi
	return 0
}

# Runs tests within a specified directory.
#
# $1 - directory path
# $2 - filename pattern
# $3 - global coverage variable
# $4 - output directory path
run_dir_tests() {
	local name="$(get_report_name $1 $4)"
	local pattern="$1/**/$2"

	"${cmd}" "${test_runner}" --dir "$1" --global "$3" --output "${name}" "${pattern}"

	if [[ "$?" -ne 0 ]]; then
		return 1
	fi
	return 0
}

# Runs tests.
run_tests() {
	local dirs="$(get_dirs ${dir} ${folder} ${filter})"
	if [[ "$?" -ne 0 ]]; then
		return 1
	fi
	for d in "${dirs}"; do
		echo '' >&2
		echo "Running tests in directory: $d" >&2
		echo '' >&2
		run_dir_tests "${d}" "${pattern}" "${global}" "${output}"
		if [[ "$?" -ne 0 ]]; then
			return 1
		fi
	done
	return 0
}

# Main execution sequence.
main() {
	create_dir "${output}"
	if [[ "$?" -ne 0 ]]; then
		on_error 1
	fi
	run_tests
	if [[ "$?" -ne 0 ]]; then
		on_error 1
	fi
	generate_report
	if [[ "$?" -ne 0 ]]; then
		on_error 1
	fi
	cleanup
	exit 0
}

# Set an error handler to print captured output and perform any clean-up tasks:
trap 'on_error' ERR

# Run in the top-level project directory:
cd "${root}"

# Parse command-line options:
while :; do
	case "$1" in
		-h|--help)
			usage
			exit 0
			;;
		--dir)
			if [[ -n "$2" ]]; then
				dir="$2"
				shift
			else
				echo 'ERROR: "--dir" requires a non-empty option argument.' >&2
				on_error 1
			fi
			;;
		--dir=?*)
			# Delete everything up to "=" and assign the remainder:
			dir="${1#*=}"
			;;
		--dir=)
			# Handle empty "--dir=" option:
			echo 'ERROR: "--dir" requires a non-empty option argument.' >&2
			on_error 1
			;;
		--folder)
			if [[ -n "$2" ]]; then
				folder="$2"
				shift
			else
				echo 'ERROR: "--folder" requires a non-empty option argument.' >&2
				on_error 1
			fi
			;;
		--folder=?*)
			# Delete everything up to "=" and assign the remainder:
			folder="${1#*=}"
			;;
		--folder=)
			# Handle empty "--folder=" option:
			echo 'ERROR: "--folder" requires a non-empty option argument.' >&2
			on_error 1
			;;
		--filter)
			if [[ -n "$2" ]]; then
				filter="$2"
				shift
			else
				echo 'ERROR: "--filter" requires a non-empty option argument.' >&2
				on_error 1
			fi
			;;
		--filter=?*)
			# Delete everything up to "=" and assign the remainder:
			filter="${1#*=}"
			;;
		--filter=)
			# Handle empty "--filter=" option:
			echo 'ERROR: "--filter" requires a non-empty option argument.' >&2
			on_error 1
			;;
		--pattern)
			if [[ -n "$2" ]]; then
				pattern="$2"
				shift
			else
				echo 'ERROR: "--pattern" requires a non-empty option argument.' >&2
				on_error 1
			fi
			;;
		--pattern=?*)
			# Delete everything up to "=" and assign the remainder:
			pattern="${1#*=}"
			;;
		--pattern=)
			# Handle empty "--pattern=" option:
			echo 'ERROR: "--pattern" requires a non-empty option argument.' >&2
			on_error 1
			;;
		--global)
			if [[ -n "$2" ]]; then
				global="$2"
				shift
			else
				echo 'ERROR: "--global" requires a non-empty option argument.' >&2
				on_error 1
			fi
			;;
		--global=?*)
			# Delete everything up to "=" and assign the remainder:
			global="${1#*=}"
			;;
		--global=)
			# Handle empty "--global=" option:
			echo 'ERROR: "--global" requires a non-empty option argument.' >&2
			on_error 1
			;;
		--output)
			if [[ -n "$2" ]]; then
				output="$2"
				shift
			else
				echo 'ERROR: "--output" requires a non-empty option argument.' >&2
				on_error 1
			fi
			;;
		--output=?*)
			# Delete everything up to "=" and assign the remainder:
			output="${1#*=}"
			;;
		--output=)
			# Handle empty "--output=" option:
			echo 'ERROR: "--output" requires a non-empty option argument.' >&2
			on_error 1
			;;
		--)
			# End of options:
			shift
			break
			;;
		-?*)
			# Handle unknown options:
			printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
			;;
		*)
			# Default case (end the loop if no more options):
			break
	esac

	shift
done

# Run main:
main
