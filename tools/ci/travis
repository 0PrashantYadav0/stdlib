#!/usr/bin/env bash
#
# Build script to run continuous integration on [Travis CI][1].
#
# [1]: travis-ci.org


# VARIABLES #

# Get the name of the build task as the first argument to the build script:
task="$1"

# Define an output file to store log output:
log_file=/var/log/travis-ci.log

# Define a heartbeat interval to periodically print messages in order to prevent Travis CI from prematurely ending a build due to long running commands:
heartbeat_interval=30s

# Declare a variable for storing the heartbeat process id:
heartbeat_pid=

# Define the number of lines of logged output to print upon completion:
tail_num_lines=4000


# FUNCTIONS #

# Defines an error handler.
#
# $1 - error status
on_error() {
	echo 'ERROR: An error was encountered during execution.' >&2
	cleanup
	exit "$1"
}

# Runs clean-up tasks.
cleanup() {
	tail_output "$log_file" "$tail_num_lines"
	stop_heartbeat
}

# Starts a heartbeat.
#
# $1 - heartbeat interval
start_heartbeat() {
	echo 'Starting heartbeat...' >&2

	# Create a heartbeat and send to background:
	heartbeat "$1" &

	# Capture the heartbeat pid:
	heartbeat_pid=$!
	echo "Heartbeat pid: $heartbeat_pid" >&2
}

# Runs an infinite print loop.
#
# $1 - heartbeat interval
heartbeat() {
	while true; do
		echo "$(date) - heartbeat..." >&2;
		sleep "$1";
	done
}

# Stops the heartbeat print loop.
stop_heartbeat() {
	echo 'Stopping heartbeat...' >&2
	kill "$heartbeat_pid"
}

# Tails a log file.
#
# $1 - log file to tail
# $2 - number of lines to tail
tail_output() {
   echo "Printing the last $2 lines of log output..." >&2
   tail -"$2" "$1"
}

# Creates an output log file.
#
# $1 - log file path
create_log_file() {
	sudo touch "$1"
	sudo chown travis "$1"
}

# Prints a success message.
print_success() {
	echo 'Success!' >&2
}

# Runs unit tests.
#
# $1 - log file
run_tests() {
	echo 'Running tests...' >&2
	make test >> "$1" 2>&1
}

# Runs test coverage.
#
# $1 - log file
run_test_coverage() {
	echo 'Running test coverage...' >&2
	make test-cov >> "$1" 2>&1
}

# Sends test coverage to coverage service.
#
# $1 - log file
send_coverage() {
	echo 'Sending coverage report to coverage service...' >&2
	make coverage >> "$1" 2>&1
}

# Runs benchmarks.
#
# $1 - log file
run_benchmarks() {
	echo 'Running benchmarks...' >&2
	make benchmark >> "$1" 2>&1
}

# Runs examples.
#
# $1 - log file
run_examples() {
	echo 'Running examples...' >&2
	make examples >> "$1" 2>&1
}

# Checks dependencies.
#
# $1 - log file
check_deps() {
	echo 'Checking dependencies...' >&2
	make check-deps >> "$1" 2>&1
}

# Main execution sequence.
main() {
	create_log_file "$log_file"
	start_heartbeat "$heartbeat_interval"
	if [[ "$task" = "test" ]]; then
		# FIXME: remove checking deps once separate build environment
		check_deps "$log_file"
		run_tests "$log_file"
	elif [[ "$task" = "benchmark" ]]; then
		run_benchmarks "$log_file"
	elif [[ "$task" = "examples" ]]; then
		run_examples "$log_file"
	elif [[ "$task" = "test-coverage" ]]; then
		run_test_coverage "$log_file"
		send_coverage "$log_file"
	elif [[ "task" = "check-deps" ]]; then
		check_deps "$log_file"
	else
		echo "ERROR: unknown task: $task." >&2
		on_error 1
	fi
	cleanup
	print_success
	exit 0
}

# Exit immediately if one of the executed commands exits with a non-zero status:
set -e

# Set an error handler to print captured output and perform any clean-up tasks:
trap 'on_error' ERR

# Run main:
main
