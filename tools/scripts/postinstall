#!/usr/bin/env node

/**
* @license Apache-2.0
*
* Copyright (c) 2019 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable no-sync, no-process-env, no-console */

'use strict';

// MODULES //

var path = require( 'path' );
var fs = require( 'fs' );
var logger = require( 'debug' );


// VARIABLES //

var debug = logger( 'stdlib:post-install' );

// Define the project package name:
var PKG_NAME = '@stdlib/stdlib';

// Define the folder name for storing node_modules dependencies:
var NODE_MODULES = 'node_modules';

// Resolve the root project directory (WARNING: this is fragile and likely needs to be updated should this file move!):
var ROOT_DIR = path.resolve( __dirname, '..', '..' );

// Resolve the project package directory:
var PKG_DIR = path.join( ROOT_DIR, 'lib', 'node_modules', '@stdlib' );

// Resolve the destination directory:
var DEST_DIR = path.resolve( ROOT_DIR, '..' );

// Resolve the path of this script within the project (WARNING: this is fragile and likely needs to be updated should this file move!):
var PKG_SCRIPT_PATH = path.join( PKG_NAME, 'tools', 'scripts', path.basename( __filename ) );

// Define an output file path for storing post-install meta data:
var OUTPUT_FILE = path.join( ROOT_DIR, '.postinstall.json' );

// Regular expression to detect whether this script is being executed after this package was installed as a node_modules dependency:
var RE_SCRIPT_CONTEXT = /[\\/]node_modules[\\/]@stdlib[\\/]stdlib[\\/]/;

// Define the lifecycle hook script:
var LIFECYCLE_HOOK = [
	'#!/usr/bin/env node',
	'',
	'\'use strict\';',
	'',
	'require( \''+PKG_SCRIPT_PATH+'\' );',
	''
].join( '\n' );


// MAIN //

/**
* Main execution sequence.
*
* ## Notes
*
* -   We add a post-install lifecycle hook in order to provide a "workaround" to how `npm install` works (see <https://docs.npmjs.com/cli/install#algorithm>). Namely, upon first running `npm install`, this script will be run after installing the project package. This script subsequently modifies the `node_modules` tree. Upon a subsequent `npm install`, npm will "undo" our modifications (which is not good for us!) as those modifications are not included in the ideal package tree, and npm will not run this script as the package lifecycle event is not triggered. However, npm will run a post-install lifecycle hook, so we install such a hook which simply runs this script.
*
* @private
* @returns {void}
*/
function main() {
	var action;
	var stats;
	var opts;
	var list;
	var odir;
	var ndir;
	var meta;
	var out;
	var FLG;
	var p;
	var f;
	var i;

	debug( 'Checking package context...' );
	if ( process.env.npm_package_name === PKG_NAME ) {
		debug( 'Detected applicable package context: %s', process.env.npm_package_name );
	} else {
		// If we are here, this script was likely invoked during npm lifecycle hook execution...
		debug( 'Detected foreign package context: %s', process.env.npm_package_name );

		// Check for a meta data file...
		if ( fs.existsSync( OUTPUT_FILE ) ) {
			debug( 'Detected meta data file: %s', OUTPUT_FILE );
			meta = require( OUTPUT_FILE ); // eslint-disable-line stdlib/no-dynamic-require

			debug( 'Checking installation...' );
			for ( i = 0; i < meta.length; i++ ) {
				action = meta[ i ][ 0 ];
				if ( action === 'link' ) {
					ndir = meta[ i ][ 2 ];
					if ( fs.existsSync( ndir ) ) {
						debug( 'Directory exists: %s', ndir );
					} else {
						FLG = true;
						odir = meta[ i ][ 1 ];

						debug( 'Moving: %s...', path.basename( odir ) );
						fs.linkSync( odir, ndir );
					}
				}
			}
			if ( FLG ) {
				debug( 'Re-installation complete.' );
			} else {
				debug( 'Installation okay.' );
			}
			debug( 'Aborting script execution...' );
			return;
		}
		debug( 'Meta data file does not exist. Proceeding with post-install sequence...' );
	}

	debug( 'Checking file system context...' );
	if ( !RE_SCRIPT_CONTEXT.test( __filename ) ) {
		debug( 'Detected non-node_modules context. Aborting script execution...' );
		return;
	}
	debug( 'Detected node_modules context.' );

	debug( 'Root directory: %s', ROOT_DIR );
	debug( 'Package directory: %s', PKG_DIR );
	debug( 'Destination directory: %s', DEST_DIR );

	out = [];

	debug( 'Checking for root node_modules...' );
	odir = path.join( ROOT_DIR, NODE_MODULES );
	if ( fs.existsSync( odir ) ) {
		debug( 'Detected root node_modules.' );
		ndir = path.join( DEST_DIR, NODE_MODULES );
		if ( fs.existsSync( ndir ) ) {
			debug( 'Destination directory already exists: %s. Skipping...', ndir );
			console.warn( 'WARNING: path conflict. node_modules directory already exists.' );
		} else {
			debug( 'Moving node_modules directory...' );
			fs.linkSync( odir, ndir );
			out.push( [ 'link', odir, ndir ] );
		}
	} else {
		debug( 'Creating root node_modules directory...' );
		fs.mkdirSync( odir );
		out.push( [ 'create', odir ] );
	}

	debug( 'Checking for a post-install lifecycle hook...' );
	ndir = path.join( odir, '.hooks' );
	p = path.join( ndir, 'postinstall' );
	if ( fs.existsSync( p ) ) {
		debug( 'Post-install lifecyle hook already exists: %s. Skipping...', p );
		console.warn( 'WARNING: post-install hook conflict. File already exists: %s.', p );
	} else {
		if ( !fs.existsSync( ndir ) ) {
			debug( 'Creating .hooks directory: %s', ndir );
			fs.mkdirSync( ndir );
			out.push( [ 'create', ndir ] );
		}
		debug( 'Creating post-install lifecycle hook...' );
		fs.writeFileSync( p, LIFECYCLE_HOOK, {
			'encoding': 'utf8'
		});
		out.push( [ 'create', p ] );
	}

	debug( 'Reading package directory...' );
	list = fs.readdirSync( PKG_DIR );

	debug( 'Moving package directory contents...' );
	for ( i = 0; i < list.length; i++ ) {
		f = list[ i ];
		odir = path.join( PKG_DIR, f);
		stats = fs.statSync( odir );
		if ( stats.isDirectory() === false ) {
			debug( 'Found a non-directory: %s. Skipping...', f );
			continue;
		}
		ndir = path.join( DEST_DIR, f );
		if ( fs.existsSync( ndir ) ) {
			debug( 'Destination directory already exists: %s. Skipping...', ndir );
			console.warn( 'WARNING: package conflict. Package directory already exists: %s.', f );
		} else {
			debug( 'Moving: %s...', f );
			fs.linkSync( odir, ndir );
			out.push( [ 'link', odir, ndir ] );
		}
	}
	debug( 'Finished post-install sequence.' );

	debug( 'Saving changes...' );
	opts = {
		'encoding': 'utf8'
	};
	fs.writeFileSync( OUTPUT_FILE, JSON.stringify( out )+'\n', opts );
	debug( 'Finished saving changes.' );
}

main();
